# 数据结构与算法

术有千法 道本归一



理论把具体提取为抽象

实践是把抽象实用为具体



纸上得来终觉浅 绝知此事要躬行









![img](D:\01\技术\笔记\md文档\数据结构与算法.assets\wps781D.tmp-1740015035071-1.jpg)

这个图就是告诉我自己，下文内容只是讲述抽象模型，要会具体应用才行。

















## 开始

------------------------------------------------------------------------------------------------------------------------------------------------------------



### 数组、单链表

为了分别体现存储结构的顺序存储和链式存储。

 

****顺序存储相关操作及实现-数组\****



```java
public class StaitcArray{
    
    int[] array = new int[10];
    
    int a = array[0];
    
}
```

静态数组因为随机访问，查找复杂度始终O(1)，但增删操作步骤多、效率低，动态数组算是对静态数组进行了操作封装，解决了步骤多这一问题

效率低是因为连续空间这一特性带来的影响，没能避免



```c++
// 创建动态数组
// 不用显式指定数组大小，它会根据实际存储的元素数量自动扩缩容
vector<int> arr;

for (int i = 0; i < 10; i++) {
    // 在末尾追加元素，时间复杂度 O(1)
    arr.push_back(i);
}

// 在中间插入元素，时间复杂度 O(N)
// 在索引 2 的位置插入元素 666
arr.insert(arr.begin() + 2, 666);

// 在头部插入元素，时间复杂度 O(N)
arr.insert(arr.begin(), -1);

// 删除末尾元素，时间复杂度 O(1)
arr.pop_back();

// 删除中间元素，时间复杂度 O(N)
// 删除索引 2 的元素
arr.erase(arr.begin() + 2);

// 根据索引查询元素，时间复杂度 O(1)
int a = arr[0];

// 根据索引修改元素，时间复杂度 O(1)
arr[0] = 100;

// 根据元素值查找索引，时间复杂度 O(N)
int index = find(arr.begin(), arr.end(), 666) - arr.begin();
```

 



​	**动态数组实现原理**

要注意的点：扩缩容机制、索引越界检查、内存泄漏

​	扩缩容机制

在基础上扩大2倍、当元素是数组大小的1/4，缩减至原大小1/2

​	索引越界检查

有两个检查越界的方法，分别是 `checkElementIndex` 和 `checkPositionIndex`，你可以看到它俩的区别仅仅在于 `index < size` 和 `index <= size`。

size是数组大小，假设size=9，那合法索引就是0-8，但这是对索引而言合法。对于元素插入，9也是合法位置，毕竟确实可以插入（数组因为索引越界在位置9得到的值不合法，那是索引的事儿，和插入无关）



​	内存泄漏

删除元素记得置为null











在 Java 里，E 属于泛型类型参数。泛型的作用是让类、接口或者方法能够处理多种不同类型的数据，同时保证类型的安全性。当你在定义一个泛型类时，能够使用泛型类型参数来代表任意类型。

​        // 注意：不能直接 new E[capacity]，需要进行类型转换

​        data = (E[]) new Object[capacity];

this(INIT_CAP); 是什么操作，this 到底是类还是方法

this(INIT_CAP); 属于构造方法的调用，也就是在一个构造方法里调用同一个类的另一个构造方法。this 在这里并不是类也不是方法，而是一个引用变量，它指向当前对象。

下面是一个使用 this 调用构造方法的示例：

java

public class MyClass {

​    private int capacity;



​    public MyClass() {

​        // 调用另一个构造方法

​        this(10); 

​    }



​    public MyClass(int capacity) {

​        this.capacity = capacity;

​    }

}









### 二叉树



#### 各种各样的二叉树

非线性数据结构

```java
/* 二叉树节点类 */
class TreeNode {
    int val;         // 节点值
    TreeNode left;   // 左子节点引用
    TreeNode right;  // 右子节点引用
    TreeNode(int x) { val = x; }
}
```



- 根节点（root node）：位于二叉树顶层的节点，没有父节点。
- 叶节点（leaf node）：没有子节点的节点，其两个指针均指向 `None` 。
- 边（edge）：连接两个节点的线段，即节点引用（指针）。
- 节点所在的层（level）：从顶至底递增，根节点所在层为 1 。
- 节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。
- 二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。
- 节点的深度（depth）：从根节点到该节点所经过的边的数量。
- 节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。



**完美二叉树**

![image-20250329145046044](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329145046044.png)



**完全二叉树**

![image-20250329145125898](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329145125898.png)







**二叉搜索树	镜像二叉搜索树**

搜索树是	左子树节点值<根<右子树节点值

根节点是相对而言的

二叉搜索树不允许存在重复节点



查找

```java
/* 查找节点 */
TreeNode search(int num) {
    TreeNode cur = root;
    // 循环查找，越过叶节点后跳出
    while (cur != null) {
        // 目标节点在 cur 的右子树中
        if (cur.val < num)
            cur = cur.right;
        // 目标节点在 cur 的左子树中
        else if (cur.val > num)
            cur = cur.left;
        // 找到目标节点，跳出循环
        else
            break;
    }
    // 返回目标节点
    return cur;
}
```

插入

- 为了实现插入节点，我们需要借助节点 `pre` 保存上一轮循环的节点。这样在遍历至 `None` 时，我们可以获取到其父节点，从而完成节点插入操作。

```java
/* 插入节点 */
void insert(int num) {
    // 若树为空，则初始化根节点
    if (root == null) {
        root = new TreeNode(num);
        return;
    }
    TreeNode cur = root, pre = null;
    // 循环查找，越过叶节点后跳出
    while (cur != null) {
        // 找到重复节点，直接返回
        if (cur.val == num)
            return;
        pre = cur;
        // 插入位置在 cur 的右子树中
        if (cur.val < num)
            cur = cur.right;
        // 插入位置在 cur 的左子树中
        else
            cur = cur.left;
    }
    // 插入节点
    TreeNode node = new TreeNode(num);
    if (pre.val < num)
        pre.right = node;
    else
        pre.left = node;
}
```



删除

- 根据目标节点的子节点数量，分 0、1 和 2 三种情况，执行对应的删除节点操作。

    如图 7-19 所示，当待删除节点的度为 0 时，表示该节点是叶节点，可以直接删除。

```java
/* 删除节点 */
void remove(int num) {
    // 若树为空，直接提前返回
    if (root == null)
        return;
    TreeNode cur = root, pre = null;
    // 循环查找，越过叶节点后跳出
    while (cur != null) {
        // 找到待删除节点，跳出循环
        if (cur.val == num)
            break;
        pre = cur;
        // 待删除节点在 cur 的右子树中
        if (cur.val < num)
            cur = cur.right;
        // 待删除节点在 cur 的左子树中
        else
            cur = cur.left;
    }
    // 若无待删除节点，则直接返回
    if (cur == null)
        return;
    // 子节点数量 = 0 or 1
    if (cur.left == null || cur.right == null) {
        // 当子节点数量 = 0 / 1 时， child = null / 该子节点
        TreeNode child = cur.left != null ? cur.left : cur.right;
        // 删除节点 cur
        if (cur != root) {
            if (pre.left == cur)
                pre.left = child;
            else
                pre.right = child;
        } else {
            // 若删除节点为根节点，则重新指定根节点
            root = child;
        }
    }
    // 子节点数量 = 2
    else {
        // 获取中序遍历中 cur 的下一个节点
        TreeNode tmp = cur.right;
        while (tmp.left != null) {
            tmp = tmp.left;
        }
        // 递归删除节点 tmp
        remove(tmp.val);
        // 用 tmp 覆盖 cur
        cur.val = tmp.val;
    }
}
```



二叉树的中序遍历遵循“左 → 根 → 右”的遍历顺序，而二叉搜索树满足“左子节点 < 根节点 < 右子节点”的大小关系。

这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：**二叉搜索树的中序遍历序列是升序的**。

利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需 O(n) 时间，无须进行额外的排序操作，非常高效。

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329150502705.png" alt="image-20250329150502705" style="zoom:50%;" />





**平衡搜索二叉树	AVL**

![image-20250329145149939](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329145149939.png)

AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种平衡二叉搜索树。



出现AVL树的原因是  二叉树如果只朝一条路径填充，就会变为链表

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329145233272.png" alt="image-20250329145233272" style="zoom:50%;" />

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329145307269.png" alt="image-20250329145307269" />

通过平衡二叉树，不断进行调整，可以避免这种情况



AVL 树的相关操作需要获取节点高度，因此我们需要为节点类添加 `height` 变量

```java
/* AVL 树节点类 */
class TreeNode {
    public int val;        // 节点值
    public int height;     // 节点高度
    public TreeNode left;  // 左子节点
    public TreeNode right; // 右子节点
    public TreeNode(int x) { val = x; }
}
```

“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。

需要特别注意的是，叶节点的高度为 0 ，而空节点的高度为 −1 。我们将创建两个工具函数，分别用于获取和更新节点的高度

```java
/* 获取节点高度 */
int height(TreeNode node) {
    // 空节点高度为 -1 ，叶节点高度为 0
    return node == null ? -1 : node.height;
}

/* 更新节点高度 */
void updateHeight(TreeNode node) {
    // 节点高度等于最高子树高度 + 1
    node.height = Math.max(height(node.left), height(node.right)) + 1;
}
```

节点的平衡因子（balance factor）定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为 0 。平衡因子应在-1到1之间

```java
/* 获取平衡因子 */
int balanceFactor(TreeNode node) {
    // 空节点平衡因子为 0
    if (node == null)
        return 0;
    // 节点平衡因子 = 左子树高度 - 右子树高度
    return height(node.left) - height(node.right);
}
```



AVL树旋转

若失衡，旋转

在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。



旋转👉右旋、左旋、右左旋、左右旋



选择旋转的情况：

- 右旋：   左子树的左子节点（LL 情况）插入导致失衡

- 左旋：   右子树的右子节点（RR 情况）插入导致失衡

- 左右旋：左子树的右子节点（LR 情况）插入导致失衡

- 右左旋：右子树的左子节点（RL 情况）插入导致失衡

    

| 失衡节点的平衡因子 | 子节点的平衡因子 | 应采用的旋转方法 |
| :----------------- | :--------------- | :--------------- |
| >1 （左偏树）      | ≥0               | 右旋             |
| >1 （左偏树）      | <0               | 先左旋后右旋     |
| <−1 （右偏树）     | ≤0               | 左旋             |
| <−1 （右偏树）     | >0               | 先右旋后左旋     |







**右旋**

1. 将失衡节点的左子节点作为新的根节点。
2. 新的根节点的右子树变为失衡节点的左子树。
3. 失衡节点变为新根节点的右子树。

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329161237357.png" alt="image-20250329161237357" style="zoom:50%;" />

左旋同理

1. 将失衡节点的右子节点作为新的根节点。
2. 新的根节点的左子树变为失衡节点的右子树。
3. 失衡节点变为新根节点的左子树



因为原理相同，代码相差不大

```java
// 流程就是保存要被交换的节点
// 交换节点
// 更新高度
// 返回这棵子树 新的根节点

/* 右旋操作 */
// rotate  旋转
TreeNode rightRotate(TreeNode node) {
    TreeNode child = node.left;
    TreeNode grandChild = child.right;
    // 以 child 为原点，将 node 向右旋转
    child.right = node;
    node.left = grandChild;
    // 更新节点高度
    updateHeight(node);
    updateHeight(child);
    // 返回旋转后子树的根节点
    return child;
}


/* 左旋操作 */
//	right left 互换
TreeNode leftRotate(TreeNode node) {
    TreeNode child = node.right;
    TreeNode grandChild = child.left;
    // 以 child 为原点，将 node 向左旋转
    child.left = node;
    node.right = grandChild;
    // 更新节点高度
    updateHeight(node);
    updateHeight(child);
    // 返回旋转后子树的根节点
    return child;
}

```



先左旋再右旋

1. 对左子树进行 RR 旋转（左旋转）。
2. 对当前节点进行 LL 旋转（右旋转）。

![image-20250329161711831](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329161711831.png)



先右旋再左旋

1. 对右子树进行 LL 旋转（右旋转）。
2. 对当前节点进行 RR 旋转（左旋转）。







所有操作封装（参考刚开始那张表格）

```java
/* 执行旋转操作，使该子树重新恢复平衡 */
TreeNode rotate(TreeNode node) {
    // 获取节点 node 的平衡因子
    int balanceFactor = balanceFactor(node);
    // 左偏树
    if (balanceFactor > 1) {
        if (balanceFactor(node.left) >= 0) {
            // 右旋
            return rightRotate(node);
        } else {
            // 先左旋后右旋
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
    }
    // 右偏树
    if (balanceFactor < -1) {
        if (balanceFactor(node.right) <= 0) {
            // 左旋
            return leftRotate(node);
        } else {
            // 先右旋后左旋
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }
    }
    // 平衡树，无须旋转，直接返回
    return node;
}
```









AVL树的插入和删除

无论插入还是删除，都可能导致该节点到根节点路径上一系列的失衡



插入

从这个节点开始，**自底向上**执行旋转操作，使所有失衡节点恢复平衡



删除

在二叉搜索树的删除节点方法的基础上，需要从底至顶执行旋转操作





















#### **二叉树的遍历**

先序、中序、后序

DFS

BFS

层序（是一种广度优先）







**最近共同祖先	LCA**

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250401205157155.png" alt="image-20250401205157155" style="zoom:50%;" />

LCA指在树结构中，两个节点的最深层共同祖先

节点自身以及它所在路径的所有上级节点，都是它的祖先节点

- 如 6 ，653都是6的祖先

- 4的祖先是253，64共同祖先是53，最近共同祖先是5



| 算法        | 预处理时间 | 查询时间 | 空间复杂度 | 适用场景     |
| ----------- | ---------- | -------- | ---------- | ------------ |
| 暴力法      | O(1)       | O(n)     | O(1)       | 小规模数据   |
| DFS/BFS     | O(1)       | O(n)     | O(n)       | 小规模数据   |
| 倍增法      | O(n log n) | O(log n) | O(n log n) | 中等规模数据 |
| Tarjan 离线 | O(n α(n))  | O(1)     | O(n)       | 批量查询     |
| 树链剖分    | O(n log n) | O(log n) | O(n)       | 动态树结构   |



问题

找出二叉树中p、q节点的最近共同祖先

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250401205900763.png" alt="image-20250401205900763" style="zoom:50%;" />

左右子树都没找到：采用递归，当前递归A子树，但pq都在B子树

讨论结果

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250401210532332.png" alt="image-20250401210532332" style="zoom:50%;" />





| 算法               | 预处理时间 | 查询时间 | 空间        | 适用场景                |
| ------------------ | ---------- | -------- | ----------- | ----------------------- |
| **DFS 序 + ST 表** | O(n log n) | O(1)     | O(n log n)  | 静态树，高频 LCA 查询   |
| **欧拉序 + ST 表** | O(n log n) | O(1)     | O(2n log n) | 静态树，路径相关查询    |
| **倍增法**         | O(n log n) | O(log n) | O(n log n)  | 静态树，综合性能均衡    |
| **树链剖分**       | O(n)       | O(log n) | O(n)        | 静态树，需子树操作      |
| **Tarjan**         | O(n + q)   | O(1)     | O(n)        | 离线查询，大量 LCA 请求 |



下面实现BF递归实现+BF添加父指针实现、DFS+ST、Tarjan、倍增LCA



​	**BF递归**

适合树的结构相对稳定，且只需要进行少量的 LCA 查询的情景

如果是二叉树

```java
//	纯递归版本，不推荐

package TestField;

import java.util.*;

class Main {

	static class Node {
		int val;
		Node left;
		Node right;

		public Node(int val) {
			this.val = val;
		}
	}

	static Node getLCA(Node root, Node n1, Node n2) {
		if (root == null)
			return null;
		if (root == n1 || root == n2)
			return root;

		Node left = getLCA(root.left, n1, n2);
		Node right = getLCA(root.right, n1, n2);

		if (left != null && right != null)
			return root;
		if (left != null)
			return left;
		if (right != null)
			return right;

		// n1 n2 不在树中的情况
		return null;

	}


	public static void main(String[] args) {
		// 构建一个简单的二叉树
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);

		// 测试用例 1：n1 和 n2 分别在左右子树
		Node n1 = root.left.left;
		Node n2 = root.right;
		Node lca1 = getLCA(root, n1, n2);
		System.out.println("n1 和 n2 的最近公共祖先是: " + (lca1 != null ? lca1.val : "null"));

		// 测试用例 2：n1 和 n2 都在左子树
		n1 = root.left.left;
		n2 = root.left.right;
		Node lca2 = getLCA(root, n1, n2);
		System.out.println("n1 和 n2 的最近公共祖先是: " + (lca2 != null ? lca2.val : "null"));

		// 测试用例 3：n1 是 n2 的祖先
		n1 = root.left;
		n2 = root.left.right;
		Node lca3 = getLCA(root, n1, n2);
		System.out.println("n1 和 n2 的最近公共祖先是: " + (lca3 != null ? lca3.val : "null"));
	}

}

```



​	**BF添加父指针实现**

给树节点添加指向它父节点的指针，问题转化为 寻找两个单向链表的第一个公共结点

树还是树，因为树结构摆在那，即使加了指针，效率受影响，但没退化为单链表

且 引入父节点，时间复杂度降至O（h），h为树高

```java
package TestField;

import java.util.HashSet;
import java.util.Set;

class Main {
	static class Node {
		int val;
		Node left;
		Node right;
		Node parent;

		public Node(int val) {
			this.val = val;
		}
	}

	// 设置父节点
	private static void setParents(Node root) {
		if (root == null)
			return;
		if (root.left != null) {
			root.left.parent = root;
			setParents(root.left);
		}
		if (root.right != null) {
			root.right.parent = root;
			setParents(root.right);
		}
	}

    // 获取最近公共祖先
	static Node getLCA(Node n1, Node n2) {
		Set<Node> visited = new HashSet<>();
		while (n1 != null) {
            // 不断的存储n1的祖先
			visited.add(n1);
			n1 = n1.parent;
		}
		while (n2 != null) {
            // 如果找到了，这个祖先就是n1n2共同的祖先
			if (visited.contains(n2))
				return n2;
			n2 = n2.parent;
		}
        // 如果n2祖先里没有n1的，说明它俩没有公共祖先，连root都没有，可以说n2不存在
		return null;
	}
    
	public static void main(String[] args) {
		// 构建树结构
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);

		// 自动设置父节点
		setParents(root);

		// 测试用例 1：n1 和 n2 分别在左右子树
		Node n1 = root.left.left;
		Node n2 = root.right;
		Node lca1 = getLCA(n1, n2);
		System.out.println("n1 和 n2 的最近公共祖先是:" + (lca1 != null ? lca1.val : "null"));

		// 测试用例 2：n1 和 n2 都在左子树
		n1 = root.left.left;
		n2 = root.left.right;
		Node lca2 = getLCA(n1, n2);
		System.out.println("n1 和 n2 的最近公共祖先是:" + (lca2 != null ? lca2.val : "null"));

		// 测试用例 3：n1 是 n2 的祖先
		n1 = root.left;
		n2 = root.left.right;
		Node lca3 = getLCA(n1, n2);
		System.out.println("n1 和 n2 的最近公共祖先是:" + (lca3 != null ? lca3.val : "null"));
	}
}
```





二叉搜索树，只有BF写了二叉搜索树的LCA	

```java
package TestField;

import java.util.*;

class MainCopy {

	static class Node {
		int value;
		Node left;
		Node right;

		public Node(int value) {
			this.value = value;
		}
	}

	static Node getLCA(Node t, Node u, Node v) {
	    int left = Math.min(u.value, v.value);
	    int right = Math.max(u.value, v.value);
	    
	    while (true) {
	        if (t.value < left) t = t.right;
	        else if (t.value > right) t = t.left;
	        else return t;
	    }
	}

	public static void main(String[] args) {
		Node root = new Node(6);
		root.left = new Node(2);
		root.right = new Node(8);
		root.left.left = new Node(0);
		root.left.right = new Node(4);
		root.right.left = new Node(7);
		root.right.right = new Node(9);

		Node u = root.left;
		Node v = root.right;
		Node lcaNode = getLCA(root, u, v);
		System.out.println("节点 " + u.value + " 和节点 " + v.value + " 的最近公共祖先节点为: " + lcaNode.value);

	}
}
```





​	**DFS+ST**

DFS使用了ST表

本来只有DFS，但是如果把LCA问题转换成RMQ问题，就可以使用ST表优化效率





**为什么能转换**

二叉树本身是有深度的

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250408111329645.png" alt="image-20250408111329645" style="zoom:50%;" /> 

树用数组表示，找出2节点间区间深度最浅的，那就是答案

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250408112137240.png" alt="image-20250408112137240" style="zoom:50%;" />

上面这张表使用三个数组: **fir[]** 节点在序列中首次出现的序号、 **d[]** 节点深度表 、 **dfn[]** dfs序 ， 需要注意的是欧拉序会重复加入节点，所以数组大小需要扩大一倍。



```java
package TestField;

import java.util.*;

public class Main {

	static class Node {
		int val;
		Node parent;
		// 该节点所有相邻节点，应排除父节点
		List<Node> children;
		int nodeDFN; // dfs时间戳，记录node该node的dfs深度，或着说它在树里所在的层次

		public Node(int val) {
			this.val = val;
			children = new ArrayList<>();
		}
	}

	// 这个dfs用来初始化node的dfn
	private static int dfn = 0;
	private static int[][] st;
	// 最大倍增层数（根据节点数调整，此处假设节点数≤2^20）
	private static int log = 20;

	// 这个DFS用来标记tree的所有节点所在层次以及父节点
	public static void DFS(Node node, Node parent) {
		node.parent = parent;
//		分配dfs序时间戳，从1开始递增
		node.nodeDFN = ++dfn;
//		初始化st第0层：每个位置父节点（根节点的父节点为-1）
		st[0][node.nodeDFN] = parent == null ? -1 : parent.val;
//		递归处理子节点：（排除父节点、避免回环）
		for (Node child : node.children) {
			if (child != parent) {
				DFS(child, node);
			}
		}
	}

	public static void ST(int n) {

		for (int j = 1; j < log; ++j) {
			for (int i = 1; i + (1 << j) - 1 <= n; ++i) {
				int left = st[j - 1][i];
				int right = st[j - 1][i + (1 << (j - 1))];
// 比较左、右结果对应的节点的dfn，选择dfn较小的（即更接近祖先的节点）
				if (left == -1) {
					st[j][i] = right;
				} else if (right == -1) {
					st[j][i] = left;
				} else {
					st[j][i] = dfnMap.get(left) < dfnMap.get(right) ? left : right;
				}
			}
		}
	}

	public static int LCA(int u, int v) {
		// 特殊判断：节点自身
		if (u == v)
			return u;
		// return v;

		// 获取u和v的dfn
		int dfnU = dfnMap.get(u);
		int dfnV = dfnMap.get(v);
		// 获取长度
		int len = (int) (Math.log(Math.abs(dfnU - dfnV)) / Math.log(2));

		// 查询区间[dfnU+1, dfnV]内的两个子区间
		int node1 = st[len][dfnU + 1];// 左子区间起点：dfnU+1，长度2^k
		int node2 = st[len][dfnV - (1 << len) + 1];// 右子区间起点：dfnV - 2^k + 1
		// 比较两个子区间的结果，选择dfn较小的节点（更接近祖先）
		int ancestor = (dfnMap.get(node1) < dfnMap.get(node2)) ? node1 : node2;
		// 返回祖先节点的值（根节点的父节点为-1，但此处假设输入合法）
		return ancestor == -1 ? -1 : ancestor;

	}

	private static Map<Integer, Integer> dfnMap = new HashMap<>();

	public static void main(String[] args) {
		// 构建树结构
		Node root = new Node(1);
		Node node2 = new Node(2);
		Node node3 = new Node(3);
		Node node4 = new Node(4);
		Node node5 = new Node(5);
		root.children.add(node2);
		root.children.add(node3);
		node2.children.add(node4);
		node2.children.add(node5);

		// 初始化ST表
		dfn = 0;
		int n = 5; // 节点数
		st = new int[log][n + 1];
		DFS(root, null);// 从根节点开始DFS

		// 填充（节点值→dfn）
		Queue<Node> queue = new LinkedList<>();
		queue.add(root);
		while (!queue.isEmpty()) {
			Node node = queue.poll();
			dfnMap.put(node.val, node.nodeDFN);
			// queue.addAll(node.children); // 遍历所有节点
			for (Node child : node.children) {
				queue.add(child);
			}
		}
// 构建ST表
		ST(n);

		// 测试LCA查询
		System.out.println(LCA(4, 3)); // 输出1
		System.out.println(LCA(4, 5)); // 输出2
		System.out.println(LCA(2, 5)); // 输出2
	}
}
```



如果 批量查询公共祖先，可以 借鉴**离线处理**的方式(处理所有查询前，先收集所有查询请求，统一处理)，由此引入Tarjan算法

再加上并查集（Union-Find）和深度优先搜索（DFS）来优化计算过程



**Tarjan算法**

本是图论中的算法(图论中我没收录2025年4月5日)

Tarjan是离线算法，就是预处理，然后1次遍历解决所有查询

1. dfs遍历，并查集优化
2. 任选一个点为根节点，从根节点开始。
3. 遍历该点u所有子节点v，并标记这些子节点v已被访问过。
4. 若是v还有子节点，对子节点重复步骤2，否则下一步。
5. 合并v到u上（合并子节点到父节点）。
6. 寻找与当前点u有询问关系的点v。
7. 若是v已经被访问过了，则可以确认u和v的最近公共祖先为v被合并到的父亲节点。



解决普通二叉树LCA问题、二叉搜索树就不写了

```java
//	使用递归会导致栈溢出

package TestField;

import java.util.*;

public class Main {

	static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode(int x) {
			val = x;
		}
	}

	static class BinaryTreeLCA {
		public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
			// 如果根节点为空，或者根节点就是 p 或 q，直接返回根节点
			if (root == null || root == p || root == q) {
				return root;
			}
			// 递归查找左子树中 p 和 q 的 LCA
			TreeNode left = lowestCommonAncestor(root.left, p, q);
			// 递归查找右子树中 p 和 q 的 LCA
			TreeNode right = lowestCommonAncestor(root.right, p, q);

			// 如果左子树和右子树都找到了 p 或 q 的祖先，说明根节点就是 LCA
			if (left != null && right != null) {
				return root;
			}
			// 如果左子树找到了 p 或 q 的祖先，返回左子树的结果
			if (left != null) {
				return left;
			}
			// 否则返回右子树的结果
			return right;
		}
	}

	public static void main(String[] args) {
		// 构建一个简单的二叉树
		TreeNode root = new TreeNode(3);
		root.left = new TreeNode(5);
		root.right = new TreeNode(1);
		root.left.left = new TreeNode(6);
		root.left.right = new TreeNode(2);
		root.right.left = new TreeNode(0);
		root.right.right = new TreeNode(8);
		root.left.right.left = new TreeNode(7);
		root.left.right.right = new TreeNode(4);

		BinaryTreeLCA solution = new BinaryTreeLCA();
		TreeNode p = root.left; // 节点 5
		TreeNode q = root.right; // 节点 1
		TreeNode lca = solution.lowestCommonAncestor(root, p, q);
		System.out.println("节点 " + p.val + " 和节点 " + q.val + " 的最近公共祖先是: " + lca.val);
	}
}
```



​	**解决图的LCA问题**

Tarjan也能解决多叉树问题，多叉树本质上也是特殊结构的图

- 使用栈 `stack` 模拟递归调用，`nextChild` 数组记录每个节点下一个要访问的子节点的索引。
- 从根节点开始，将根节点压入栈中。
- 当栈不为空时，取出栈顶节点 `u`，如果 `u` 未被访问过，则标记为已访问。
- 遍历 `u` 的所有子节点，找到第一个未被访问的子节点 `v`，将 `v` 压入栈中，并标记 `u` 有未访问的子节点。
- 如果 `u` 没有未访问的子节点，说明 `u` 的所有子节点都已处理完毕，将 `u` 出栈。
- 处理与 `u` 相关的所有查询，如果查询的另一个节点 `v` 已被访问过，则 `u` 和 `v` 的 LCA 就是 `v` 所在集合的根节点。
- 如果栈不为空，将 `u` 合并到其父节点所在的集合中。

```java
//	使用递归会导致栈溢出

package TestField;

import java.util.*;

public class Main {

	static class TarjanLCA {
        // 节点数
		private int n;
        //	邻接表
		private List<List<Integer>> adjList;
        //	存储所有查询信息  queries.get(u) 存储了所有与节点 u 相关的查询，每个查询用一个长度为 2 的数组 {v, index} 表示，其中 v 是查询的另一个节点，index 是查询的编号
		private List<List<int[]>> queries;
		//	并查集
        private int[] parent;
        //	是否访问过
		private boolean[] visited;
		//	存储查询结果，ans[index]表示编号index的查询结果	，默认-1
        private int[] ans;

		public TarjanLCA(int n) {
			this.n = n;
			adjList = new ArrayList<>();
			queries = new ArrayList<>();
			for (int i = 0; i <= n; i++) {
				adjList.add(new ArrayList<>());
				queries.add(new ArrayList<>());
			}
			parent = new int[n + 1];
			visited = new boolean[n + 1];
			ans = new int[n + 1];
			Arrays.fill(ans, -1);
			for (int i = 1; i <= n; i++) {
				parent[i] = i;
			}
		}

		public void addEdge(int u, int v) {
			adjList.get(u).add(v);
			adjList.get(v).add(u);
		}

		public void addQuery(int u, int v, int index) {
			queries.get(u).add(new int[] { v, index });
			queries.get(v).add(new int[] { u, index });
		}

		private int find(int x) {
			if (parent[x] != x) {
				parent[x] = find(parent[x]);
			}
			return parent[x];
		}

		private void union(int x, int y) {
			int rootX = find(x);
			int rootY = find(y);
			if (rootX != rootY) {
				parent[rootY] = rootX;
			}
		}

		public void tarjan(int root) {
			Stack<Integer> stack = new Stack<>();
			int[] nextChild = new int[n + 1];
			stack.push(root);

			while (!stack.isEmpty()) {
				int u = stack.peek();
				if (!visited[u]) {
					visited[u] = true;
				}

				boolean hasUnvisitedChild = false;
				while (nextChild[u] < adjList.get(u).size()) {
					int v = adjList.get(u).get(nextChild[u]);
					if (!visited[v]) {
						stack.push(v);
						hasUnvisitedChild = true;
						nextChild[u]++;
						break;
					}
					nextChild[u]++;
				}

				if (!hasUnvisitedChild) {
					stack.pop();
					for (int[] query : queries.get(u)) {
						int v = query[0];
						int index = query[1];
						if (visited[v]) {
							ans[index] = find(v);
						}
					}
					if (!stack.isEmpty()) {
						int parentNode = stack.peek();
						union(parentNode, u);
					}
				}
			}
		}

		public int[] getAnswers() {
			return ans;
		}

	}

	public static void main(String[] args) {
		int n = 7;
		TarjanLCA lca = new TarjanLCA(n);
		lca.addEdge(1, 2);
		lca.addEdge(1, 3);
		lca.addEdge(2, 4);
		lca.addEdge(2, 5);
		lca.addEdge(3, 6);
		lca.addEdge(3, 7);

		// 添加查询
		lca.addQuery(4, 5, 0);
		lca.addQuery(4, 6, 1);
		lca.addQuery(6, 7, 2);
		// 模拟查询节点自身与自身的 LCA
		lca.addQuery(4, 4, 3);

		// 任选一个点作为根节点开始 Tarjan 算法
		lca.tarjan(1);

		int[] answers = lca.getAnswers();
		for (int i = 0; i < answers.length; i++) {
			if (answers[i] == -1) {
				System.out.println("查询 " + i + " 未得到有效结果");
			} else {
				System.out.println("查询 " + i + " 的结果是: " + answers[i]);
			}
		}
	}
}
```







**倍增LCA**(在线)

引入二维的 f 数组，来减少节点上跳次数。倍增思路和ST表思路差不多。
使用 f[x] [i] 来表示 点x 的第 2$$^i$$个祖先，而 f[x] [i] 数组可以通过dfs预处理出来。f[u] [i] = f [f[u] [i-1] ]  [i-1] , u 的第2$$^i$$个祖先,就是 u 的2$$^{i-1}$$个祖先的2$$^{i-1}$$个祖先

预处理

- **深度数组 `depth[]`**：记录每个节点到根节点的深度。
- **倍增数组 `up[][]`**：`up[i][j]` 表示节点 `i` 的 2*j* 级祖先。例如，`up[i][0]` 就是节点 `i` 的父节点，`up[i][1]` 是节点 `i` 的 21=2 级祖先（即父节点的父节点），以此类推。

查询

- 对于两个节点 `u` 和 `v`，先将它们调整到同一深度。
- 然后，从最大的 *k* 开始，尝试将 `u` 和 `v` 同时向上跳 2*k* 步，如果跳跃后它们的祖先不同，则继续向上跳；如果相同，则不跳。
- 最后，`u` 和 `v` 的父节点就是它们的最近公共祖先。

```java
import java.util.*;

class LCAWithBinaryLifting {
    private int n;
    private int LOG;
    private List<List<Integer>> adj;
    private int[] depth;
    private int[][] up;

    public LCAWithBinaryLifting(int n) {
        this.n = n;
        LOG = (int) (Math.log(n) / Math.log(2)) + 1; // 计算最大幂次
        adj = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            adj.add(new ArrayList<>());
        }
        depth = new int[n + 1];
        up = new int[LOG][n + 1];
    }

    public void addEdge(int u, int v) {
        adj.get(u).add(v);
        adj.get(v).add(u);
    }

    public void preprocess(int root) {
        // 初始化队列进行BFS
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(root);
        depth[root] = 1; // 根节点深度为1

        // 初始化每个节点的父节点（2^0级祖先）
        while (!queue.isEmpty()) {
            int u = queue.poll();
            for (int v : adj.get(u)) {
                if (depth[v] == 0 && v != up[0][u]) {
                    depth[v] = depth[u] + 1;
                    up[0][v] = u;
                    queue.offer(v);
                }
            }
        }

        // 填充倍增表
        for (int k = 1; k < LOG; k++) {
            for (int v = 1; v <= n; v++) {
                up[k][v] = up[k - 1][up[k - 1][v]];
            }
        }
    }

    public int query(int u, int v) {
        if (u == v) return u;

        // 确保u的深度不小于v
        if (depth[u] < depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }

        // 将u上移到与v同一深度
        for (int k = LOG - 1; k >= 0; k--) {
            if (depth[u] - (1 << k) >= depth[v]) {
                u = up[k][u];
            }
        }

        if (u == v) return u;

        // 同时上移u和v直到找到共同祖先
        for (int k = LOG - 1; k >= 0; k--) {
            if (up[k][u] != up[k][v]) {
                u = up[k][u];
                v = up[k][v];
            }
        }

        return up[0][u];
    }

    public static void main(String[] args) {
        int n = 7;
        LCAWithBinaryLifting lca = new LCAWithBinaryLifting(n);
        lca.addEdge(1, 2);
        lca.addEdge(1, 3);
        lca.addEdge(2, 4);
        lca.addEdge(2, 5);
        lca.addEdge(3, 6);
        lca.addEdge(3, 7);

        lca.preprocess(1); // 根节点为1

        // 测试用例
        System.out.println("LCA(4, 5) = " + lca.query(4, 5)); // 2
        System.out.println("LCA(4, 6) = " + lca.query(4, 6)); // 1
        System.out.println("LCA(6, 7) = " + lca.query(6, 7)); // 3
        System.out.println("LCA(2, 7) = " + lca.query(2, 7)); // 1
        System.out.println("LCA(5, 5) = " + lca.query(5, 5)); // 5
    }
}
```















#### 二叉树数组表示

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329145552730.png" alt="image-20250329145552730" style="zoom:50%;" />

父节点的数组下标是i,那么它的左孩子就是2 * i + 1,右孩子就是i * 2 + 2





### 堆

满足特定条件的完全二叉树

- 小顶堆（min heap）：任意节点的值 ≤ 其子节点的值。
- 大顶堆（max heap）：任意节点的值 ≥ 其子节点的值。



许多编程语言提供的是优先队列（priority queue），这是一种抽象的数据结构，定义为具有优先级排序的队列。

实际上，**堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列**。说白了就是从使用角度来看，“优先队列”和“堆”是同一种东西。

![image-20250329171400967](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250329171400967.png)

```java
/* 初始化堆 */
// 初始化小顶堆
Queue<Integer> minHeap = new PriorityQueue<>();
// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）
Queue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

/* 元素入堆 */
maxHeap.offer(1);
maxHeap.offer(3);
maxHeap.offer(2);
maxHeap.offer(5);
maxHeap.offer(4);

/* 获取堆顶元素 */
int peek = maxHeap.peek(); // 5

/* 堆顶元素出堆 */
// 出堆元素会形成一个从大到小的序列
peek = maxHeap.poll(); // 5
peek = maxHeap.poll(); // 4
peek = maxHeap.poll(); // 3
peek = maxHeap.poll(); // 2
peek = maxHeap.poll(); // 1

/* 获取堆大小 */
int size = maxHeap.size();

/* 判断堆是否为空 */
boolean isEmpty = maxHeap.isEmpty();

/* 输入列表并建堆 */
minHeap = new PriorityQueue<>(Arrays.asList(1, 3, 2, 5, 4));
```



堆正是一种完全二叉树，完全二叉树非常适合用数组来表示。所以用数组存储堆

​	入堆

给定元素添加至堆底，可能不符合堆的特性，要调整顺序，从这个节点开始**从底至顶执行堆化**。直至越过根节点或遇到无序交换的节点

```java
/* 元素入堆 */
void push(int val) {
    // 添加节点
    maxHeap.add(val);
    // 从底至顶堆化
    siftUp(size() - 1);
}

/* 从节点 i 开始，从底至顶堆化 */
void siftUp(int i) {
    while (true) {
        // 获取节点 i 的父节点
        int p = parent(i);
        // 当“越过根节点”或“节点无须修复”时，结束堆化
        if (p < 0 || maxHeap.get(i) <= maxHeap.get(p))
            break;
        // 交换两节点
        swap(i, p);
        // 循环向上堆化
        i = p;
    }
}
```



​	出堆

堆顶元素直接出去，会导致所有后续元素前移，破坏堆的父子节点关系

​	将堆顶元素（根节点）与数组末尾元素交换位置

​	移除末尾元素

​	从顶至底执行堆化

通过交换堆顶与末尾元素，仅需调整根节点的位置，其他节点的相对索引保持不变。

仅需从根节点开始堆化，时间复杂度为 *O*(log*n*)，远低于重新构建堆的 *O*(*n*)。



若直接删除

- 所有后续元素前移，索引改变。
- 父子节点关系被破坏（如原左子节点索引 `1` 变为 `0`，右子节点索引 `2` 变为 `1`）。
- 堆化操作无法正确找到子节点，导致逻辑错误。



























### 图

#### 基本概念

图（graph）是一种非线性数据结构，由顶点（vertex）和边（edge）组成。

将图抽象地表示为一组顶点和一组边的集合。



以下示例展示了一个包含 5 个顶点和 7 条边的图。

![image-20250225202540153](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250225202540153.png)



将顶点看作节点，边看作连接各个节点的引用（指针），图就成了一种从链表拓展而来的数据结构。





根据边是否有方向 分无向图（undirected graph）、有向图（directed graph）

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250225202707367.png" alt="image-20250225202707367" style="zoom:50%;" />



根据所有顶点是否互通 分为连通图（connected graph）、非连通图（disconnected graph）

- 对于连通图，从某个顶点出发可以到达任意顶点。
- 对于非连通图，从某个顶点出发至少有一个顶点无法到达。

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250225202827328.png" alt="image-20250225202827328" style="zoom:50%;" />





为边添加“权重”属性，从而得到有权图（weighted graph）。

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250225203009042.png" alt="image-20250225203009042" style="zoom:50%;" />



图数据结构的常用术语（参考上图）：

- 邻接（adjacency）：当两顶点之间存在边相连时，称这两顶点“邻接”。顶点 1 的邻接顶点为顶点 2、3、5。
- 路径（path）：顶点 A 到顶点 B 经过的边构成的序列被称为从 A 到 B 的“路径”。边序列 1-5-2-4 是顶点 1 到顶点 4 的一条路径。
- 度（degree）：一个顶点拥有的边数。对于有向图，入度（in-degree）表示有多少条边指向该顶点，出度（out-degree）表示有多少条边从该顶点指出。





连通、非连通、有权、无权 的图，一对是特征、一对是加了权值属性、本质还是看有向、无向图



所以以下代码只实现有向图、无向图



#### `图的表示 及 实现`

图的常用表示方式包括“邻接矩阵”和“邻接表”。

​	

邻接表和矩阵  都是存储1个节点所邻接的节点的关系



​		邻接矩阵

设图的顶点数量为 n ，邻接矩阵（adjacency matrix）使用一个 n×n 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 1 或 0 表示两个顶点之间是否存在边。

如图 9-5 所示，设邻接矩阵为 M、顶点列表为 V ，那么矩阵元素 M[i,j]=1 表示顶点 V[i] 到顶点 V[j] 之间存在边，反之 M[i,j]=0 表示两顶点之间无边。

![image-20250225203942240](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250225203942240.png)

对于简单图，顶点不能与自身相连，此时邻接矩阵主对角线元素没有意义。（用0表示）

对于无向图，两个方向的边等价，所以无向图 的 邻接矩阵关于主对角线对称。

邻接矩阵的元素从 10 替换为权重，表示有权图。



使用邻接矩阵表示图时，可以直接访问矩阵元素获取边，因此增删查改操作效率很高，时间复杂度均为 O(1) ，空间复杂度为 O(n^2) 。









​		邻接表

邻接表（adjacency list）使用 n 个链表来表示图，链表节点表示顶点。第 i 个链表对应顶点 i ，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。

![image-20250225204501858](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250225204501858.png)

邻接表仅存储实际存在的边，因此它更加节省空间。但因为用链表实现，需要遍历链表查找边，其时间效率不如邻接矩阵。

**邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似的方法来优化效率**。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从 O(n) 优化至 O(log⁡n) ；还可以把链表转换为哈希表，从而将时间复杂度降至 O(1) 。



还有逆邻接表

注意：
邻接表：反映的是顶点出度的情况。
逆邻接表：反映的是顶点的入度情况。





#### 邻接表和邻接矩阵对比

| **邻接矩阵**                                       | **邻接表**                                                   |
| -------------------------------------------------- | ------------------------------------------------------------ |
| 二维数组，大小为 *V*×*V*（*V* 为顶点数）           | 数组 / 链表 / 哈希表存储每个顶点的邻接顶点列表               |
| 示例： `matrix[i][j] = 1` 表示顶点 *i* 到 *j* 有边 | 示例： `adjList[i] = [j, k]` 表示顶点 *i* 的邻接顶点为 *j*,*k* |



时间复杂度

| **操作**                  | **邻接矩阵** | **邻接表** |
| ------------------------- | ------------ | ---------- |
| 查询边是否存在（*i*→*j*） | *O*(1)       | *O*(出度)  |
| 添加边（*i*→*j*）         | *O*(1)       | *O*(1)     |
| 删除边（*i*→*j*）         | *O*(1)       | *O*(出度)  |
| 遍历所有邻接顶点          | *O*(*V*)     | *O*(出度)  |



空间复杂度

| **图类型**     | **邻接矩阵** | **邻接表**   |
| -------------- | ------------ | ------------ |
| 稀疏图（边少） | *O*(*V*2)    | *O*(*V*+*E*) |
| 稠密图（边多） | *O*(*V*2)    | *O*(*V*+*E*) |
| **说明**       | 空间浪费严重 | 空间利用率高 |



优缺点对比

| **特性**       | **邻接矩阵**           | **邻接表**                       |
| -------------- | ---------------------- | -------------------------------- |
| **空间占用**   | 高（尤其稀疏图）       | 低（适合稀疏图）                 |
| **查询效率**   | 高（直接数组访问）     | 低（需遍历链表）                 |
| **增删顶点**   | 困难（需重建整个数组） | 容易（修改对应列表即可）         |
| **图类型**     | 适合稠密图（如完全图） | 适合稀疏图（如社交网络、树结构） |
| **内存连续性** | 高（数组连续存储）     | 低（链表分散存储）               |

总的来说

邻接矩阵	适合

邻接表	   适合	









无向图的链的第一个元素是本顶点，后继分别连接着和这个顶点相连的顶点；
有向图的链第一个顶点是本顶点，后继是以本顶点为起点的边的终点。



```java
// 基于邻接表实现的无向图类

package TestField;

import java.util.Arrays;


public class Main {
    Vertex[] vertices; // 邻接表数组，每个元素对应一个顶点的链表
    int size;             // 顶点总数

    // 邻接表节点类（单链表结构）
    class Vertex {
        char ch;          // 顶点字符标识
        Vertex next;      // 指向下一个邻接顶点

        // 构造函数：初始化顶点字符
        Vertex(char ch) {
            this.ch = ch;
        }

        // 方法：向链表末尾添加新邻接顶点（尾插法）
        void add(char ch) {
            Vertex current = this;
            // 遍历到链表末尾
            while (current.next != null) {
                current = current.next;
            }
            // 创建新节点并连接
            current.next = new Vertex(ch);
        }
    }

    // 构造函数：初始化无向图
    public Main(char[] vertexs, char[][] edges) {
        size = vertexs.length;
        vertices = new Vertex[size]; // 初始化邻接表数组

        // 初始化每个顶点的头节点
        for (int i = 0; i < size; i++) {
            vertices[i] = new Vertex(vertexs[i]);
        }

        // 填充邻接表
        for (char[] edge : edges) {
            int p1 = getPosition(edge[0]); // 获取顶点1的索引
            int p2 = getPosition(edge[1]); // 获取顶点2的索引

            // 检查顶点是否存在（优化点：此处应添加异常处理）
            if (p1 == -1 || p2 == -1) {
                throw new IllegalArgumentException("无效顶点: " + Arrays.toString(edge));
            }

            // 无向图需双向添加边
            vertices[p1].add(edge[1]);
            vertices[p2].add(edge[0]);
        }
    }

    // 辅助方法：根据字符查找顶点索引
    private int getPosition(char ch) {
        for (int i = 0; i < size; i++) {
            if (vertices[i].ch == ch) {
                return i;
            }
        }
        return -1; // 顶点不存在时返回-1（优化点：建议抛出异常）
    }

    // 方法：打印邻接表结构
    public void print() {
        for (int i = 0; i < size; i++) {
            Vertex current = vertices[i];
            // 遍历链表并输出
            while (current != null) {
                System.out.print(current.ch + " ");
                current = current.next;
            }
            System.out.println(); // 换行分隔不同顶点
        }
    }

    public static void main(String[] args) {
        char[] vexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'};
        char[][] edges = {
            {'A', 'C'}, {'A', 'D'}, {'A', 'F'},
            {'B', 'C'}, {'C', 'D'}, {'E', 'G'},
            {'D', 'G'}, {'I', 'J'}, {'J', 'G'}
        };

        // 测试：创建10个图对象
        for (int i = 0; i < 10; i++) {
            Main graph = new Main(vexs, edges);
             graph.print();
        }
    }
    
}
```



```java
// 基于邻接表实现有向图

package TestField;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class MainCopy {
    
    // 数组可以通过索引方便的查找邻接点，这里为了方便，用Map，可以不用
	private Map<Character, List<Character>> adjList; // 使用 Map 存储顶点和邻接表
	private int size;

	public MainCopy(char[] vertexs, char[][] edges) {
		size = vertexs.length;
		adjList = new HashMap<>();

		// 初始化邻接表（仅存储顶点本身）
		for (char vertex : vertexs) {
			adjList.put(vertex, new LinkedList<>());
		}

		// 添加有向边（仅单边）
		for (char[] edge : edges) {
			char from = edge[0];
			char to = edge[1];
			if (!adjList.containsKey(from)) {
				throw new IllegalArgumentException("Invalid vertex: " + from);
			}
			adjList.get(from).add(to);
		}
	}

	public void print() {
		for (char vertex : adjList.keySet()) {
			System.out.print(vertex + " -> ");
			adjList.get(vertex).forEach(neighbor -> System.out.print(neighbor + " "));
			System.out.println();
		}
	}

	public static void main(String[] args) {
		char[] vexs = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K' };
		char[][] edges = { { 'A', 'C' }, { 'A', 'D' }, { 'A', 'F' }, { 'B', 'C' }, { 'C', 'D' }, { 'E', 'G' },
				{ 'D', 'G' }, { 'I', 'J' }, { 'J', 'G' } };

		MainCopy graph = new MainCopy(vexs, edges);
		graph.print();
	}
}
```



```java
// 逆邻接表
```



```java
/* 基于邻接矩阵实现的无向图  类 */



package TestField;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class MainCopy {

    static class Graph {
        // 节点列表
        List<Integer> vertices;
        // 邻接矩阵
        List<List<Integer>> adjMat;

        public Graph(int[] vertex, int[][] edges) {
            this.vertices = new ArrayList<>();
            this.adjMat = new ArrayList<>();

            for (int i : vertex)
                vertices.add(i);

            int size = vertex.length;
            // 初始化邻接矩阵元素为 0
            for (int i = 0; i < size; i++) {
                List<Integer> row = new ArrayList<>();
                for (int j = 0; j < size; j++) {
                    row.add(0);
                }
                adjMat.add(row);
            }

            for (int[] edge : edges)
                addEdge(edge[0], edge[1]);
        }

        void addEdge(Integer i, Integer j) {
            if (i < 0 || j < 0 || i == j || i >= getSize() || j >= getSize())
                // 修正拼写错误
                throw new IndexOutOfBoundsException("索引超出边界");
            adjMat.get(i).set(j, 1);
            adjMat.get(j).set(i, 1);
        }

        int getSize() {
            return vertices.size();
        }

        public void addVertex(int vertex) {
            vertices.add(vertex);
            int size = getSize();
            ArrayList<Integer> newRow = new ArrayList<>(size);
            // 正确初始化 newRow 元素为 0
            for (int i = 0; i < size; i++) {
                newRow.add(0);
            }
            adjMat.add(newRow);

            for (List<Integer> row : adjMat)
                row.add(0);
        }

        public void removeVertex(int index) {
            if (index >= getSize()) {
                throw new IndexOutOfBoundsException("越界");
            }

            vertices.remove(index);
            adjMat.remove(index);

            for (List<Integer> row : adjMat)
                row.remove(index);
        }

        public void addEdge(int i, int j) {
            if (i < 0 || j < 0 || i >= getSize() || j >= getSize() || i == j) {
                throw new IndexOutOfBoundsException("边的索引超出范围或不合法");
            }
            adjMat.get(i).set(j, 1);
            adjMat.get(j).set(i, 1);
        }

        public void removeEdge(int i, int j) {
            if (i < 0 || j < 0 || i >= getSize() || j >= getSize() || i == j) {
                throw new IndexOutOfBoundsException("边的索引超出范围或不合法");
            }
            adjMat.get(i).set(j, 0);
            adjMat.get(j).set(i, 0);
        }

        public void print() {
            System.out.println("顶点");
            // 让顶点在同一行输出
            for (int vertex : vertices)
                System.out.print(vertex + " ");
            System.out.println();

            System.out.println("邻接矩阵");
            int size = adjMat.size();
            for (List<Integer> row : adjMat) {
                for (int i = 0; i < size; i++) {
                    System.out.print(row.get(i) + " ");
                }
                System.out.println();
            }
        }
    }

    // 入口
    public static void main(String[] args) {
        int[] vertices = {1, 2, 3, 4};
        int[][] edges = {{0, 1}, {1, 2}, {2, 3}};

        // 创建图对象
        Graph graph = new Graph(vertices, edges);

        // 打印初始图信息
        System.out.println("初始图信息：");
        graph.print();

        // 添加顶点
        graph.addVertex(5);
        System.out.println("\n添加顶点 5 后：");
        graph.print();

        // 添加边
        graph.addEdge(0, 4);
        System.out.println("\n添加边 (0, 4) 后：");
        graph.print();

        // 删除边
        graph.removeEdge(1, 2);
        System.out.println("\n删除边 (1, 2) 后：");
        graph.print();

        // 删除顶点 3（索引为 2）
        graph.removeVertex(2);
        System.out.println("\n删除顶点 3 后：");
        graph.print();
    }
}
```









a

```java
// 对顶点和边的字段的解释

static class Node {
	// 编号
	int vertex;
	// 该顶点到起点的最短距离
	int dist;

	Node(int vertex, int dist) {
		this.vertex = vertex;
		this.dist = dist;
	}
}

public static class Edge {

	//该边权重
	int len;
	//该边终点顶点的编号
	int to;

	public Edge(int to, int len) {
		this.to = to;
		this.len = len;
	}

}
```



```java
// 基于邻接矩阵实现的有向图类





public class MatrixDG {
    int size;
    char[] vertexs;
    int[][] matrix;
    
    public MatrixDG(char[] vertexs,char[][] edges){
        
        size=vertexs.length;
        matrix=new int[size][size];
        this.vertexs=vertexs;
        //和邻接矩阵无向图差别仅仅在这里
        for(char[] c:edges){
            int p1 = getPosition(c[0]);
            int p2 = getPosition(c[1]);
            matrix[p1][p2] = 1;
        }

    }
    public void print(){
        for(int[] i:matrix){
            for(int j:i){
                System.out.print(j+" ");
            }
            System.out.println();
        }
    }
    private int getPosition(char ch) {
        for(int i=0; i<vertexs.length; i++)
            if(vertexs[i]==ch)
                return i;
        return -1;
    }
    public static void main(String[] args) {
        char[] vexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G','H','I','J','K'};
        char[][] edges = new char[][]{
            {'A', 'C'}, 
            {'A', 'D'}, 
            {'A', 'F'}, 
            {'B', 'C'}, 
            {'C', 'D'}, 
            {'E', 'G'}, 
            {'D', 'G'},
            {'I','J'},
            {'J','G'},};
        MatrixDG pG;
        // 自定义"图"(输入矩阵队列)
        //pG = new MatrixUDG();
        // 采用已有的"图"
        pG = new MatrixDG(vexs, edges);
        pG.print();
    }
}

```











​	`图的遍历`



有深度优先和广度优先



​	**广度优先**	BFS

从某节点出发，始终优先访问最近节点，并层层向外扩张



BFS 通常借助队列实现，因为 队列具有“先入先出”的性质，这与 BFS 的“由近及远”的思想异曲同工。

1. 将遍历起始顶点 `startVet` 加入队列，并开启循环。
2. 在循环的每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所有邻接顶点加入到队列尾部。
3. 循环步骤 `2.` ，直到所有顶点被访问完毕后结束。

还要借助哈希集合( hashSet ,这里名为`visited`)去重的特点来记录已访问节点，避免重复访问。

```java
// 核心内容
/* 广度优先遍历 */
// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点


List<Vertex> graphBFS(GraphAdjList graph, Vertex startVet) {
    // 顶点遍历序列(被遍历的顶点将会顺次加入这个序列)
    List<Vertex> res = new ArrayList<>();
    // 哈希集合，用于记录已被访问过的顶点
    Set<Vertex> visited = new HashSet<>();
    visited.add(startVet);
    // 队列用于实现 BFS
    Queue<Vertex> que = new LinkedList<>();
    que.offer(startVet);
    // 以顶点 vet 为起点，循环直至访问完所有顶点
    while (!que.isEmpty()) {
        Vertex vet = que.poll(); // 队首顶点出队
        res.add(vet);            // 记录访问顶点
        // 遍历该顶点的所有邻接顶点
        for (Vertex adjVet : graph.adjList.get(vet)) {
            if (visited.contains(adjVet))
                continue;        // 跳过已被访问的顶点
            que.offer(adjVet);   // 只入队未访问的顶点
            visited.add(adjVet); // 标记该顶点已被访问
        }
    }
    // 返回顶点遍历序列
    return res;
}
```



```java
// 完整代码

package TestField;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Queue;
import java.util.LinkedList;

public class Main {

	public static class Vertex {

		int val;

		public Vertex(int val) {

			this.val = val;
		}

		@Override
		public String toString() {
			return String.valueOf(val);
		}

	}

	public static class GraphAdjList {

		List<Vertex> vertices;
		Map<Vertex, List<Vertex>> adjList;

		public GraphAdjList() {
			this.vertices = new ArrayList<>();
			this.adjList = new HashMap<>();
		}

		public void addVertex(Vertex vertex) {

			// 若重复，保留以前的
			if (!adjList.containsKey(vertex)) {
				vertices.add(vertex);
				adjList.put(vertex, new ArrayList<Vertex>());

			}
		}

		public void addEdge(Vertex v1, Vertex v2) {

			adjList.get(v1).add(v2);
			adjList.get(v2).add(v1);

		}

	}

	public static class GraphBFSTravel {

		List<Vertex> BFS(GraphAdjList graph, Vertex start) {

			List<Vertex> res = new ArrayList<Vertex>();
			// 因为把节点定义成了类Vertex，就不能用boolean[]
			Set<Vertex> visited = new HashSet<>();
			Queue<Vertex> que = new LinkedList<>();

			que.offer(start);
			visited.add(start);
			
			while (!que.isEmpty()) {

				Vertex curVertex = que.poll();
				res.add(curVertex);
				for (Vertex neighbor : graph.adjList.get(curVertex)) {
						if(visited.contains(neighbor))
							continue;
						que.offer(neighbor);
						visited.add(neighbor);
				}
			}

			return res;

		}

	}

	
	public static void main(String[] args) {
		// 创建图
		GraphAdjList graph = new GraphAdjList();

		// 创建顶点
		Vertex v0 = new Vertex(0);
		Vertex v1 = new Vertex(1);
		Vertex v2 = new Vertex(2);
		Vertex v3 = new Vertex(3);
		Vertex v4 = new Vertex(4);

		// 添加顶点到图中
		graph.addVertex(v0);
		graph.addVertex(v1);
		graph.addVertex(v2);
		graph.addVertex(v3);
		graph.addVertex(v4);

		// 添加边
		graph.addEdge(v0, v1);
		graph.addEdge(v0, v2);
		graph.addEdge(v1, v2);
		graph.addEdge(v1, v3);
		graph.addEdge(v2, v4);

		// 执行广度优先遍历
		List<Vertex> traversalResult = new GraphBFSTravel().BFS(graph, v0);

		// 输出遍历结果
		System.out.println("广度优先遍历结果: " + traversalResult);
	}

}
```



```c++
// c++版本

/*Vertex 类：定义了图的顶点，每个顶点包含一个整数值 val。
GraphAdjList 类：使用邻接表来表示图，提供了添加顶点和添加边的方法。
graphBFS 函数：实现了广度优先遍历算法，使用队列来存储待访问的顶点，使用哈希集合来记录已访问的顶点。
printVertexSequence 函数：辅助函数，用于打印顶点遍历序列。
main 函数：创建了一些顶点和边，构建了一个图，然后从顶点 v0 开始进行广度优先遍历，并打印遍历序列。最后，释放了动态分配的顶点内存。*/

#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>
#include <unordered_map>

// 定义顶点类
class Vertex {
public:
    int val;
    Vertex(int x) : val(x) {}
};

// 定义图类，使用邻接表表示
class GraphAdjList {
public:
    std::unordered_map<Vertex*, std::vector<Vertex*>> adjList;

    // 添加顶点
    void addVertex(Vertex* vet) {
        if (adjList.find(vet) == adjList.end()) {
            adjList[vet] = {};
        }
    }

    // 添加边
    void addEdge(Vertex* vet1, Vertex* vet2) {
        if (adjList.find(vet1) == adjList.end() || adjList.find(vet2) == adjList.end()) {
            return;
        }
        adjList[vet1].push_back(vet2);
        adjList[vet2].push_back(vet1); // 无向图
    }
};

/* 广度优先遍历 */
// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
std::vector<Vertex*> graphBFS(GraphAdjList &graph, Vertex *startVet) {
    // 顶点遍历序列
    std::vector<Vertex*> res;
    // 哈希集合，用于记录已被访问过的顶点
    std::unordered_set<Vertex*> visited = {startVet};
    // 队列用于实现 BFS
    std::queue<Vertex*> que;
    que.push(startVet);
    // 以顶点 vet 为起点，循环直至访问完所有顶点
    while (!que.empty()) {
        Vertex *vet = que.front();
        que.pop();          // 队首顶点出队
        res.push_back(vet); // 记录访问顶点
        // 遍历该顶点的所有邻接顶点
        for (auto adjVet : graph.adjList[vet]) {
            if (visited.count(adjVet))
                continue;            // 跳过已被访问的顶点
            que.push(adjVet);        // 只入队未访问的顶点
            visited.emplace(adjVet); // 标记该顶点已被访问
        }
    }
    // 返回顶点遍历序列
    return res;
}

// 辅助函数：打印顶点遍历序列
void printVertexSequence(const std::vector<Vertex*>& sequence) {
    for (auto vet : sequence) {
        std::cout << vet->val << " ";
    }
    std::cout << std::endl;
}

int main() {
    // 创建顶点
    Vertex* v0 = new Vertex(0);
    Vertex* v1 = new Vertex(1);
    Vertex* v2 = new Vertex(2);
    Vertex* v3 = new Vertex(3);
    Vertex* v4 = new Vertex(4);

    // 创建图
    GraphAdjList graph;
    graph.addVertex(v0);
    graph.addVertex(v1);
    graph.addVertex(v2);
    graph.addVertex(v3);
    graph.addVertex(v4);

    // 添加边
    graph.addEdge(v0, v1);
    graph.addEdge(v0, v2);
    graph.addEdge(v1, v2);
    graph.addEdge(v1, v3);
    graph.addEdge(v2, v4);

    // 从顶点 v0 开始进行广度优先遍历
    std::vector<Vertex*> bfsSequence = graphBFS(graph, v0);

    // 打印遍历序列
    std::cout << "BFS 遍历序列: ";
    printVertexSequence(bfsSequence);

    // 释放内存
    delete v0;
    delete v1;
    delete v2;
    delete v3;
    delete v4;

    return 0;
}
```



**BFS关键点：状态的选取和标记**









​	**深度优先	**DFS

走到底，无路可走再回去，如此反复



关键点：递归、回溯

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250227171912596.png" alt="image-20250227171912596" style="zoom:50%;" />

```java
// 深度优先核心代码

// 深度优先一般通过递归实现，和广度优先的几乎没有区别
 
class DFSGraphTraversal {
    /* 深度优先遍历辅助函数 */
    void dfs(GraphAdjList graph, Set<Vertex> visited, List<Vertex> res, Vertex startVet) {
        res.add(startVet);     // 记录访问顶点
        visited.add(startVet); // 标记该顶点已被访问
        // 遍历该顶点的所有邻接顶点
        for (Vertex adjVet : graph.adjList.get(startVet)) {
            if (visited.contains(adjVet))
                continue; // 跳过已被访问的顶点
            // 递归访问邻接顶点
            dfs(graph, visited, res, adjVet);
        }
    }

    /* 深度优先遍历 */
    // 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
    List<Vertex> graphDFS(GraphAdjList graph, Vertex startVet) {
        // 顶点遍历序列
        List<Vertex> res = new ArrayList<>();
        // 哈希集合，用于记录已被访问过的顶点
        Set<Vertex> visited = new HashSet<>();
        dfs(graph, visited, res, startVet);
        return res;
    }
}


```

```java
//完整代码
    
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List	;
import java.util.Map;
import java.util.Set;

// 顶点类
class Vertex {
    int val;

    public Vertex(int val) {
        this.val = val;
    }

    @Override
    public String toString() {
        return String.valueOf(val);
    }
}

// 图的邻接表实现类
class GraphAdjList {
    List<Vertex> vertices;
    Map<Vertex, List<Vertex>> adjList;

    public GraphAdjList() {
        this.vertices = new ArrayList<>();
        this.adjList = new HashMap<>();
    }

    // 添加顶点
    public void addVertex(Vertex vertex) {
        if (!adjList.containsKey(vertex)) {
            vertices.add(vertex);
            adjList.put(vertex, new ArrayList<>());
        }
    }

    // 添加边
    public void addEdge(Vertex v1, Vertex v2) {
        addVertex(v1);
        addVertex(v2);
        adjList.get(v1).add(v2);
        adjList.get(v2).add(v1);
    }
}

// 深度优先搜索遍历类
class DFSGraphTraversal {
    /* 深度优先遍历辅助函数 */
    void dfs(GraphAdjList graph, Set<Vertex> visited, List<Vertex> res, Vertex startVet) {
        res.add(startVet);     // 记录访问顶点
        visited.add(startVet); // 标记该顶点已被访问
        // 遍历该顶点的所有邻接顶点
        for (Vertex adjVet : graph.adjList.get(startVet)) {
            if (visited.contains(adjVet))
                continue; // 跳过已被访问的顶点
            // 递归访问邻接顶点
            dfs(graph, visited, res, adjVet);
        }
    }

    /* 深度优先遍历 */
    // 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
    List<Vertex> graphDFS(GraphAdjList graph, Vertex startVet) {
        // 顶点遍历序列
        List<Vertex> res = new ArrayList<>();
        // 哈希集合，用于记录已被访问过的顶点
        Set<Vertex> visited = new HashSet<>();
        dfs(graph, visited, res, startVet);
        return res;
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建图
        GraphAdjList graph = new GraphAdjList();

        // 创建顶点
        Vertex v0 = new Vertex(0);
        Vertex v1 = new Vertex(1);
        Vertex v2 = new Vertex(2);
        Vertex v3 = new Vertex(3);
        Vertex v4 = new Vertex(4);

        // 添加顶点到图中
        graph.addVertex(v0);
        graph.addVertex(v1);
        graph.addVertex(v2);
        graph.addVertex(v3);
        graph.addVertex(v4);

        // 添加边
        graph.addEdge(v0, v1);
        graph.addEdge(v0, v2);
        graph.addEdge(v1, v2);
        graph.addEdge(v1, v3);
        graph.addEdge(v2, v4);

        // 创建深度优先搜索对象
        DFSGraphTraversal dfsTraversal = new DFSGraphTraversal();
        // 执行深度优先遍历
        List<Vertex> traversalResult = dfsTraversal.graphDFS(graph, v0);

        // 输出遍历结果
        System.out.println("深度优先遍历结果: " + traversalResult);
    }
}
```





```java
// DFS一般基于递归实现，那二般呢？
```

 







<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250227192405962.png" alt="image-20250227192405962" style="zoom: 67%;" />

按照👈👇👉👆的顺序尝试



DFS会尝试各种路径，在不断地撞墙后，最终会试出一条可以到达目标地路，在撞墙后，要重新走，在DFS里就是回溯，所以，DFS关键是回溯

回溯是递归在上一层后把原本的标记去掉。回溯的那步本质只是去掉标记，而不是退回哦，退回是在递归那句话实现的。





而BFS则是反复进入和退出，将所有可行解得出再记录下来，所以BFS关键是状态选取和标记



DFS和BFS

**数据结构上的运用**

DFS用递归的形式，用到了栈结构，先进后出。

BFS选取状态用队列的形式，先进先出。

都用hashSet来记录已访问过节点

**复杂度**

DFS的复杂度与BFS的复杂度大体一致

**思想**

思想上来说这两种方法都是穷竭列举所有的情况

不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。





`Dijkstra算法`

核心思想是贪心策略，它从源节点开始，每次选择距离最近且未确定最短路径的节点，并以该节点为中间点更新其他节点到源节点的距离，直到所有节点的最短路径都被确定。

```java
package algo;

import java.util.*;


class Dijkstra{
	
	private static final int INF = Integer.MAX_VALUE;

	// 内部类用于存储节点和距离
	static class Node implements Comparable<Node> {
		int vertex;
		int distance;

		Node(int vertex, int distance) {
			this.vertex = vertex;
			this.distance = distance;
		}

		@Override
		public int compareTo(Node other) {
			return Integer.compare(this.distance, other.distance);
		}
	}

	
	public static class Result {
		
		// 存储距离
		int[] dist;
		// 存储前驱节点
		int[] prev;

		Result(int[] dist, int[] prev) {
			this.dist = dist;
			this.prev = prev;
		}
	}

	// 核心算法
	public static Result dijkstra(int[][] graph, int src) {
		int n = graph.length;
		int[] dist = new int[n];
		int[] prev = new int[n];
		boolean[] visited = new boolean[n];

		// 初始化距离数组和前驱数组
		Arrays.fill(dist, INF);
		Arrays.fill(prev, -1);
		dist[src] = 0;

		// 使用优先队列（最小堆）来优化选择最小距离节点的过程
		PriorityQueue<Node> pq = new PriorityQueue<>();
		pq.add(new Node(src, 0));

		while (!pq.isEmpty()) {
			// 取出距离源节点最近的节点
			Node current = pq.poll();
			int u = current.vertex;

			if (visited[u])
				continue;
			visited[u] = true;

			// 更新 u 的邻接节点的距离
			for (int v = 0; v < n; v++) {
				//如果邻接节点v没访问过&& u到v之间有路 && 源节点到u是可达的 && 小于目前记录最短距离
				if (!visited[v] && graph[u][v] != 0 && dist[u] != INF && dist[u] + graph[u][v] < dist[v]) {
					dist[v] = dist[u] + graph[u][v];
					prev[v] = u;
					pq.add(new Node(v, dist[v]));
				}
			}
		}

		return new Result(dist, prev);
	}

	// 用于输出从源节点到目标节点的具体路径
	public static List<Integer> getPath(int[] prev, int dest) {
		List<Integer> path = new ArrayList<>();
		for (int at = dest; at != -1; at = prev[at]) {
			path.add(at);
		}
		Collections.reverse(path);
		return path;
	}

	public static void main(String[] args) {
		int[][] graph = { { 0, 4, 0, 0, 0, 0, 0, 8, 0 }, { 4, 0, 8, 0, 0, 0, 0, 11, 0 }, { 0, 8, 0, 7, 0, 4, 0, 0, 2 },
				{ 0, 0, 7, 0, 9, 14, 0, 0, 0 }, { 0, 0, 0, 9, 0, 10, 0, 0, 0 }, { 0, 0, 4, 14, 10, 0, 2, 0, 0 },
				{ 0, 0, 0, 0, 0, 2, 0, 1, 6 }, { 8, 11, 0, 0, 0, 0, 1, 0, 7 }, { 0, 0, 2, 0, 0, 0, 6, 7, 0 } };

		int src = 0;
		Result result = dijkstra(graph, src);
		int[] dist = result.dist;
		int[] prev = result.prev;

		System.out.println("从节点 " + src + " 到其他节点的最短距离：");
		for (int i = 0; i < dist.length; i++) {
			System.out.println("到节点 " + i + " 的距离: " + (dist[i] == INF ? "INF" : dist[i]));
			List<Integer> path = getPath(prev, i);
			System.out.print("路径: ");
			for (int j = 0; j < path.size(); j++) {
				if (j > 0) {
					System.out.print(" -> ");
				}
				System.out.print(path.get(j));
			}
			System.out.println();
		}
	}
}

```





```java
对于稀疏图（边数远小于节点数的平方），邻接矩阵会浪费大量的空间。
使用邻接表  减少空间开销，并且在遍历节点的邻接节点时，时间复杂度也会降低。
    
package algo;

import java.util.*;

class DijkstraFurtherOptimized {
    private static final int INF = Integer.MAX_VALUE;

    static class Node implements Comparable<Node> {
        int vertex;
        int distance;

        Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.distance, other.distance);
        }
    }

    public static class Result {
        int[] dist;
        int[] prev;

        Result(int[] dist, int[] prev) {
            this.dist = dist;
            this.prev = prev;
        }
    }

    public static Result dijkstra(List<List<Map.Entry<Integer, Integer>>> graph, int src) {
        int n = graph.size();
        int[] dist = new int[n];
        int[] prev = new int[n];
        boolean[] visited = new boolean[n];

        Arrays.fill(dist, INF);
        Arrays.fill(prev, -1);
        dist[src] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(src, 0));

        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.vertex;

            if (visited[u]) continue;
            visited[u] = true;

            for (Map.Entry<Integer, Integer> neighbor : graph.get(u)) {
                int v = neighbor.getKey();
                int weight = neighbor.getValue();
                if (!visited[v] && dist[u] != INF && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    prev[v] = u;
                    pq.add(new Node(v, dist[v]));
                }
            }
        }

        return new Result(dist, prev);
    }

    public static List<Integer> getPath(int[] prev, int dest) {
        List<Integer> path = new ArrayList<>();
        for (int at = dest; at != -1; at = prev[at]) {
            path.add(at);
        }
        Collections.reverse(path);
        return path;
    }

    public static void main(String[] args) {
        int n = 9;
        List<List<Map.Entry<Integer, Integer>>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }

        int[][] edges = {
                {0, 1, 4}, {0, 7, 8},
                {1, 0, 4}, {1, 2, 8}, {1, 7, 11},
                {2, 1, 8}, {2, 3, 7}, {2, 5, 4}, {2, 8, 2},
                {3, 2, 7}, {3, 4, 9}, {3, 5, 14},
                {4, 3, 9}, {4, 5, 10},
                {5, 2, 4}, {5, 3, 14}, {5, 4, 10}, {5, 6, 2},
                {6, 5, 2}, {6, 7, 1}, {6, 8, 6},
                {7, 0, 8}, {7, 1, 11}, {7, 6, 1}, {7, 8, 7},
                {8, 2, 2}, {8, 6, 6}, {8, 7, 7}
        };

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];
            graph.get(u).add(new AbstractMap.SimpleEntry<>(v, weight));
        }

        int src = 0;
        Result result = dijkstra(graph, src);
        int[] dist = result.dist;
        int[] prev = result.prev;

        System.out.println("从节点 " + src + " 到其他节点的最短距离：");
        for (int i = 0; i < dist.length; i++) {
            System.out.println("到节点 " + i + " 的距离: " + (dist[i] == INF ? "INF" : dist[i]));
            List<Integer> path = getPath(prev, i);
            System.out.print("路径: ");
            for (int j = 0; j < path.size(); j++) {
                if (j > 0) {
                    System.out.print(" -> ");
                }
                System.out.print(path.get(j));
            }
            System.out.println();
        }
    }
}
```





**Floyd	弗洛伊德算法**

Floyd基于动态规划

定义2个二维矩阵

1. 矩阵D记录顶点间的最小路径
    例如D[0] [3]= 10，说明顶点0 到 3 的最短路径为10；
2. 矩阵P记录顶点间最小路径中的中转点
    例如P[0] [3]= 1 说明，0 到 3的最短路径轨迹为：0 -> 1 -> 3

通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v] [w] 和 D[v] [k] + D[k] [w] 最小值，如果D[v] [k] + D[k] [w] 为更小值，则把D[v] [k] + D[k] [w] 覆盖保存在D[v] [w]中

//	和dijkstra一样的比较，已存储的起点到终点的距离是否比起点经过当前路径到达终点的距离更远

```java
// 弗洛伊德算法
public void floyd() {
    int len;
    for (int mid = 0; mid < dis.length; mid++) {
        for (int start = 0; start < dis.length; start++) {
            for (int end = 0; end < dis.length; end++) {
                len = dis[start][mid] + dis[mid][end];
                if (len < dis[start][end]) {
                    dis[start][end] = len;
                    pre[start][end] = pre[mid][end];
                }
            }
        }
    }
}








// 更新最短路径（Floyd-Warshall）
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (g[i][k] != INF && g[k][j] != INF) {
                if (g[i][j] > g[i][k] + g[k][j])
                    g[i][j] = g[i][k] + g[k][j];
            }
        }
    }
}
```





```java
package TestField;

import java.util.Arrays;

public class Main {

	public static void main(String[] args) {
// 创建顶点
		char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
// 创建邻接矩阵
		int[][] matrix = new int[vertex.length][vertex.length];
		final int N = 65535; // 表示不可达
		matrix[0] = new int[] { 0, 5, 7, N, N, N, 2 };
		matrix[1] = new int[] { 5, 0, N, 9, N, N, 3 };
		matrix[2] = new int[] { 7, N, 0, N, 8, N, N };
		matrix[3] = new int[] { N, 9, N, 0, N, 4, N };
		matrix[4] = new int[] { N, N, 8, N, 0, 5, 4 };
		matrix[5] = new int[] { N, N, N, 4, 5, 0, 6 };
		matrix[6] = new int[] { 2, 3, N, N, 4, 6, 0 };

// 创建图对象
		Graph graph = new Graph(matrix, vertex);
// 调用弗洛伊德算法
		graph.floyd();
// 显示结果
		graph.show();
	}
}

class Graph {
	private char[] vertex; // 保存顶点
	private int[][] dis; // 保存距离
	private int[][] pre; // 保存前驱顶点

	public Graph(int[][] dis, char[] vertex) {
		this.vertex = vertex;
		this.dis = dis;
		this.pre = new int[vertex.length][vertex.length];
		for (int i = 0; i < vertex.length; i++) {
			Arrays.fill(this.pre[i], i);
		}
	}

// 弗洛伊德算法
	public void floyd() {
		int len;
		for (int mid = 0; mid < dis.length; mid++) {
			for (int start = 0; start < dis.length; start++) {
				for (int end = 0; end < dis.length; end++) {
					len = dis[start][mid] + dis[mid][end];
					if (len < dis[start][end]) {
						dis[start][end] = len;
						pre[start][end] = pre[mid][end];
					}
				}
			}
		}
	}

// 显示结果
	public void show() {
		for (int i = 0; i < dis.length; i++) {
			for (int j = 0; j < dis.length; j++) {
				System.out.print(vertex[pre[i][j]] + " ");
			}
			System.out.println();
			for (int j = 0; j < dis.length; j++) {
				System.out.println(vertex[i] + "到" + vertex[j] + "的最短路径为" + dis[i][j] + " ");
			}
			System.out.println();
		}
	}
}
```





Floyd和Dijkstra比较

floyd时间复杂度O(n$$^3)$$，适合求任意2点间最短路径



dijkstra使用堆结构*O*((*m*+*n*)*l**o**g**n*)，其中`m`是边的数量，`n`是顶点数量	适合给定源点到其它节点的最短路径









#### spfa

给定的图存在负权边,这是可考虑spfa，求解单源最短路径问题，原理是对图进行v-1次松弛操作，得到所有可能最短路径

可以判断图中是否有负环图

带有负环的图没有最短路径

​	













## 数学

### 容斥原理

无遗漏无重复，每个数只计算1次

 （A∪B∪C = A+B+C - A∩B - B∩C - C∩A + A∩B∩C）



关键思想

- **包含**：先将所有集合的元素个数相加。
- **排除**：减去所有两两交集的元素个数（因为它们被重复计算了）。
- **再包含**：加上所有三个交集的元素个数（因为它们被多减了一次）。
- **交替进行**：依此类推，直到所有可能的交集都被处理。

![image-20250401191540844](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250401191540844.png)





应用场景

1. **统计至少满足一个条件的元素数目**。
2. **计算多个事件中至少发生一个的概率**。
3. **排列组合中的去重问题**。
4. **编程竞赛中的数论问题**（如计算不被某些数整除的数的个数）





统计从 1 到 100 中，能被 2、3 或者 5 整除的整数的个数。

```java
package TestField;

import java.util.*;

public class Main {

	public static void count(int n, int a, int b, int c) {

		int countA = n / a;
		int countB = n / b;
		int countC = n / c;

		int countAB = n / lcm(a, b);
		int countAC = n / lcm(a, c);
		int countBC = n / lcm(b, c);
		int countABC = n / lcm(a, lcm(b, c));

		int res = countA + countB + countC - countAB - countAC - countBC + countABC;
		System.out.println(res);

	}

	static int gcd(int a, int b) {
		while (b != 0) {
			int c = b;
			b = a % b;
			a = c;
		}
		return a;
	}

	static int lcm(int a, int b) {
		return a * b / gcd(a, b);
	}
	
	public static void main(String[] args) {
		count(100, 2,3,5);
        
	}
}
```



多个事件中至少发生1个的概率

```java
public class InclusionExclusionExample2 {
    public static void main(String[] args) {
        double pA = 0.3;
        double pB = 0.4;
        double pC = 0.5;
        double pAB = 0.1;
        double pAC = 0.15;
        double pBC = 0.2;
        double pABC = 0.05;

        // 根据容斥原理计算至少有一个事件发生的概率
        double probability = pA + pB + pC - pAB - pAC - pBC + pABC;
        System.out.println("至少有一个事件发生的概率为: " + probability);
    }
}
```



排列组合去重

```java
import java.util.ArrayList;
import java.util.List;

public class InclusionExclusionExample3 {
    public static void main(String[] args) {
        int length = 3;
        char[] chars = {'a', 'b', 'c'};

        // 生成所有长度为 length 的字符串
        List<String> allStrings = generateStrings(chars, length);

        // 统计包含 'a' 的字符串个数
        int countA = countStringsWithChar(allStrings, 'a');
        // 统计包含 'b' 的字符串个数
        int countB = countStringsWithChar(allStrings, 'b');
        // 统计同时包含 'a' 和 'b' 的字符串个数
        int countAB = countStringsWithChars(allStrings, 'a', 'b');

        // 根据容斥原理计算结果
        int result = countA + countB - countAB;
        System.out.println("包含字符 'a' 或者 'b' 的字符串的个数为: " + result);
    }

    // 生成所有长度为 length 的字符串
    public static List<String> generateStrings(char[] chars, int length) {
        List<String> result = new ArrayList<>();
        generateStringsHelper(chars, length, "", result);
        return result;
    }

    private static void generateStringsHelper(char[] chars, int length, String current, List<String> result) {
        if (length == 0) {
            result.add(current);
            return;
        }
        for (char c : chars) {
            generateStringsHelper(chars, length - 1, current + c, result);
        }
    }

    // 统计包含指定字符的字符串个数
    public static int countStringsWithChar(List<String> strings, char c) {
        int count = 0;
        for (String s : strings) {
            if (s.indexOf(c) != -1) {
                count++;
            }
        }
        return count;
    }

    // 统计同时包含两个指定字符的字符串个数
    public static int countStringsWithChars(List<String> strings, char c1, char c2) {
        int count = 0;
        for (String s : strings) {
            if (s.indexOf(c1) != -1 && s.indexOf(c2) != -1) {
                count++;
            }
        }
        return count;
    }
}
```









### gcd 和 lcm

最大公约数和最小公倍数



gcd和lcm重点在gcd



**开始之前说一下gcd几条性质**



如果b是A和B的公约数，那么：

b也是A+B的约数，即b是A,B,A+B的公约数
b也是A-B的约数，即b是A,B,A-B的公约数
更一般地，对于任意整数x、y，b也是Ax+By的约数，即b是A,B,Ax+By的公约数
根据上一条性质，r = A - kB = A mod B，所以A mod B也是A+B的约数，mod是求余运算，即b是A,B,A mod B的公约数

```
gcd(A,B) = gcd(B,A) = gcd(A,A+B) = gcd(A,A-B) = gcd(A,Ax+By) = gcd(A,A mod B)
```





#### gcd

常见的求最大公约数的方法有

- 分解因式法
- 辗转相除法
- 更相减损法
- Stein算法



##### 因式分解法

```C++
/*assert（表达式）
断言方法，表达式非真则抛出异常


在二进制表示中，一个整数的最低位（最右边的位）如果是 0，则这个数是偶数；如果是 1，则这个数是奇数。因此，当一个整数与 1 进行&运算时，实际上就是在检查这个整数的最低位的值。
如果 (a & 1) == 0，说明 a 的最低位是 0，即 a 是偶数。
如果 (a & 1) == 1，说明 a 的最低位是 1，即 a 是奇数。
*/

// greatest common divisor
int GCD(int a, int b) {
    assert(a != 0);
    assert(b != 0);
    int min = a < b ? a : b;
    int accumulate = 1;

    // 以2进行分解，不能进0，0进来这里就死循环了
    while ((a & 1) == 0 && (b & 1) == 0) {
        accumulate *= 2; // 积累
        a >>= 1;
        b >>= 1;
    }
    // 以大于等于3的数进行分解
    for (int i = 3; i <= min; i += 2) {
        while ((a % i) == 0 && (b % i) == 0) {
          accumulate *= i;
          a /= i;
          b /= i;
        }
    }
    // 将所有公因子的乘积作为返回值
    return accumulate;
}
```

代码冗长性能低，但有参考意义



##### 辗转相除法

因为整数除法具有传递性，所以x如果能除以a、b,则x能除以它们的任意线性组合

所以

两个正整数A，B的最大公约数等于其中较小值与两数相除的余数的最大公约数

gcd(A, B) = gcd(B, A mod B)   其中:A > B

```java
// 	推荐
int GCD(int a, int b) {
    return b == 0 ? a : GCD(b, a%b);
}

int GCD(int a, int b) {
    int r;
    while (b != 0) {
        r = a % b; a = b; b = r;
    }
    return a;
}


int GCD(int a,int b) {
    while(b^=a^=b^=a%=b);
    /*
    	b^=a
    	a^=t1;
    	b^=a;
    	交换ab的值
    */
    return a;
}
```

如果用辗转相除法计算斐波那契数列相邻2项的最大公约数，该算法会最糟

可以用±代替*/ 进行优化

##### 更相减损法

两个正整数，如果它们都是偶数，则将它们都除以 2；如果不是偶数，那么用较大的数减去较小的数，然后用得到的差和较小的数继续做减法，直到两个数相等，此时这个相等的数就是原来两个数的最大公因数。



换成公式的写法：

```c
如果A > B，则 gcd(A,B) = gcd(B,A-B)
如果A < B，则 gcd(A,B) = gcd(A,B-A)
```

证明：

不妨设A>B，设A和B的最大公约数为X，其中a和b都为正整数，a>b	所以 A=aX，B=bx	C = A-B，则有：C=aX−bX=(a−b)X

因为a和b均为正整数，所以C也能被X整除，即A、B、C最大公约数均为X

所以`gcd(A,B) = gcd(B,A-B)`

```c++
public static int GCD(int a, int b) {

    // 先将两个数都化为非负数
    // 其实用负数也不影响结果，但GCD定义是对于正数
    a = Math.abs(a);
    b = Math.abs(b);

    // 若两个数都是偶数，先同时除以2，记录约去的2的个数
    // 这样不会对结果造成影响还能提高效率
    int TwoCount = 0;
    while ((a & 1) == 0 && (b & 1) == 0) {
        a >>= 1;
        b >>= 1;
        TwoCount++;
    }

    // 更相减损法的核心步骤
    while(a != b)
    {
        a > b ? a-=b : b-=a;
    }

    // 将约去的2乘回去
    return a << TwoCount;
//    return b << factorOfTwo;
}
```

辗转相除法与更相减损术的比较
（1）两者都是求最大公因数的方法，计算上辗转相除法以除法为主，更相减损术以减法为主，计算次数上辗转相除法计算次数相对较少，特别当两个数字大小区别较大时计算次数的区别较明显。

（2）从结果体现形式来看，辗转相除法体现结果是以相除余数为0则得到，而更相减损术则以减数与差相等而得到。



```
辗转相除法：通常效率较高，尤其是对于较大的数。因为它利用除法运算，每次迭代能使数字快速减小，迭代次数相对较少。
更相减损法：在数字相差较大时，可能需要进行多次减法运算才能使数字变小，计算步骤相对较多。但对于较小且相差不大的数，更相减损法可能会更快。


辗转相除法：适合处理较大整数的最大公因数
更相减损法：在一些对精度要求较高，或者不适合使用除法运算（如在一些加密算法中，除法可能会导致精度丢失或安全问题）的场景中，更相减损法可能更为适用。
```



##### **Stein算法**

使用位运算替代符号运算，提高效率

除了考虑偶数，还考虑了奇数



辗转相除法在计算两个超过64位的整数的模，也许不得不采用类似于多位数除法手算过程中的试商法，频繁使用/和%，消耗严重



1. 若a和b都是偶数，则记录下公约数2，然后都除2（即右移1位）；
2. 若其中一个数是偶数，则偶数除2，因为此时2不可能是这两个数的公约数了
3. 若两个都是奇数，则a = |a-b|，b = min(a,b)，因为若d是a和b的公约数，那么d也是|a-b|和min(a,b)的公约数。

​	对2进行解释

- 若 *b* 是**奇数**，则 2 无法整除 *b*，即 2 不是 *a* 和 *b* 的公约数。此时将 *a* 除以 2，得到 *a*/2，问题转化为求 gcd(*a*/2,*b*)，缩小计算规模且不影响最终结果。
- 若 *b* 也是**偶数**，则 2 是公约数。此时先将 *a* 和 *b* 都除以 2，记录公约数 2，后续对新的 *a*/2 和 *b*/2 继续求最大公约数，最后将记录的 2 与新结果相乘，即可得到原始两数的最大公约数。
- 总的来说就是为了减小规模



​	对3进行解释

不妨设奇数A>B，A和B的公约数为X，即A=jX，B=kX，其中j，k均为正整数且j>k。则 A−B=(j−k)X

所以X也是A-B的公约数

min(A,B)=B	所以A-B与min(A,B)公约数相同，因为A，B都是奇数，所以A-B必然是偶数，偶数又可以二除移位了。

```java
	public static int Stein(int a, int b) {
		if (a == 0) return b;
		if (b == 0) return a;

		int twoCount = 0;
		// 计算a和b中2的公共因子的个数
		while (((a | b) & 1) == 0) {
			a >>= 1; b >>= 1;
			twoCount++;
		}

		//仅仅移除ab公共2因子，也就是说只有在ab都是偶数时，twoCount++;
		// 否则说明一奇一偶，它们的公约数肯定不是偶数，所以单独移去偶数的2因子不会影响结果
		// 移除a中的所有2因子
		while ((a & 1) == 0) {
			a >>= 1;
		}
        
		// 主循环
		while (b != 0) {
			// 移除b中的所有2因子，写在这里是因为b作差后有可能为偶数
			while ((b & 1) == 0) {
				b >>= 1;
			}
			if (a > b) { int temp = a; a = b; b = temp; }
            // 这里始终保持b是大数
			b = b - a;
		}

		// 将公共的2因子乘回去
        // 这里不能随便交换，while谁，就得return另一个
		return a << twoCount;
	}





// 递归形式
public static int Stein(int a, int b) {
    if (b == 0) return a;
    if (a == 0) return b;

    if (a < b) { int r = a; a = b; b = r; }

    if ((a & 1) == 0 && (b & 1) == 0)
        return Stein(a >> 1, b >> 1) << 1;
    else if ((a & 1) == 0 && (b & 1) != 0)
        return Stein(a >> 1, b);
    else if ((a & 1) != 0 && (b & 1) == 0)
        return Stein(a, b >> 1);
    else
        return Stein(a - b, b);
}



2种实现方式的时间复杂度都是 O(log(min(a,b)))
空间复杂度 	 第1种 O(1)
    		第2递归在最坏情况下O(log(min(a,b)))
```

Stein算法算是更相减损法 结合   奇数   结合 数二进制特性的算法



[辗转相除法、更相减损法、Stein算法-CSDN博客](https://blog.csdn.net/Holmofy/article/details/76401074)

还有一点对辗转相除法的扩展，我没看



#### 	lcm

本质上求最小公倍数就是求最大公倍数：`x=m*a`， `y=m*b`；m是最大公约数，那最小公倍数就是`m*a*b`。所以可以得到最大公约数与最小公倍数的关系：

LCM(A,B)×GCD(A,B)=A×B

定理：a、b 两个数的lcm乘以gcd 等于它们的乘积。

所以ab的lcm = ab / gcd

```java
static int gcd(int a, int b){
	return a / (gcd(a, b)) * b; // 先/后*防溢出
}
```











#### **推广到3个及以上数的GCD**

https://leetcode.cn/problems/maximum-subarray-with-equal-products/

两个数的 LCM 与 GCD 关系 

对于两个数 a 和 b，有：
lcm(a,b)=gcd(a,b)a⋅b​
因此：
a⋅b=lcm(a,b)⋅gcd(a,b)



当扩展到三个或更多数时，上述等式不再成立

例如： 

数组 {6,10,15}，则：

gcd(6,10)=2，gcd(6,15)=3，gcd(10,15)=5。

整个数组的 gcd(6,10,15)=1

lcm(6,10,15)=30，而 6⋅10⋅15=900，显然 30⋅1 != 900。



###### 质因数分解法

每个正整数都可以唯一分解为素数的乘积，多个数的最大公约数就是它们公共素因数的乘积

1. 对每个数进行质因数分解。
2. 找出所有数共有的质因数。
3. 将这些公共质因数相乘，得到最大公约数。

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GCDPrimeFactorization {
    // 分解质因数
    public static List<Integer> primeFactors(int n) {
        List<Integer> factors = new ArrayList<>();
        for (int divisor = 2; n > 1; divisor++) {
            while (n % divisor == 0) {
                factors.add(divisor);
                n /= divisor;
            }
        }
        return factors;
    }

    // 计算多个数的最大公约数
    public static int gcdMultipleNumbersPrime(int[] numbers) {
        if (numbers.length == 0) {
            return 0;
        }
        // 存储第一个数的质因数及其出现次数
        Map<Integer, Integer> commonFactors = new HashMap<>();
        List<Integer> firstFactors = primeFactors(numbers[0]);
        for (int factor : firstFactors) {
            commonFactors.put(factor, commonFactors.getOrDefault(factor, 0) + 1);
        }

        // 遍历其余的数
        for (int i = 1; i < numbers.length; i++) {
            List<Integer> numFactors = primeFactors(numbers[i]);
            Map<Integer, Integer> tempFactors = new HashMap<>();
            for (int factor : numFactors) {
                tempFactors.put(factor, tempFactors.getOrDefault(factor, 0) + 1);
            }
            // 更新公共质因数的最小出现次数
            for (Map.Entry<Integer, Integer> entry : commonFactors.entrySet()) {
                int factor = entry.getKey();
                int count = entry.getValue();
                commonFactors.put(factor, Math.min(count, tempFactors.getOrDefault(factor, 0)));
            }
        }

        int gcd = 1;
        // 计算最大公约数
        for (Map.Entry<Integer, Integer> entry : commonFactors.entrySet()) {
            int factor = entry.getKey();
            int count = entry.getValue();
            gcd *= Math.pow(factor, count);
        }
        return gcd;
    }

    public static void main(String[] args) {
        int[] numbers = {24, 36, 48};
        System.out.println("质因数分解法求得的最大公约数: " + gcdMultipleNumbersPrime(numbers));
    }
}
```











## 思想



### 枚举

枚举（英语：Enumerate）是基于已有知识来猜测答案的一种问题求解策略。从可能的集合中一一尝试，然后再判断题目的条件是否成立



我想的那样一个一个举出来，但缺乏关键，枚举不是单纯的一个一个举出来，而是优化后举出来，就是根据条件，不断精简，让最后枚举的范围是剔除一切多余精简到不能再精简的枚举，也就是确定解的形式，比如满足条件的区间个数，那就枚举二元组（左右端点）



​	`要点`

​	考虑可能情况和要枚举元素

​	虽说从可能的集合中一一尝试，但尝试越少越好（这个少，1种是减小范围，另1种是集合中的内容不必全部枚举）

​	枚举方式：循环、递归、构造方法



```java
//	一个数组中的数互不相同，求其中和为 0 的数对的个数。


如果BF，要嵌套循环，假设有n个是，每个数都要验n遍，最后要验n*2遍，很费时

    用枚举思想分析：
它们互为相反数
只要枚举其中一个数就能确定了另一个数
存在只需遍历一遍的可能
取一个参考，相反数相对它来说是对称的


public class Main {

	// 定义偏移量 MAXN，这里假设数组元素绝对值最大不超过 100
	// MAXN左侧是原数组索引，右侧(包括MAXN)是偏移后的索引
	// 左侧就是正常跑的，右侧用来记录左侧对应位置值是否出现过，用 对±值作差的特性来验证

	// 用偏移量减去arr[i]的数值，无论arr[i]的值是正是负，都会去到同一索引位置
	// 假设arr[0]值是1，正常情况位置i标记为true，但因为偏移的缘故，实际是1+偏移量，就是101的位置
	// 该位置因为出现过标记为true
	// 当arr[0]的相反值-1出现，因为 对±值作差的特性，就会回到1的对应位置，因为1位置是true，可确定它俩凑成一对，ans+1

	static final int MAXN = 100;

	public static void main(String[] args) {

		int ans = 0;
		int[] arr = { 1, -1, 2, -2 };
		int n = arr.length;
		boolean[] met = new boolean[MAXN * 2 + 1];

		for (int i = 0; i < n; ++i) {

			if (met[MAXN - arr[i]]) {
				++ans;
			}

			met[MAXN + arr[i]] = true;
		}

		System.out.println(ans);

	}

}
```

 









### 排序算法



#### 	快速排序	quickSort

选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。



实质是将一个较长数组的排序问题简化为两个较短数组的排序问题。

分治策略



1. 选取数组最左端元素作为基准数，初始化两个指针 `i` 和 `j` 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 `i`（`j`）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 `2.` ，直到 `i` 和 `j` 相遇时停止，最后将基准数交换至两个子数组的分界线。







```java
package TestField;

import java.util.*;

public class Main {

	static void quickSort(int[] arr, int left, int right) {

		if (left >= right)
			return;

		int par = partition(arr, left, right);
		quickSort(arr, left, par - 1);
		quickSort(arr, par + 1, right);

	}

	static int partition(int[] arr, int left, int right) {

		int i = left;
		int j = right;

		// 外层只保证i<j
		while (i < j) {
			// 通过左右指针 i 和 j 寻找需要交换的元素，使左边元素 ≤ 基准值，右边元素 ≥ 基准值。
			// 找到第一个 小于基准值 的元素
			while (i < j && arr[j] >= arr[left])
				--j;
			// 找到第一个 大于基准值 的元素
			while (i < j && arr[i] <= arr[left])
				++i;
			// 小的给i，大的给j
			// 小的换到区间左，大的换到区间右
			swap(arr, i, j);
		}
		// 基准值归位：将基准值与i位置交换，使左边≤基准，右边≥基准，使最小值始终是par
		swap(arr, i, left);
		return i;
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}

	public static void main(String[] args) {
		int[] arr = { 1, 4, 5, 8, 9, 0, 90, 1, 9, 778, 6, 765, 7, 6, 8, 987 };
		quickSort(arr, 0, arr.length - 1);
		for (int m = 0; m < arr.length; ++m)
			System.out.print(arr[m] + " ");
	}

}
```

👇1

基准数优化

```java
/*假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在基准数划分完成后，基准数被交换至数组最右端，导致左子数组长度为n-1、右子数组长度为0。如此递归下去，每轮哨兵划分后都有一个子数组的长度为0，分治策略失效，快速排序退化为“冒泡排序”的近似形式。
*/

/*可以通过随机数选取基准数，但也可能出意外，所以通常从数组的首、尾、中选元素，并将这三个候选元素的中位数作为基准数。*/

/*
中位数是按顺序排列的一组数据中居于中间位置的数
如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。
*/


/* 选取三个候选元素的中位数 */
int medianThree(int[] nums, int left, int mid, int right) {
    int l = nums[left], m = nums[mid], r = nums[right];
    if ((l <= m && m <= r) || (r <= m && m <= l))
        return mid; // m 在 l 和 r 之间
    if ((m <= l && l <= r) || (r <= l && l <= m))
        return left; // l 在 m 和 r 之间
    return right;
}

/* 哨兵划分（三数取中值） */
int partition(int[] nums, int left, int right) {
    // 选取三个候选元素的中位数
    int med = medianThree(nums, left, (left + right) / 2, right);
    // 将中位数交换至数组最左端
    swap(nums, left, med);
    // 以 nums[left] 为基准数
    int i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] >= nums[left])
            j--;          // 从右向左找首个小于基准数的元素
        while (i < j && nums[i] <= nums[left])
            i++;          // 从左向右找首个大于基准数的元素
        swap(nums, i, j); // 交换这两个元素
    }
    swap(nums, i, left);  // 将基准数交换至两子数组的分界线
    return i;             // 返回基准数的索引
}
```

👇2

```python

在普通递归中，因为当前递归并未结束，每次递归调用在调用栈上创建一个新的栈帧来保存当前函数调用的上下文信息（如局部变量、返回地址等）。当递归深度过深会导致栈溢出错误

尾传递优化
函数的最后一步操作是调用自身，调用是函数的最后一个动作，没有其他额外的操作需要在调用返回后执行。
这就是尾传递
实现尾传递，有条件的编译器或解释器就会将尾递归优化成迭代形式，这就是尾传递优化
尾传递避免递归调用带来的栈空间累积问题，使得递归深度始终保持为 1。

A递归调用，最后A的返回是递归函数的结果


def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
看着递归调用是最后1步操作，其实+才是，因为函数还没结束，就挂着没释放了

def fibonacci_tail(n, a=0, b=1):
    if n == 0:
        return a
    return fibonacci_tail(n - 1, b, a + b)

递归调用是最后1步操作

```



明白尾递归调用后，再看它优化quick_sort

（除了尾递归调用思想，还有别的）

其实也能看出来，在某些输入下，快速排序占用空间较多，就如上面所说的完全逆序输入，每次都划分出长度为0和  n-1的子数组，每层递归只减少了1个元素
可以在哨兵划分后比较子数组长度，只对较短数组（长度不会超过n/2）递归,最差空间复杂度优化至logns



优先递归处理较短的子数组，而将较长的子数组留在循环中继续处理。这种策略的核心思想是**减少递归深度**，从而降低栈空间的使用，避免栈溢出。

较长的子数组因为在while中，它就会逐渐被拆为较短数组

```java
/* 快速排序（尾递归优化） */
void quickSort(int[] nums, int left, int right) {
    // 子数组长度为 1 时终止
    while (left < right) {
        // 哨兵划分操作
        int pivot = partition(nums, left, right);
        // 对两个子数组中较短的那个执行快速排序
        if (pivot - left < right - pivot) {
            quickSort(nums, left, pivot - 1); // 递归排序左子数组
            left = pivot + 1; // 剩余未排序区间为 [pivot + 1, right]
        } else {
            quickSort(nums, pivot + 1, right); // 递归排序右子数组
            right = pivot - 1; // 剩余未排序区间为 [left, pivot - 1]
        }
    }
}
```







#### 	归并排序	mergeSort



划分-合并

不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。

子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250228195138595.png" alt="image-20250228195138595" style="zoom: 33%;" />



```java
public static int[] mergeSort(int[] nums, int l, int h) {
    if (l == h)
        return new int[] { nums[l] };

    int mid = l + ((h - l) >> 1);
    int[] leftArr = mergeSort(nums, l, mid); // 左有序数组
    int[] rightArr = mergeSort(nums, mid + 1, h); // 右有序数组
    int[] newNum = new int[leftArr.length + rightArr.length]; // 新有序数组

    int m = 0, i = 0, j = 0;
    while (i < leftArr.length && j < rightArr.length) {
        newNum[m++] = leftArr[i] < rightArr[j] ? leftArr[i++] : rightArr[j++];
    }
    while (i < leftArr.length)
        newNum[m++] = leftArr[i++];
    while (j < rightArr.length)
        newNum[m++] = rightArr[j++];
    return newNum;
}
```









#### 桶排序（Bucket Sort）

把待排序数尽可能均匀分配到一些桶里，再对桶内部排序，最后按序输出



数据要均匀放入桶

考虑桶数量和桶的数据范围





桶装的数据范围 = （最大值 - 最小值）/ 数据量 + 1

因为至少要有1个桶，所以+1



桶数量 = （最大值 - 最小值） / 桶数据范围 + 1

因为至少有1个桶，桶得有容量吧，容量至少为1吧，所以+1



对桶中数据排序可用其它排序方式

最后依次输出数据



1. **创建桶**：根据数据范围和桶的数量，定义若干个桶（通常是数组或链表）。
2. **分配元素**：将每个数据元素按规则放入对应的桶中（例如：通过哈希函数或范围划分）。
3. **桶内排序**：对每个非空的桶内数据进行排序（可使用插入排序、快速排序等）。
4. **合并结果**：按顺序将所有桶中的元素合并，得到最终有序数组。





```java
package TestField;

import java.util.*;

public class Main {

	static void bucketSort(int[] arr) {

		int len = arr.length;
		int max = arr[0];
		int min = arr[0];
		for (int i = 1; i < len; ++i) {
			max = Math.max(max, arr[i]);
			min = Math.min(min, arr[i]);
		}

		// 计算桶范围和桶数量
		int size = (max - min) / len + 1;
		int cnt = (max - min) / size + 1;

		// 初始化桶
		List<Integer>[] buckets = new List[cnt];//这里要注意
		for (int i = 0; i < cnt; ++i)
			buckets[i] = new ArrayList<>();

		// 将元素放入桶，可以采用哈希函数
		for (int i = 0; i < len; ++i) {
			int idx = (arr[i] - min) / size;//这里要注意
			buckets[idx].add(arr[i]);
		}

		// 桶内排序并合并结果
		int index = 0;
		for (List<Integer> bucket : buckets) {
			Collections.sort(bucket); // 桶内排序（也可用插入排序等）
			for (int num : bucket) {
				arr[index++] = num;
			}
		}

	}

	public static void main(String[] args) {
		int[] arr = { 78, 65, 90, 82, 73, 88, 55, 95, 0, 0, 0 };
		bucketSort(arr);
		for (int num : arr) {
			System.out.print(num + " "); // 输出：55 65 73 78 82 88 90 95
		}
	}
}

```









#### 选择排序

```java
package TestField;

import java.util.*;

public class Main {

	static void selectionSort(int[] arr) {
		int len = arr.length;
		for (int i = 0; i < len - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < len; j++) {
				if (arr[j] < arr[minIndex]) {
					minIndex = j;
				}
			}
			// 交换最小元素和当前位置的元素
			if (minIndex != i) {
				int temp = arr[i];
				arr[i] = arr[minIndex];
				arr[minIndex] = temp;
			}
		}
	}

	public static void main(String[] args) {
		int[] arr = { 78, 65, 90, 82, 73, 88, 55, 95, 0, 0, 0 };
		selectionSort(arr);
		for (int num : arr) {
			System.out.print(num + " "); // 输出：55 65 73 78 82 88 90 95
		}
	}
}

```























### 搜索



搜索算法可根据实现思路分为以下两类。

- **通过遍历数据结构来定位目标元素**，例如数组、链表、树和图的遍历等。
- **利用数据组织结构或数据包含的先验信息，实现高效元素查找**，例如二分查找、哈希查找和二叉搜索树查找等。





#### 二分查找

```java
// 二分查找的数组必须是有序的
// 可以选择递归或不递归，这里递归

package TestField;

import java.util.Arrays;

public class Main {

	static int binarySearch(int[] arr, int tar, int left, int right) {

		if (left > right)
			return -1;

		int mid = left + ((right - left) >> 1);
        // 防止left + right 超出取值范围

		if (arr[mid] == tar)
			return mid;

		if (arr[mid] < tar) {
			return binarySearch(arr, tar, mid + 1, right);

		} else {
			return binarySearch(arr, tar, left, mid - 1);
		}

	}

	public static void main(String[] args) {

		int[] arr = { 1, 5, 6, 7, 8, 90, 3, 45, 6, 3, 2 };
		Arrays.sort(arr);
		int target = binarySearch(arr, 7, 0, arr.length - 1);
		System.out.println(target);

	}

}
```







### 分治



比如归并排序，就是分治思想的典型应用	



何时用分治

- 问题可以分解
- 子问题是独立的
- 子问题解可以合并



分治解决的问题

- **寻找最近点对**：该算法首先将点集分成两部分，然后分别找出两部分中的最近点对，最后找出跨越两部分的最近点对。
- **大整数乘法**：例如 Karatsuba 算法，它将大整数乘法分解为几个较小的整数的乘法和加法。
- **矩阵乘法**：例如 Strassen 算法，它将大矩阵乘法分解为多个小矩阵的乘法和加法。
- **汉诺塔问题**：汉诺塔问题可以通过递归解决，这是典型的分治策略应用。
- **求解逆序对**：在一个序列中，如果前面的数字大于后面的数字，那么这两个数字构成一个逆序对。求解逆序对问题可以利用分治的思想，借助归并排序进行求解。



根据二叉树的任意2序列构建二叉树

```java

```















### 回溯

穷举，找到解或确认无解

无法前进、无满足条件解时，回溯



回溯算法通常采用“深度优先搜索”来遍历解空间

二叉树的前中后序遍历都属于深度优先

```java
//	搜索前序二叉树中值为7的节点，并返回根节点到这些节点的路径

//	path 记录访问过的节点路径
//	res存储结果
//	通过DFS不断访问节点，节点左右子节点都已遍历结束后，在递归过程中  删去对当前节点访问的记录（path = path.size-1 ），实现回溯效果


void preOrder(TreeNode root){
    
    if(root == null)
        return;
    
    path.add(root);
    
    if(root.val == 7)
        res.add(new ArrayList<>(path));
    
    preOrder(root.left);
    preOrder(root.right);
    
    path.remove(path.size() - 1);
    
        
}
```



```java
//	完整代码

package TestField;

import java.util.ArrayList;
import java.util.List;

public class Main {

	public static class TreeNode {

		int val;
		TreeNode left;
		TreeNode right;

		public TreeNode(int val) {
			this.val = val;
		}

	}

	public static class BinaryTreeSearch {

		List<List<TreeNode>> res = new ArrayList<>();
		List<TreeNode> path = new ArrayList<>();

		void preOrder(TreeNode root) {

			if (root == null)
				return;

			path.add(root);
			if (root.val == 7)
                //	将当前 path 列表的一个副本添加到 res 列表中。
				res.add(new ArrayList<>(path));

			preOrder(root.left);
			preOrder(root.right);
			//	别忘了，这是递归，在它上一步是先去子节点那，子节点已经执行过这一步了，这里是递归回来了
            //	所以-1很合理
			path.remove(path.size() - 1);

		}

	}

	public static void main(String[] args) {
		// 构建一个简单的二叉树
		TreeNode root = new TreeNode(1);
		root.left = new TreeNode(2);
		root.right = new TreeNode(7);
		root.left.left = new TreeNode(3);
		root.left.right = new TreeNode(4);
		root.right.left = new TreeNode(7);

		BinaryTreeSearch solution = new BinaryTreeSearch();
		// 调用前序遍历方法进行搜索
		solution.preOrder(root);

		// 输出所有值为 7 的节点所在的路径
		for (List<TreeNode> path : solution.res) {
			for (TreeNode node : path) {
				System.out.print(node.val + " ");
			}
			System.out.println();
		}
	}

}
```





#### 剪枝

对回溯问题的约束条件，就是剪枝

```java
//在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径，并要求路径中不包含值为3的节点

void preOrder(TreeNode root) {
    // 剪枝
    // 直接回退到上一步
    if (root == null || root.val == 3) {
        return;
    }
    
    // 尝试
    path.add(root);
    if (root.val == 7) {
        // 记录解
        res.add(new ArrayList<>(path));
    }
    preOrder(root.left);
    preOrder(root.right);
    // 回退
    path.remove(path.size() - 1);
}

```









#### `回溯算法通用框架`

将回溯的“尝试、回退、剪枝”的主体框架提炼出来



- `state`：记录工具，记录了当前搜索分支中已确定的选择（不一定是res）
- `choices`：包含所有可能选择的列表，在每一步搜索中，从这个列表里挑选合适的选择。
- `res`：存储解决方案。

```java
/*
	用上面前序二叉树的例子
	choice  当前选择的节点
    state	相当于path
*/

	// 回溯
void backtrack(State state, List<Choice> choices, List<State> res){
	
    // 是否为解
    if(isSolution(state)){
        // 记录方案
		recordSolution(state, res);
        // 不再搜索
        return;
        // 因为具体问题的实现，还有剪枝，算法设计避免重复什么的，这里return也不会错过解
    }
    
    // 遍历所有可能
    for(Choice choice : choices){

        // 判断选择是否合法，不合法剪去，这步算是实现了剪枝
    	if(isValid(state, choice)){
            //合法，进行操作
            makeChoice(state, choice);
            //操作后更新状态
            backtrack(state, choices, res);
            // 回溯
            undoChoice(state, choice);
        }
    }
    
}

```







模板解决上述问题

```java
package TestField;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

// 定义二叉树节点类
class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode(int val) {
		this.val = val;
	}
}

public class Main {

	/* 判断当前状态是否为解 */
	boolean isSolution(List<TreeNode> state) {
		return !state.isEmpty() && state.get(state.size() - 1).val == 7;
	}

	/* 记录解 */
	void recordSolution(List<TreeNode> state, List<List<TreeNode>> res) {
		res.add(new ArrayList<>(state));
	}

	/* 判断在当前状态下，该选择是否合法 */
	boolean isValid(List<TreeNode> state, TreeNode choice) {
		return choice != null && choice.val != 3;
	}

	/* 更新状态 */
	void makeChoice(List<TreeNode> state, TreeNode choice) {
		state.add(choice);
	}

	/* 恢复状态 */
	void undoChoice(List<TreeNode> state, TreeNode choice) {
		state.remove(state.size() - 1);
	}

	/* 回溯算法：例题三 */
	void backtrack(List<TreeNode> state, List<TreeNode> choices, List<List<TreeNode>> res) {
		// 检查是否为解
		if (isSolution(state)) {
			// 记录解
			recordSolution(state, res);
		}
		// 遍历所有选择
		for (TreeNode choice : choices) {
			// 剪枝：检查选择是否合法
			if (isValid(state, choice)) {
				// 尝试：做出选择，更新状态
				makeChoice(state, choice);
				// 进行下一轮选择
				backtrack(state, Arrays.asList(choice.left, choice.right), res);
				// 回退：撤销选择，恢复到之前的状态
				undoChoice(state, choice);
			}
		}
	}

	public static void main(String[] args) {
		// 构建一个简单的二叉树
		TreeNode root = new TreeNode(1);
		root.left = new TreeNode(2);
		root.right = new TreeNode(7);
		root.left.left = new TreeNode(3);
		root.left.right = new TreeNode(4);
		root.right.left = new TreeNode(7);

		Main solution = new Main();
		List<List<TreeNode>> res = new ArrayList<>();
		List<TreeNode> state = new ArrayList<>();
		state.add(root); // 初始状态包含根节点

		// 调用回溯算法
		solution.backtrack(state, Arrays.asList(root.left, root.right), res);

		// 输出所有解
		for (List<TreeNode> path : res) {
			for (TreeNode node : path) {
				System.out.print(node.val + " ");
			}
			System.out.println();
		}
	}
}
```



回溯典型例题

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250313173641758.png" alt="image-20250313173641758" style="zoom:67%;" />

在大规模数据上回溯的效果不理想



#### **`回溯典型应用`**

##### 全排列

找出给定集合中元素所有可能的排列

考虑有无相等元素



​	无相等元素

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250306173434534.png" alt="image-20250306173434534" style="zoom: 25%;" />

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250323113512643.png" alt="image-20250323113512643" style="zoom:33%;" />



无相等元素，但存在 重复选择 的情况，避免这一情况

```java
package TestField;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    static class Permutations {

        static List<List<Integer>> permutations(int[] choices) {
            List<List<Integer>> res = new ArrayList<>();
            List<Integer> state = new ArrayList<>();
            boolean[] visited = new boolean[choices.length];
            // 对数组进行排序，以便处理重复元素
            Arrays.sort(choices);
            backtrack(choices, res, state, visited);
            return res;
        }

        static void backtrack(int[] choices, List<List<Integer>> res, List<Integer> state, boolean[] visited) {
            if (state.size() == choices.length) {
                res.add(new ArrayList<>(state));
                return;
            }

            for (int i = 0; i < choices.length; ++i) {
                // 如果当前元素已经被访问过，跳过
                if (visited[i]) continue;
                // 处理重复元素
                if (i > 0 && choices[i] == choices[i - 1] && !visited[i - 1]) continue;

                visited[i] = true;
                state.add(choices[i]);

                backtrack(choices, res, state, visited);

                visited[i] = false;
                state.remove(state.size() - 1);
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {1, 1, 5, 6};
        List<List<Integer>> res = Permutations.permutations(arr);
        for (List<Integer> re : res) {
            System.out.println(re);
        }
    }
}
```









有相等元素

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250323115752689.png" alt="image-20250323115752689" style="zoom:67%;" />

因为元素相等，同一轮中选你还是选我没区别，生成的序列都是一样的



要做的就是这一轮内，在选某元素时，确定有没有已经选过它了

同一轮互相排斥，或者说只能有1个，用Set，为了便于统计用HashSet

因为递归实现，每一论都新创建一个HashSet仅记录本轮状态，所以它无需回退

```java
/* 回溯算法：全排列 II */
void backtrack(List<Integer> state, int[] choices, boolean[] selected, List<List<Integer>> res) {
    // 当状态长度等于元素数量时，记录解
    if (state.size() == choices.length) {
        res.add(new ArrayList<Integer>(state));
        return;
    }
    // 遍历所有选择
    Set<Integer> duplicated = new HashSet<Integer>();
    for (int i = 0; i < choices.length; i++) {
        int choice = choices[i];
        // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素
        if (!selected[i] && !duplicated.contains(choice)) {
            // 尝试：做出选择，更新状态
            duplicated.add(choice); // 记录选择过的元素值
            selected[i] = true;
            state.add(choice);
            // 进行下一轮选择
            backtrack(state, choices, selected, res);
            // 回退：撤销选择，恢复到之前的状态
            selected[i] = false;
            state.remove(state.size() - 1);
        }
    }
}

/* 全排列 II */
List<List<Integer>> permutationsII(int[] nums) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    backtrack(new ArrayList<Integer>(), nums, new boolean[nums.length], res);
    return res;
}
```









##### 子集和 问题

给定一个数组 `nums` 和一个目标 `target` ，找出元素和等于 `target`的子集 



​	**无重复元素情况**

给定数组无重复元素，**每个元素可以被选取多次。**



由上可知，单个元素可重复选择、{x,y}和{y,x}算重复结果

比如{3，4，5}，target 9 ，则{3,3,3}、{4，5}是结果

```java
因为可以重复选，所以不需要visited数组


如何剪枝
    
{3，4，5}和{5，4，3}是同结果重复集合

有一个特点，若选出集合3，4，5 则后面选5后，遇到4，3就跳过，这样就避免了重复集合
也就是说，选择序列应满足i1 ≤ i2 ≤ i3 …… ≤ in   ，其余情况剪枝
这样选小的还没有大的，选大的一定没有小的

为了实现上述效果，先对序列排序
然后用start 表示当前递归搜索的起始索引，用于避免重复选择同一元素


排序后又有两个优化点
    若当前子集和 > target 则。结束循环，后面的结果肯定超了
    不需要求和了，直接用target - 目前已统计的元素和
    

/* 回溯算法：子集和 I */
void backtrack(List<Integer> state, int target, int[] choices, int start, List<List<Integer>> res) {
    // 子集和等于 target 时，记录解
    if (target == 0) {
        res.add(new ArrayList<>(state));
        return;
    }
    // 遍历所有选择
    // 剪枝二：从 start 开始遍历，避免生成重复子集
    for (int i = start; i < choices.length; i++) {
        // 剪枝一：若子集和超过 target ，则直接结束循环
        // 这是因为数组已排序，后边元素更大，子集和一定超过 target
        if (target - choices[i] < 0) {
            break;
        }
        // 尝试：做出选择，更新 target, start
        state.add(choices[i]);
        // 进行下一轮选择
        // 若i改为i + 1，则没有{3，3，3}这种重复情况了
        backtrack(state, target - choices[i], choices, i, res);
        // 回退：撤销选择，恢复到之前的状态
        state.remove(state.size() - 1);
    }
    
    
    
}

/* 求解子集和 I */
List<List<Integer>> subsetSumI(int[] nums, int target) {
    List<Integer> state = new ArrayList<>(); // 状态（子集）
    Arrays.sort(nums); // 对 nums 进行排序
    int start = 0; // 遍历起始点
    List<List<Integer>> res = new ArrayList<>(); // 结果列表（子集列表）
    backtrack(state, target, nums, start, res);
    return res;
}
```



​	重复元素

每个元素只能选1次

虽然是不同元素，但是因为值相同，所以被认为是同一元素

{4(i2)，5}  {4(i3)，5}	这算是重复子集，不允许

产生的原因是值相同的不同索引元素在同一轮中被选择，这样在接下来它们各自的递归结束后，产生了相同的子集



限制值相同元素在同一轮中被选择即可

```java
package TestField;

import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;

public class Main {

	static List<List<Integer>> subsetSumINaive(int[] arr, int tar) {

		List<List<Integer>> res = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		int start = 0;
		Arrays.sort(arr);
		backtrack(arr, path, res, tar, start);
		return res;

	}

	static void backtrack(int[] arr, List<Integer> path, List<List<Integer>> res, int tar, int start) {

		if (0 == tar) {
			res.add(new ArrayList<>(path));
			return;
		}

		for (int i = start; i < arr.length; ++i) {

			if (tar - arr[i] < 0)
				break;
            // i > start，说明本轮选过第1个元素了
            // 因为排过序，所以值相同元素挨着
			if (i > start && arr[i] == arr[i - 1])
				continue;

			path.add(arr[i]);
            // 不允许重复元素，选择xi后，下一轮从索引x+1遍历	
			backtrack(arr, path, res, tar - arr[i], i + 1);

			path.remove(path.size() - 1);

		}
	}

	public static void main(String[] args) {

		int[] arr = {4, 4, 5 };
		List<List<Integer>> res = subsetSumINaive(arr, 9);
		for (List<Integer> item : res) {
			for (Integer i : item) {
				System.out.print(i + " ");
			}
			System.out.println();
		}

	}

}
```







##### N皇后问题

皇后所在的行、列、对角线不能有其它皇后



皇后数和棋盘行数相等，所有逐行放置，剪枝同行多皇后的情况

使用数组记录每列是否有皇后

![image-20250327195523063](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250327195523063.png)

![image-20250327195549902](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250327195549902.png)



```java
package TestField;

import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;

public class Main {

	static List<List<List<String>>> nQueens(int n) {

		List<List<List<String>>> res = new ArrayList<>();
		List<List<String>> phanel = new ArrayList<>();
		for (int i = 0; i < n; ++i) {
			List<String> row = new ArrayList<>();
			for (int j = 0; j < n; ++j) {
				row.add("#");
			}
			phanel.add(row);
		}
		boolean[] cols = new boolean[n];
		boolean[] diags = new boolean[2 * n + 1];
		boolean[] diags2 = new boolean[2 * n + 1];

		backtrack(0, n, phanel, cols, diags, diags2, res);
		return res;

	}

	static void backtrack(int row, int n, List<List<String>> state, boolean[] cols, boolean[] diags, boolean[] diags2,
			List<List<List<String>>> res) {

		if (row == n) {
			List<List<String>> Cstate = new ArrayList<>();
			for (List<String> CRow : state) {
				Cstate.add(new ArrayList<String>(CRow));
			}
			res.add(Cstate);
			return;
		}

		for (int col = 0; col < n; ++col) {

			int diag = n - 1 + col - row;
			int diag2 = col + row;
			if (!diags[diag] && !diags2[diag2] && !cols[col]) {
				state.get(row).set(col, "Q");
				diags[diag] = diags2[diag2] = cols[col] = true;
				backtrack(row + 1, n, state, cols, diags, diags2, res);

				state.get(row).set(col, "#");
				diags[diag] = diags2[diag2] = cols[col] = false;

			}

		}
	}

	public static void main(String[] args) {
		int n = 5;
		List<List<List<String>>> res = nQueens(n);

		int solutionIndex = 0;
		for (List<List<String>> solution : res) {
			System.out.println("Solution " + (++solutionIndex) + ":");
			for (List<String> row : solution) {
				System.out.println(String.join("", row)); // 将 List<String> 转换为字符串
			}
			System.out.println(); // 换行分隔不同解
		}
	}
    

}
```











































































































### 动态规划

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250331174126364.png" alt="image-20250331174126364" style="zoom:50%;" />

第i阶楼梯的上一轮只可能是在i-1或i-2阶，根据这个进行递归超过最高阶则回溯，由此通过  回溯 进行穷举解决

```java

package TestField;

import java.util.*;

public class Main {

	public static void climb(int state, List<Integer> res, List<Integer> choices, int upstairs) {

		if (state == upstairs)
			res.set(0, res.get(0) + 1);

		for (Integer choice : choices) {
			if (state + choice > upstairs)
				continue;
			climb(state + choice, res, choices, upstairs);
		}
	}

	public static void main(String[] args) {

		List<Integer> choices = Arrays.asList(1, 2);
		int state = 0;
		int upstairs = 9;
		List<Integer> res = new ArrayList<>();
		res.add(0);
		climb(state, res, choices, upstairs);
		System.out.println(res + " ");
	}
}

```

如果暴力搜索，以 dp[n] 为起始点，**递归地将一个较大问题拆解为两个较小问题的和**，直至到达最小子问题 dp[1] 和 dp[2] 时返回

```java
/* 搜索 */
int dfs(int i) {
    // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1) + dfs(i - 2);
    return count;
}

/* 爬楼梯：搜索 */
int climbingStairsDFS(int n) {
    return dfs(n);
}
```

对于问题 dp[n] ，其递归树的深度为 n ，时间复杂度为 O(2n) 。指数阶属于爆炸式增长，其原因是重叠子问题导致

例如 dp[9] 被分解为 dp[8] 和 dp[7] ，dp[8] 被分解为 dp[7] 和 dp[6] ，两者都包含子问题 dp[7] 。



#### 记忆化搜索

在问题拆解过程中，会有很多重叠子问题，这些重叠子问题被反复计算，损耗性能

记忆化搜索通过记忆子问题的解，需要时取，解决重叠子问题

记忆化搜索 就是 通过存储子问题的解 解决重叠子问题 

```java
/* 记忆化搜索 */

public static int dfs(int n, int[] dp) {

    if (n == 1 || n == 2)
        return n;
    if (dp[n] != -1)
        return dp[n];

    int count = dfs(n - 1, dp) + dfs(n - 2, dp);
    dp[n] = count;

    return count;
}

public static int climb(int n) {

    int[] mem = new int[n + 1];
    // mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录
    Arrays.fill(mem, -1);
    return dfs(n, mem);

}
```

所有重叠子问题都只需计算一次，时间复杂度优化至 O(n) 





#### 动态规划

记忆化搜索是原大问题拆为不可分子问题，然后回溯逐层收回子问题的解



由于问题的解可能由更小问题的解得到，最终发现，不需要dp表，子解可递推，实现空间优化

因此动态规划与记忆化搜索相反	省略回溯和递归

```java
/* 爬楼梯：动态规划 */
int climbingStairsDP(int n) {
    if (n == 1 || n == 2)
        return n;
    // 初始化 dp 表，用于存储子问题的解
    int[] dp = new int[n + 1];
    // 初始状态：预设最小子问题的解
    dp[1] = 1;
    dp[2] = 2;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}


// 这道题其实和斐波那契数列本质一致
// 这里其实不要dp也行，但为了体现动态规划思想，没有优化
// 以后的动态规划，像这种某个状态只和前面有限个状态相关，可以不要dp
```



动态规划的常用术语

- 将数组 `dp` 称为 dp 表，dp[i] 表示状态 i 对应子问题的解。
- 将最小子问题对应的状态（第 1 阶和第 2 阶楼梯）称为初始状态。
- 将递推公式 dp[i]=dp[i−1]+dp[i−2] 称为状态转移方程。

它起到了与记忆化搜索中数组 `mem` 相同的记录作用















**分治、回溯、动态规划	区分**

3者本身就有很多重合的地方

关键区别：

分治不断递归分解问题，并在回溯中合并问题的解  子问题相互独立

**典型应用**：
排序（归并排序、快速排序）、搜索（二分查找）、矩阵乘法（Strassen 算法）

回溯关键在于 穷举	在穷举过程中 尝试、回退、剪枝	问题的解由这一系列决策组成

**典型应用**：
斐波那契数列、背包问题、最长公共子序列（LCS）、最短路径问题

动态规划 不需要递归，如果递归是自顶向底，那动态规划就是自底向顶， 子问题存在重叠，需要记忆化存储来去重

**典型应用**：
八皇后问题、数独求解、子集和问题、全排列生成

​	



动态规划的特性：重叠子问题、最优子结构、无后效性





​	`最优子结构`

原问题最优解来自子问题最优解

​	`无后效性`

当前状态仅与过去有关，不会因未来的决策而改变



无后效性与子问题相互独立不是一个概念，子问题是解决一个子问题不会影响另一个子问题的解





**修改原问题，体现动态规划特性**

修改原问题，体现最优子结构

![image-20250331205045103](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250331205045103.png)

设 dp[i] 为爬到第 i 阶累计付出的代价，由于第 i 阶只可能从 i−1 阶或 i−2 阶走来，因此 dp[i] 只可能等于 dp[i−1]+cost[i] 或 dp[i−2]+cost[i] 。为了尽可能减少代价，我们应该选择两者中较小的那一个

```java
package TestField;

import java.util.*;

public class Main {

	/* 爬楼梯：动态规划 */
	static int climb(int[] cost) {
		int n = cost.length - 1;
        // 只有1阶或2阶
		if(n == 1 || n == 2)
			return cost[n];
		int a = cost[1], b = cost[2];
		for(int i = 3; i <=n; ++i) {
			int tmp = b;
			b = Math.min(a, tmp) + cost[i];
			a = tmp;
            /*一开始a=1,b=2。随着发展，b不断上升1阶，a也上升1阶，也就成了原来的b阶
            */
		}
        // b存储了到达终点的消耗
		return b;
	}

	public static void main(String[] args) {

		// 每阶楼梯的消耗
		int[] cost = {1,4,5,7,8,9,3};
		System.out.println(climb(cost) + " ");
	}
}
```





约束原问题，失去  无后效性

![image-20250401112723837](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250401112723837.png)

这时候 动态规划 需要结合 记忆化搜索的优点：记录子问题解	

**状态 [i,j] 表示处在第 i 阶并且上一轮跳了 j 阶**，其中 j∈{1,2} 。此状态定义有效地区分了上一轮跳了 1 阶还是 2 阶

```java

package TestField;

import java.util.*;

public class Main {

	/* 爬楼梯：动态规划 */
	static int climb(int n) {
		
		if(n == 1 || n == 2)
			return 1;
		// 需要包括n本身、2，由于数组特性，所以写成这样
		int[][] dp = new int[n + 1][2 + 1];
		
		// 设置基本值状态
		dp[1][1] = 1; 
		dp[1][2] = 0;//不存在
		dp[2][1] = 0;//受约束，不能实现
		dp[2][2] = 1;
		
		for(int i = 3; i <= n; ++i) {
			dp[i][1] = dp[i - 1][2];
            // 这里要注意，因为是跳2阶过来的，实际是从i-2位置过来的
			dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
		}
		
		return dp[n][1] + dp[n][2];
		
	}
	

	public static void main(String[] args) {

		// 每阶楼梯的消耗
		int n = 9;
		System.out.println(climb(n) + " ");
	}
}
```



上面的只需要考虑前1个状态，所以通过扩展状态定义，问题重新满足无后效性

但如果不止考虑1个状态

![image-20250401115515591](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250401115515591.png)

每次跳跃都依赖过去所有状态，动态规划难以解决



总结来说，若问题能被分解为可重复计算的子问题，且子问题的最优解可组合成原问题的最优解，则动态规划是合适的选择。它通过存储中间结果（记忆化或表格）和 自底向顶的设计  显著提升效率，避免递归中的指数级时间复杂度。

但如果子问题**不满足**无后效性，可尝试扩展状态定义解决

动态规划不适合 后效性严重的问题



除了上述，还有一些判断是不是动态规划问题的加减项

“加分项”

- 问题包含最大（小）或最多（少）等最优化描述
- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系

“减分项”

- 问题的目标是找出所有可能的解决方案，而不是找出最优解
- 问题描述中有明显的排列组合的特征，需要返回具体的多个方案





动态规划一般求解步骤

描述决策，定义状态，建立 dp 表，推导状态转移方程，确定边界条件等

![image-20250401122627184](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250401122627184.png)







#### 最长公共子序列-LCS



#### 最长上升子序列-LIS



















### 贪心

不断做出当下最利的选择

不断局部最好



- 动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。（经验）
- 贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。（眼前）









### 素数

素数是大于1、除了1和本身没有任何因子的自然数



#### 试除法	一个一个因子算的就不说了



#### `求素数的几种方法：`

判断单个数字是否为素数
试除法（穷举法）
优化方法一：范围缩小到n/2，原因是合数因子范围为[2，n/2]
优化方法二：使用奇偶数性质优化，原因是素数是奇数，奇数不能被2的整数倍(偶数)整除
优化方法三：上面两种方法结合
优化到sqrt(n)的试除法，原因是因子成对且分布在sqrt(n)两侧，检测一侧即可
优化方法一：使用奇偶性质优化，原因不重复
筛选区间范围内的素数
埃氏筛
引入中，利用任何数字的倍数都不是素数的性质
埃氏筛，只对素数进行倍增，利用唯一分解定理，合数必然可以分解出素因子
优化方法一：倍增从 i 开始
优化方法二：只对奇数进行素数判定，以为素数一定是奇数
优化方法三：开平方优化，同样是因为数字的因子成对出现且分布在sqrt(n)两侧
欧拉筛
1.
这里有多种优化方法，有的甚至是多种优化方法复合使用。但在复合使用前，需要先判断一下这样做是否会影响程序的正确性。





#### 缩小查找范围

一个数字x有因子a,b，可以写成x=a*b的形式。

a和b是一种负相关的关系，不会同时变大或者变小。当a最小为2时，b最大为x/2。

反之亦然。因此，可以推断出x如果有其他因子，那么这个因子一定是在[2，x/2]范围内。基本原理和上面一致，都是试除法。在新的范围内如果没有可以整除的数字，那么就说明n没有其他因子，说明n是素数。



```java
#include<stdio.h>

int IsPrime(int n)
{
    int i,m;
    if(n<2)
        return 0;
    else
    {
        m=n/2;//其他代码都没有变，只是这里范围变动了一下
        for(i=2;i<=m;i++)//这里应该取等号，保证区间右侧大于等于左侧。不然可能会造成4的误判
        {//2和3不能保证区间右侧大于左侧，但是这两个数字是素数，因此没有关系。
            if(n%i==0)
                return 0;
        }
        return 1;
    }
}

int main()//主函数不变
{
    int n;
    printf("请输入要检验的数字\n");
    while(scanf("%d",&n)!=EOF)
    {
        if(IsPrime(n)==1)
            printf("%d是素数\n\n",n);
        else
            printf("%d不是素数\n\n",n);
    }
    return 0;
}


```





#### 从性质入手



除了2，没有偶素数了

那只对奇数进行筛选就行了



再加上缩小查找范围的方法，提速

```c
#include<stdio.h>

int IsPrime(int n)
{
    int i,m;
    if(n<2||(n!=2&&n%2==0))//如果n小于2或者n是不等于2的偶数，则n不是素数
        return 0;//直接返回0
    else
    {//到这里的n都是奇数
        m=n/2;//加了这一步
        for(i=3;i<m;i+=2)//范围左端不取2，因此右端不取m=n/2
        {
            if(n%i==0)
                return 0;
        }
        return 1;
    }
}

int main()//主函数不变
{
    int n;
    printf("请输入要检验的数字\n");
    while(scanf("%d",&n)!=EOF)
    {
        if(IsPrime(n)==1)
            printf("%d是素数\n\n",n);
        else
            printf("%d不是素数\n\n",n);
    }
    return 0;
}

// 时间复杂度从试除法的O(n)降到了O(n/4)
```



因子虽然都是在[2，num/2]这个范围内，但因子在数轴上，总是一个前一个后。在此范围内，如果前半部分都没有找到因子，那么必然后半部分的数字也不是因子。那么这个前后的分界线在哪里呢？

这个分界线就是根号num，下面用sqrt(num)表示。



数字的因子有一个特点，就是成对出现的（两个成对的因子相乘才等于原来的数字），并且成对出现的因子分布在sqrt(n)的两侧

简单证明一下为什么一定分布在sqrt(n)两侧：假设k=sqrt(n)，那么k*k=n

如果成对的两个因子不分布在k的两侧，比如同时大于k或者同时小于k。因为k*k=n，那么这两个成对因子相乘的结果要么是大于n，要么是小于n。既然相乘结果都不是n，那么就不是n的因子，则与最开始的假设相悖。

得到上面的性质之后，就可以对朴素算法再进行优化。

因为因子是成对出现，并且分布在sqrt(n)两侧。那么判断数字有无其他因子的时候，判断范围可以从[2，n-1]缩小到[ 2，sqrt(n) ]。（如果[2， sqrt(n) ]没有因子，那么[ sqrt(n) ， n-1]也不会有因子。原因就是前面提到的，因子是成对出现的）



```java
// 对朴素算法的优化
#include<stdio.h>
#include<math.h>//sqrt的头文件

int IsPrime(int n)
{
    int i,m;
    if(n<2)
        return 0;
    else
    {
        m=(int)sqrt((double)n)//sqrt函数中形参类型是double类型，这里进行一下转换防止出错
        for(i=2;i<=m;i++)//缩小判断范围，判断2-sqrt(n)范围内有无其他因子即可
        {//数字的因子是成对出现的，且分布在sqrt(n)两侧。因此判断一侧没有因子，就可知另一侧也没有
            if(n%i==0)//其他步骤不变
                return 0;
        }
        return 1;
    }
}

int main()//主函数不变
{
    int n;

    printf("请输入要检验的数字\n");
    while(scanf("%d",&n)!=EOF)
    {
        if(IsPrime(n)==1)
            printf("%d是质数\n\n",n);
        else
            printf("%d不是质数\n\n",n);
    }
    return 0;
}




// 不使用sqrt函数
int IsPrime(int n)
{
    int i;
    if(n<2)
        return 0;
    else
    {//函数其他部分不变
        for(i=2;i*i<=n;i++)//这里用i替代了开根号的过程
        {//这里应该取等号，需要取到i=sqrt(n)这个值
            if(n%i==0)
                return 0;
        }
        return 1;
    }
}


```





这个性质也可以用到奇素数

```java
int IsPrime(int n)
{
    int i;
    if(n<2||(n!=2&&n%2==0))//n小于2或者n是不等于2的偶数，必然非素数
        return 0;
    else//这里n都是奇数
    {//这里使用上面刚提到的写法，用i代替开根号的过程
        for(i=3;i*i<=n;i+=2)//这里注意循环条件
        {//2必然不是因子，从3开始，每次递增2，直到sqrt(n)为止
            if(n%i==0)
                return 0;
        }
        return 1;
    }
}

```





#### 素数筛

之前的算法都是把数字拆分为因子相乘的形式。对范围区间内的数字进行判断时，每个数字都要拆。



**可以反向构造**

根据合数的性质，找合数

事先不知道一个数是否为素数，但是可以通过创造合数（非素数）达到找出素数的目的

数字可以划分为素数和合数两大类，那么当我们把某一范围内的合数都标记出来，则剩下的数字就是素数。

如何构造合数呢？在大于1的数字中任取两个数字a，b相乘即可，这样得到的结果c必然有1，a，b，c四个因子（当a=b时为三个因子）那么c必然是合数



用算法来说就是

源数据容器，访问数组

每得到1个合数就对它 在寻找范围内 进行倍增操作

同时标记为访问过

一次就可以得到若干结果

没被访问过的就是素数



```java
package TestField;

import java.io.*;
import java.util.*;

public class Main {

	static Scanner sc = new Scanner(System.in);

	public static void main(String[] args) {

		int a = sc.nextInt();
		int b = sc.nextInt();
		isPrime(a, b);
		sc.close();

	}

	public static void isPrime(int a, int b) {

		if (a < 2)
			return;

		boolean[] vis = new boolean[b + 1];
		vis[0] = vis[1] = true;
		// 01不算，标记为访问过 	可以不写

		for (int i = 2; i * i <= b; ++i) {
			if (!vis[i]) {
				// 不需要标记i。因为i从2开始，2、3是素数，后面的数要么是它俩的倍数，要么是它俩倍数的倍数，没有例外
				for (int j = i * i; j <= b; j += i) {
					vis[j] = true;
				}
			}

		}

		List<Integer> res = new ArrayList<>();
		for (int i = a; i <= b; ++i) {
			if (!vis[i])
				res.add(i);
		}
		
		for (int i = 0; i < res.size(); ++i)
			System.out.print(res.get(i) + " ");
	}

}
```



```c++
#include<stdio.h>
#include<string.h>//memset函数的头文件

//设定一个宏，定义数组大小
#define maxn 20010

int vis[maxn];//vis用来判断数字是否访问过
int prime[maxn];//prime用来存储筛选出来的素数


int sieve(int n)
{
    int i,j,k;
    k=0;//i用来控制逐个访问，j用来第二轮标记，k用来标记prime数组位置
    //这里在函数中置为0，保证每一次函数调用时都清空，不会受到上次使用完后的结果
    //理论上需要这样做，但是在此程序中可以省略，因为数字范围彼此之间是子集的关系，而范围的改变不会改变数字的性质
    memset(vis,0,sizeof(int)*maxn);//将访问数组清零。可以使用short或者C++的bool类型节省内存、
    vis[0]=vis[1]=1;//将0和1标记为已访问，不标记其实也可以，因为我们素数的计数是从2开始
    for(i=2;i<=n;i++)//从最小的素数2开始筛选，2以下就没必要筛选
    {
        if(vis[i]==0)//这个数是目前最小的，且未被访问过的
            prime[k++]=i;//因此这个数是素数
        for(j=2;i*j<=n;j++)//j表示倍数，从两倍开始倍增，直到上界为止
            vis[i*j]=1;//将倍数标记为已访问
    }
    return k;//返回范围内素数的个数
}

void print(int k)//打印结果函数
{
    int i;
    for(i=0;i<k;i++)
    {
        printf("%5d ",prime[i]);//每个数字占5个宽度，右对齐，保持输出结果整洁
        if((i+1)%5==0)//每五个为一组换行
            printf("\n");
    }
    printf("\n\n");
}

int main()
{
    int n;//求n以内的素数
    int k;//保存返回的素数个数
    while(scanf("%d",&n)!=EOF)
    {
        k=sieve(n);
        if(k==0)
            printf("(1-%d]范围内没有素数\n",n);
        else
            printf("(1-%d]范围内的素数有:\n",n);
        print(k);
    }
}


```

上述存在重复标记的情况

引入

唯一分解定义：任何一个大于 1 的自然数N, 如果 N 不为素数，那么 N 可以唯一分解成有限个素数的乘积

也就是说合数的因子一定有素数

换成对素数进行倍增，标记为true的均为素数

这是👇埃氏筛

#### 埃氏筛

```java
//埃氏素数筛函数
int Eratosthenes_sieve(int n)//这里用了英文全称，平时用sieve等命名就好
{
    int i,j,k;
    k=0;
    memset(vis,0,sizeof(int)*maxn);
    vis[0]=vis[1]=1;
    for(i=2;i<=n;i++)//从最小的素数2开始筛选，2以下就没必要筛选
    {
        if(vis[i]==0)//这个数是目前最小的，且未被访问过的
        {
            prime[k++]=i;//因此这个数是素数,存储起来
            for(j=2;i*j<=n;j++)//这里的改变就是把损坏放入if判断语句之内
                vis[i*j]=1;//只对素数进行倍增筛选，其他基本不变
        }
    }
    /*for(i=2;i<=n;i++)
    {
        if(vis[i]==0)
        // 和上文区别从这里开始了
            prime[k++]=i;
        for(j=2;i*j<=n;j++)
            vis[i*j]=1;
        // 就是判断为素数，用{}包裹起来
    }*/
    
    return k;//返回范围内素数的个数
}
```

但埃氏筛仍存在重复标记情况

​	

​	优化方式一

这是倍增起点选择的问题：假设i = b, 则数字b 倍增2倍 和 数字2 倍增b倍是同一情况

把埃氏筛从2开始倍增改为从i开始倍增，解决重复标记

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250327115641328.png" alt="image-20250327115641328" style="zoom: 67%;" />

```c++
//埃氏素数筛函数
int Eratosthenes_sieve(int n)
{
    int i,j,k;
    k=0;
    memset(vis,0,sizeof(int)*maxn);
    vis[0]=vis[1]=1;
    for(i=2;i<=n;i++)
    {
        if(vis[i]==0)
        {
            prime[k++]=i;
            for(j=i;i*j<=n;j++)//仅仅是这里，把j=2改为j=i
                vis[i*j]=1;
        }
    }
    return k;
}

```



​	优化方式二

加上之前说的只对奇数判断是否为素数

```c++
//埃氏素数筛函数-奇数优化版
int Eratosthenes_sieve(int n)
{
    if(n<2)//之前不加上这句，是因为可以通过循环条件进行判定
        return 0;//现在前面有预处理，需要先判断
    int i,j,k;
    k=0;
    memset(vis,0,sizeof(int)*maxn);
    vis[0]=vis[1]=1;
    vis[2]=0;//这步可以省略，加上后方便理解
    prime[k++]=2;//这步很重要，不能省略，容易忘记
    for(i=3;i<=n;i+=2)//只对奇数判定，因此从3开始，步长为2
    {
        vis[i+1]=1;//把偶数的标记补上
        //这里存在大于n的风险，因此需要把数组开大一点
        //如果是i-1，则当n为偶数时，n的标记不能补上
        if(vis[i]==0)
        {
            prime[k++]=i;
            for(j=i;i*j<=n;j++)//这里把j=2改为j=i
                vis[i*j]=1;
        }
    }
    return k;
}
```



继续优化，加上sqrt

```c++
//埃氏素数筛函数
int Eratosthenes_sieve(int n)
{
    if(n<2)
        return 0;
    int i,j,k;
    k=0;
    memset(vis,0,sizeof(int)*maxn);
    vis[0]=vis[1]=1;
    vis[2]=0;
    for(i=4;i<=n;i+=2)//这里把偶数全部标记为1，非素数
        vis[i]=1;

    for(i=3;i*i<=n;i+=2)//这里只是把 i<=n 改为 i*i<=n  实现sqrt()
    {
        if(vis[i]==0)//对素数进行倍增
        {
            for(j=i;i*j<=n;j++)//这里把j=2改为j=i
                vis[i*j]=1;
        }
    }

    //上面的循环，只循环到sqrt(n),因此要存储范围内的素数，需要重头遍历一遍
    prime[k++]=2;
    for(i=3;i<=n;i+=2)//只遍历奇数
    {
        if(vis[i]==0)
            prime[k++]=i;
    }
    return k;//返回素数的个数
}


```





#### 欧拉筛

通过上面种种优化（对素奇数倍增、从2开始改成从i开始，sqrt……），解决了重复倍增问题，但是还有一个问题，重复筛除

比如说12，可能在2的时候被筛除，可能在6的时候被筛除。通过上面的优化也会在3的时候被筛除，合数越大它的素因子越多，则重复被筛除的次数就越多。能不能只筛除1次？又因为循环是从小到达循环，自然想到在最小素因子处筛除，后序就不用反复筛除了

这是欧拉筛要实现的

欧拉筛的框架和埃氏筛大致相同，区别点在于第二层循环对倍增过程的操作。埃氏筛是，只要是素数就进行倍增。而欧拉筛是用  当前遍历的数字去乘以素数表中的素数。

重复筛除也用上 上述种种优化

​	用素数倍增，素数倍增从从平方开始

​	比如 i 循环到6，前面有素数2,3,5，这三个素数会以2×2，3×3，5×5的平方方式倍增，不会出现2×3，3×2的情况



实现筛选1次：

欧拉筛的核心思想是让每个合数都被它的最小质因数筛除。在代码中，我们用`i`遍历从 2 到`n`的所有数，对于每个`i`，我们用它乘以之前找到的素数`prime[j]`来标记合数。

关键语句`if(i % prime[j] == 0) break;`

```java
//先看核心代码
int Euler_sieve(int n)
{
    int i,j,k;
    k=0;//保存素数的个数
    memset(vis,0,sizeof(int)*maxn);//初始化数组
    for(i=2;i<=n;i++)
    {
        if(vis[i]==0)//i是素数，则存起来
            prime[k++]=i;
        for(j=0;j<k;j++)//进行倍增，用i去乘以i之前(包括i)的素数
        {
            if(i*prime[j]>n)//倍增结果超出范围，退出
                break;

            vis[ i*prime[j] ]=1;//将倍增结果进行标记

            if(i%prime[j]==0)//i是前面某个素数的倍数时，也需要退出
                break;
        }
    }
    return k;
}
```

当`i % prime[j] == 0`时，意味着`prime[j]`是`i`的一个素因数，并且由于`prime`数组是按素数从小到大排列的，所以`prime[j]`是`i`的最小质因数。下面详细解释为什么此时要跳出内层循环：

假设`i % prime[j] == 0`，那么可以设`i = a * prime[j]`（其中`a`是一个正整数）。此时我们考虑`i * prime[j + 1]`，将`i = a * prime[j]`代入可得：

i×prime[j+1]=*a*×prime[j]×prime[j+1]

这表明`i * prime[j + 1]`是`prime[j]`的倍数。也就是说，`i * prime[j + 1]`这个合数的最小质因数是`prime[j]`。

当我们继续往后遍历`i`时，一定会遇到一个数`x`，使得`x * prime[j] = i * prime[j + 1]`。例如，当`i = 12`，`prime[j] = 2`，`prime[j + 1] = 3`时，12×3=36，而当`x = 18`时，18×2=36。

这就意味着，后面一定还会遇到这个数，如果现在不跳出内层循环，继续用`i`乘以`prime[j + 1]`、`prime[j + 2]`等素数就重复标记合数了，通过`if(i % prime[j] == 0) break;`这条语句，我们可以避免这种重复标记，保证每个合数只被它的最小质因数筛除一次。

```java
package TestField;

import java.util.ArrayList;
import java.util.List;

public class Main {

	public static List<Integer> sieveOfEuler(int n) {
		boolean[] vis = new boolean[n + 1];
		List<Integer> prime = new ArrayList<>();
		for (int i = 2; i <= n; i++) {
			if (!vis[i]) {
				prime.add(i);
			}
			for (int j = 0; j < prime.size() && i * prime.get(j) <= n; j++) {
				vis[i * prime.get(j)] = true;
				if (i % prime.get(j) == 0) {
					break;
				}
			}
		}
		return prime;
	}

	public static void main(String[] args) {
		int n = 50;
		List<Integer> primes = sieveOfEuler(n);
		System.out.println("小于等于 " + n + " 的素数有：");
		for (int p : primes) {
			System.out.print(p + " ");
		}
	}

}
```



```java
// 查找指定范围内的素数
import java.util.ArrayList;
import java.util.List;

public class EulerSieve {
    public static List<Integer> sieveOfEuler(int a, int b) {
        boolean[] vis = new boolean[b + 1];
        List<Integer> prime = new ArrayList<>();
        for (int i = 2; i <= b; i++) {
            if (!vis[i]) {
                // 若当前素数在指定范围内，则添加到结果列表
                if (i >= a) {
                    prime.add(i);
                }
                for (int j = 0; j < prime.size() && i * prime.get(j) <= b; j++) {
                    vis[i * prime.get(j)] = true;
                    if (i % prime.get(j) == 0) {
                        break;
                    }
                }
            }
        }
        return prime;
    }

    public static void main(String[] args) {
        int a = 10;
        int b = 50;
        List<Integer> primes = sieveOfEuler(a, b);
        System.out.println("在 " + a + " 到 " + b + " 范围内的素数有：");
        for (int p : primes) {
            System.out.print(p + " ");
        }
    }
}    
```























































### 并查集

树形、对不相交集合 查询、合并

pre[] 记录前驱

find(x) 

join(x, y)



```java
public int find(int x){ // 通过集合的代表元判断，同一代表元，则属于同一集合
    while(find[x] != x)	//只有代表元的pre是自己，根据这个找代表元
        x = pre[x];
    return x;
}
```



```java
public void join(int x, int y){
    int fx = find(x);	//合并不相交集合前 先确定是否来自同一集合
    int fy = find(y);
    if(fx != fy)		// 确定是不同集合，合并，这里我就随意指定了
        pre[fx] = fy;
    
}
```





​	**路径压缩一（优化find（））**

因为节点查询根节点确定是否同一集合，无论经过多少节点都要到达代表元（目标固定），还有就是树结构不确定（可能朝1个方向插，成链表了），索性直接让所有节点的pre都是根节点，一步到位

```java
int find(int x){
    if(pre[x] == x) return x;
    pre[x] = find(pre[x]);
}
```

有个问题，只有找到代表元 并 完成递归后，压缩才算完成，所以首次找到代表元前的查询过程是没效果的

```java
// 查找结点 x 的根结点 
int find(int x) {
    int root = x;
    // 找到根节点
    while (pre[root] != root) {
        root = pre[root];
    }
    // 路径压缩：将路径上的所有节点的父节点直接设为根节点
    while (x != root) {
        int next = pre[x];
        pre[x] = root;
        x = next;
    }
    return root;
}
```

​	

​	**路径压缩二（加权标记）**

节点增设权值，根据权值决定谁是上级（树层级结构由权值决定）

路径压缩一解决了退化为链表的问题，路径压缩二也要解决

单课树的情况就不看了（虽然权值分配不当也会导致树变为链表）

在合并的时候，如果根据权值决定谁归入谁，也可能导致变为链表，为此，再引入rank[]数组作为高度，主要功能似是表达子树内节点高度，其中代表元的高度自然就是整棵子树的高度，在合并时用代表元之间的rank进行比较，层数低的归入层数高的

![image-20250319173658479](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250319173658479.png)



```java
void union(int x, int y){
    x = find(x);
    y = find(y);
    if(x == y) return;
    
    if(rank[x] < rank[y])
        pre[x] = y;
    else{
        // rank[x]<ran[y]不成立，剩下情况中rank[x] == rank[y]只比rank[x]>rank[y]多了步rank[x]+1
        //直接合并
        if(rank[x] == rank[y])	rank[x]++;
        pre[y] = x;
    }

}
```





实战

```
C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。

如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。

现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。

下文中的样例说明
第一天后2和3之间的桥不能使用，不影响。
第二天后1和2之间，以及1和3之间的桥不能使用，居民们会抗议。
第三天后3和4之间的桥不能使用，居民们会抗议。
数据规模和约定
对于100%的数据，1< =n< =10000，1< =m< =100000，1< =a,  b< =n，  1< =t< =100000。

输入

输入的第一行包含两个整数n,  m，分别表示小岛的个数和桥的数量。 
接下来m行，每行三个整数a,  b,  t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。

输出

输出一个整数，表示居民们会抗议的天数。

样例输入

4  4 
1  2  2 
1  3  2 
2  3  1 
3  4  3 
样例输出

2
```



```java
/*
	如果模拟情况，要注意两个点
	1.同一天可能损坏多座桥，但只能计数1次，由于程序模拟，循环执行，会导致损坏一座桥就计数一次
	////我们只需要在i循环内，预先探测下一个桥的可用时限(bridge[i+1].day)。这样在循环时，我们每次都先用bridge[i+1].day来和当前桥的使用时限(bridge[i].day)进行对比，如果两个天数不一致，则直接模拟当前桥被损坏的过程；否则，跳过当前循环。
	
	2.每次桥毁，都要对剩下的岛重新进行unite和扫描所有并查集操作，2个操作各是n，共n^2复杂度,极限情况会超时
	////但如果反过来，模拟桥构建过程，只进行1次就够了
	为此还要对桥的使用时限进行降序排序，（使用时限短的是最先塌的，那就是最先抗议的，那就逆向当作最先修好的，最先欢呼的）
	
	
	
	
	

*/


```

















### 差分

在计算机算法中，**差分数组** 是一种高效处理 **区间更新** 和 **单点查询** 的数据结构

核心思想是通过预处理将**区间操作**的时间复杂度优化到 *O*(1)。



常规操作区间是遍历，但如果区间过大，效率就低

差分只操作区间两端（左端和右端+1（也就是右端的下一个位置，如果超过数组长度，那直接不管了就行））

左端加，右端减



用以上这种做法的话，原数组的计算也变了：

​	原数组每个位置的值等于差分数组的 **前缀和**（从第一个元素累加到当前元素）



假设原数组a = [0, 0, 0, 0, 0]，差分数组 d = [0, 0, 0, 0, 0]

l=2, r=4, c=1

则d[2] += 1` → `d = [0, 1, 0, 0, 0]	d[5] -= 1` → `d = [0, 1, 0, 0, -1]

计算前缀和：
a[1] = d[1] = 0
a[2] = d[1] + d[2] = 0 + 1 = 1
a[3] = 0 + 1 + 0 = 1
a[4] = 0 + 1 + 0 + 0 = 1
a[5] = 0 + 1 + 0 + 0 + (-1) = 0
结果就是 a = [0, 1, 1, 1, 0]



所以，差分只记录区间的边界，也只操作边界，左边界加，右边界减

差分数组由原数组相邻元素作差构建

原数组通过差分数组前缀和计算



**原序列是差分序列的前缀和，所以把差分看做前缀和的\**逆运算\****



对比

```java
int[] a = new int[6]; // 下标1-5
for (int i=2; i<=4; i++) {
    a[i] += 5;
}
// 输出：[0,5,5,5,0]
```

```java
int[] d = new int[6]; // 差分数组，下标1-5
int l = 2, r = 4, c = 5;
d[l] += c; // 起点加c
if (r+1 <= 5) { // 终点的下一个位置减c（如果存在）
    d[r+1] -= c;
}
// 计算前缀和得到原数组
int[] a = new int[6];
a[1] = d[1];
a[2] = a[1] + d[2];
a[3] = a[2] + d[3];
a[4] = a[3] + d[4];
a[5] = a[4] + d[5];
// 输出：[0,5,5,5,0]
```





```java
package TestField;

/*
 把String转换成Date对象
*/
public class Main {

	static int[] cf(int[] arr, int left, int right, int val) {

		int len = arr.length;
		int[] diff = new int[len];

		diff[0] = arr[0];
		for (int i = 1; i < len; ++i) {
			diff[i] = arr[i] - arr[i - 1];
		}

		diff[left] += val;
		if (right + 1 < diff.length)
			diff[right + 1] -= val;

		int[] res = new int[len];
		int dLen = diff.length;
		res[0] = diff[0];
		for (int i = 1; i < len; ++i) {
			res[i] = res[i - 1] + diff[i];
		}

		return res;

	}

	public static void main(String[] args) {

		int[] arr = { 1, 4, 5, 78, 89, 890, 98, 7, 69, 87, 765 };
		int[] res = cf(arr, 2, 5, 6);
		for (int i = 0; i < arr.length; ++i)
			System.out.println(res[i]);
	}
}

```













### 前缀和

前缀和 与   差分 可以理解为是一对逆运算

对于一个数组 `a = [a₁, a₂, ..., aₙ]`，它的 **前缀和数组** `s` 定义为：*s$$_{i}$$*=a$$_1$$+……+a$$_i$$
即 `s[i]` 表示原数组前 `i` 个元素的和（从第一个元素到第 `i` 个元素）。

前缀和的核心用途是 快速求区间和

常规操作是遍历，而通过前缀和，公式为：区间和 = *s*[ r ]−*s*[ l−1 ]

`s[r]` 是前 `r` 项的和，`s[l-1]` 是前 `l-1` 项的和，两者相减就是第 `l` 到第 `r` 项的和



前缀和数组的下标从 **1 开始** 主要是为了 **简化区间和的计算公式**，避免处理下标为 0 的边界情况。

```java
package TestField;

/*
 把String转换成Date对象
*/
public class Main {

	static int qzh(int[] arr, int left, int right) {

		int len = arr.length;
		int[] s = new int[arr.length + 1]; // 前缀和数组（下标1-4，s[0]=0）

		s[0] = 0;
		for (int i = 1; i <= arr.length; i++) {
		    s[i] = s[i - 1] + arr[i - 1]; // arr[i - 1] 是原数组第i个元素
		}

		return s[right] - s[left - 1];
	}

	public static void main(String[] args) {

		int[] arr = { 1, 3, 5, 7 }; // 原数组（下标0-3）
		System.out.println(qzh(arr, 2, 3));
	}
}

```









### 前缀和 vs 差分（对比记忆）

| **操作**       | 前缀和                   | 差分                     |
| -------------- | ------------------------ | ------------------------ |
| **核心功能**   | 快速求区间和（查询）     | 快速做区间加（更新）     |
| **时间复杂度** | 预处理 O (n)，查询 O (1) | 预处理 O (n)，更新 O (1) |
| **典型场景**   | 多次查询区间和           | 多次区间加，最后求单点值 |
| **数组关系**   | 原数组是前缀和的差分     | 原数组是差分的前缀和     |











### 双指针



- 快慢指针
- 对撞指针
- 滑动窗口



#### 快慢指针

一快一慢，步长一大一小。典型应用 是否有环问题（看慢指针是否能追上快指针），单链表找中间节点问题（快指针到单链表结尾，慢指针刚好到一半）



#### 对撞指针

从两端 往中间去



#### 滑动窗口

一般是右端向左移动，满足条件后停止，然后左端向右端移动，也是满足条件后停止，如此反复

直到达到目标或相遇







快慢指针找环

```java
package TestField;

/*
 把String转换成Date对象
*/
public class Main {

	static class ListNode {

		int val;
		ListNode next;

		public ListNode(int val) {
			this.val = val;
			next = null;
		}

		public static boolean hasCycle(ListNode head) {
			ListNode slow = head;
			ListNode fast = head;

			while (fast != null && slow.next != null) {

				slow = slow.next;
				fast = fast.next.next;

				// 相遇，说明有环
				if (slow == fast)
					return true;
			}
			return false;

		}
	}

	public static void main(String[] args) {
		// 创建一个有环的链表用于测试
		ListNode node1 = new ListNode(1);
		ListNode node2 = new ListNode(2);
		ListNode node3 = new ListNode(3);
		ListNode node4 = new ListNode(4);

		node1.next = node2;
		node2.next = node3;
		node3.next = node4;
		node4.next = node2; // 形成环

		boolean result = ListNode.hasCycle(node1);
		System.out.println("链表是否有环: " + result);
	}
}

```







### 字符串



#### LCS	最长公共子串





#### LIS	最长递增字串

序列的子序列，可以空，不包括自己，其中元素满足i < i + 1

LIS反之最长降序子序列

还有非最长增序子序列（有相等元素）



LCS、LIS不唯一，但是它们长度一定是相等的









## **百**般红紫斗芳菲

 

### 预处理技术

进行核心任务前，对数据和问题进行预处理

比如st表、埃氏筛、前缀和数组

- **原理**：通过预处理，将数组中所有长度为 2^*k*（*k*=0,1,2,⋯）的区间的最值计算并存储起来。在进行区间查询时，利用这些预处理结果，通过组合两个不重叠的 2*k* 长度区间的最值，快速得到任意区间的最值。
- **示例**：假设有一个数组 `[1, 3, 5, 7, 2, 4, 6]`，要多次查询不同区间的最大值。使用 ST 表，预处理时会计算并存储如区间 `[0, 0]`、`[0, 1]`、`[0, 3]`、`[1, 1]`、`[1, 3]` 等长度为 2^*k* 区间的最大值。当查询区间 `[1, 5]` 的最大值时，就可以利用之前预处理存储的结果快速计算得到。







#### ST表	稀疏表

对于静态区间最值查询（RMQ）问题

ST应用**倍增、动态规划、预处理**的思想，可以实现 O(nlog⁡n) 预处理、 O(1) 查询



**引入**

如果BF

```java
static int zz(int[] arr, int l, int r) {

    int zuiZhi = Integer.MAX_VALUE;
    for (int i = l; i <= r; ++i) {
        zuiZhi = Math.min(zuiZhi, arr[i]);
    }
    return zuiZhi;
}

//	如果数组很大，会超时；
//	如果重复查询，会重复计算
```

为此可以根据动态规划的思想，预处理存储[i, j]区间的最值，具体就是存储[0,1] [0, 2] [0, 3] ······[0,n]······，所以如果数组太大，空间会炸

为此根据倍增思想，减少存储

倍增在这里就是把数组对半分成2个小数组，这样的话，其实就是存储长度为2$$^{j}$$的数组的最值，空间使用大大减少

又由于原数组分成小数组，小数组需要标记起始下标和长度，所以，ST表是二维数组st[i] [j] ，表示下标i开始长度2$$^{j}$$的区间的最值

（j其实就是i+2,i+4,i+8········，不过为了方便不这么写）



例子

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250405104536263.png" alt="image-20250405104536263" style="zoom:50%;" /> 

长度为6的数组，查询[0,5]就是查询[下标0开始，长度为4的数组，也就是[0到3]]和[下标4开始，长度为1的数组，也就是[4到5]]

所有包含$$2^j $$个数字的区间分为更小的包含$$[i，i+2^{j-1}]$$个数字的区间（最小区间只有1个数）



大数组最值由2个小数组最值的比较





**建表**

使用二维数组st[i] [j]表示 位置 `i` 开始，长度为$$ 2^j $$的区间的最小值

因为整个程序核心的计算都和log、2相关，所以

`log2` 一维数组：存储以 2 为底 `i` 的对数的整数部分，用于在查询时快速确定区间长度对应小数组的幂次。

- 对log2数组的初始化也使用了动态规划思想，动态规划具体实现又是根据对数的特性，所以log2的存储也采取了对数的特性，存储i的对数的整数部分。至于为什么只存整数，因为不要小数也没影响。这个整数就是要查区间的组成区间的长度对应的次幂，到时候根据次幂推出区间长度。

![image-20250403150354727](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250403150354727.png)



初始化 `st` 表的第1列，即位置i开始的单个元素st[i] [0]



```java
public static class STTable {

    int[][] st;
    int[] log2;

    // 初始化 ST 表
    public STTable(int[] arr) {
        int len = arr.length;
        /*
		* 原数组的组成小数组对应log Math.log返回的是以e为底的对数，需要通过换底公式，换成以2为底n的对数 对数要向上取整
		*/
        int logLen = (int) (Math.log(len) / Math.log(2)) + 1;

        // st数组第二维的大小是 以2为底n的对数的整数部分，+1因为n也要存上。
        st = new int[len][logLen + 1];
        log2 = new int[len + 1];

        // 初始化 ST 表的第一列
        // st[i][0]表示长度为2^0=1的区间的最小值，即数组中单个元素的值，所以直接将数组元素赋值给 st[i][0]
        for (int i = 0; i < len; ++i)
            st[i][0] = arr[i];

        // 通过动态规划的方式，利用 log2[i] = log2[i / 2] + 1 计算 log2 数组，方便后续查询时快速获取区间长度对应的幂次。
        for (int i = 2; i <= len; ++i)
            log2[i] = log2[i >> 1] + 1;

        // 构建 ST 表
        // 2^j ≤ n
        for (int j = 1; (1 << j) <= len; ++j) {
            // 每次加的是长度，需要-1才是索引
            for (int i = 0; i + (1 << j) - 1 < len; ++i) {
                // 表示从 i 开始，长度为2^(j−1)的子区间的结束位置的下一个位置，即第二个子区间起始位置
                st[i][j] = Math.min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
```

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250405164354678.png" alt="image-20250405164354678" style="zoom:50%;" /> 





然后通过动态规划的方式构建 ST 表

```java
// 构建 ST 表

//外层循环枚举长度，即2^1到2^logn
//j代表长度长度对应位数，所以不从0开始，整个代码长度相关的东西都是根据对数特性计算的，要注意这点
for (int j = 1; (1 << j) <= n; j++) {
//内层循环枚举起点，即1到n-2^len+1
    //为什么-1，因为
//若起始下标 i = 0，长度 len = 3，那么这个区间就是 [0, 1, 2]，结束下标 end = 0 + 3 - 1 = 2。
//若起始下标 i = 2，长度 len = 2，那么这个区间就是 [2, 3]，结束下标 end = 2 + 2 - 1 = 3。
    for (int i = 0; i + (1 << j) - 1 < n; i++) {
        //表示从 i 开始长度为2^j的区间的最小值，可以由两个长度为 2^j−1的区间的最小值合并得到
        st[i][j] = Math.min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
    }
}
```

查表

<img src="D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250405105706105.png" alt="image-20250405105706105" style="zoom:50%;" /> 

任意1个数都可以分成不同以2为底的指数之和

```java
// 查询区间 [l, r] 的最小值
public int query(int l, int r) {
    //	r - l + 1是区间对应长度
    //	获取区间 [l, r]的长度 里面存储 的幂次 k（注意，因为是通过获取该区间对半分的2个小区间计算最值，所以这个k其实是计算2个小区间的幂次，存储在【lr】区间里是因为2个小区间幂次要通过更大一级区间来获取）
    int k = log2[r - l + 1];
    //通过两个长度为 2^k的区间覆盖查询区间 `[l, r]`
    return Math.min(st[l][k], st[r - (1 << k) + 1][k]);
}

public static void main(String[] args) {
    int[] arr = {4, 6, 1, 5, 7, 3};
    STTable stTable = new STTable(arr);

    // 查询区间 [1, 3] 的最小值
    int minVal = stTable.query(1, 3);
    System.out.println("区间 [1, 3] 的最小值是: " + minVal);
}
```





```java
// 汇总
public class STTable {
    private int[][] st;
    private int[] log2;

    // 初始化 ST 表
    public STTable(int[] arr) {
        int n = arr.length;
       	// n的对数
        int logN = (int) (Math.log(n) / Math.log(2));
        st = new int[n][logN + 1];
        log2 = new int[n + 1];

        // 预处理 log2 数组
        for (int i = 2; i <= n; i++) {
            log2[i] = log2[i / 2] + 1;
        }

        // 初始化 ST 表的第一列
        for (int i = 0; i < n; i++) {
            st[i][0] = arr[i];
        }

        // 构建 ST 表
        for (int j = 1; (1 << j) <= n; j++) {
            for (int i = 0; i + (1 << j) - 1 < n; i++) {
                st[i][j] = Math.min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
            }	
        }
    }

    // 查询区间 [l, r] 的最小值
    public int query(int l, int r) {
        int k = log2[r - l + 1];
        return Math.min(st[l][k], st[r - (1 << k) + 1][k]);
    }

	public static void main(String[] args) {
		int[] arr = { 4, 6, 1, 5, 7, 3 };
		STTable stTable = new STTable(arr);

		// 查询区间 [1, 3] 的最小值
		int le = 2;
		int ri = 3;
		int minVal = stTable.query(le, ri);
		System.out.println("区间 [" + le + ", " + ri + "] 的最小值是: " + minVal);
	}
}    
```















### 图形打印

观察图形性质

比如一个空心三角

![image-20250630091050197](D:\01\技术\感获\md文档\数据结构与算法.assets\image-20250630091050197.png)

有几种解法

（1）除末行，仅首尾打印，模拟数组那样的下标情况

（2）这是个对称图形

```java
// 代码雏形有，但是还有问题
public class Main {
    public static void main(String[] args) {
        System.out.println("请输入层数");
        Scanner sc = new Scanner(System.in);
        int level = sc.nextInt();

            char character = '*';
            char characterSpace = ' ';
            int index = level >> 1;
            int tag1;
            int tag2;
            tag1 = tag2 = index;

            int i;
            while(tag2 <= level - 1) {
                i = 1;
                while (i <= level) {
                    if (i == tag2 || i == tag1) {
                        System.out.print(character);
                    } else {
                        System.out.print(characterSpace);
                    }
                    i++;
                }
                System.out.println();
                tag1 -= 1;
                tag2 += 1;

            }
            while (tag1 <= level) {
                System.out.print(character);
                tag1++;
            }
        }
}
```



（3）图形，有层数，把图形以层为单位看待，找到空格，*和层数的关系公式

```java
L1-002 打印沙漏
    分数 20
    作者 陈越
    单位 浙江大学
    本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印

    *****
    ***
    *
    ***
    *****
    所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。

    给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。

    输入格式:
输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。

    输出格式:
首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。

    输入样例:
19 *
    输出样例:
*****
    ***
    *
    ***
    *****
    2
    代码长度限制
    16 KB
    时间限制
    400 ms
    内存限制
    64 MB
    栈限制
    8192 KB





import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        //输入
        int n = sc.nextInt();
        char character = sc.next().charAt(0);
        sc.close();

        int layer = 1;
        int total = 1;

        //循环结束条件是总符号数<=n
        //每次循环都判断总符号数是否<=n,并输出当前层
        while(total + 2 * (2 * (layer + 1) - 1)  <= n){
            //所以要解决2个问题:当前层符号数的计算公式、打印当前层
            layer++;
            total += 2 * (2 * layer - 1);
        }
        //从循环出来后，layer确定了，接着 打印

        //上半部分
        //要正倒2方向打印layer 2次是计算层数的公式的原因
        //不是我想的layer/2那样上下2部分对半分层数
        for(int i = layer; i>=1; i--){
            //层数越低，空符号越多
            for(int j =0 ; j< layer - i ;j++)
                System.out.print(" ");
            for(int k =0 ; k< 2 * i - 1 ;k++)
                System.out.print(character);
            System.out.println();
        }

        //下半部分
        for (int i = 2; i <= layer; i++) {
            for (int j = 0; j < layer - i; j++) 
                System.out.print(" ");
            for (int k = 0; k < 2 * i - 1; k++) 
                System.out.print(character);
            System.out.println();
        }
        int remaining = n - total;
        System.out.println(remaining);

    }
}
```



"D:\01\技术\笔记\md文档\Java.md"





### 数独	九宫格

9*9的数组

- 每行
- 每列
- 每3*3的小数组

不能有重复元素







假设数字只能是 1-9，可以用1个整数的二进制位来标记数字是否出现

- 数字 1 对应二进制的第 1 位（从右往左数，第 1 位是 2^0=1）

- 数字 2 对应第 2 位（2^1=2）

- ……

- 数字 9 对应第 9 位（2^8=256）

    

- 数字 1 出现过 → 标记为 `1`（二进制 `000000001`）
- 数字 1 和 2 都出现过 → 标记为 `1+2=3`（二进制 `000000011`）



一直感觉代码有问题

```java
import java.io.*;
import java.util.*;

public class Main {

    static PrintWriter out = new PrintWriter(System.out);
    static Scanner sc = new Scanner(System.in);

    
    public static void main(String[] args) {
        // 有 t 个数独需要检查
        int t = sc.nextInt();
        while (t-- > 0) {
            // 每行9个，每列9个，每个小数组（3*3）9个
            int shu[] = new int[9 * 3]; 
            int f = 1; // 假设数独合法（1 代表合法，0 代表不合法）
            // i 行 j 列
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    // 读取当前格子的数字（比如 x = 5）
                    int x = sc.nextInt();
                    // 检查数字是否在 1~9 之间，否则直接判错
                    if (x > 9 || x < 1) f = 0;

                    // 第 i 行的数字出现情况（i = 0~8）
                    int mark = 1 << (x - 1);
                    if ((shu[i] & mark) != 0) f = 0; // 如果当前这一行出现了重复，则不符合
                    shu[i] |= mark; // 当前这一行加上这个数

                    // 第 j 列的数字出现情况（j = 0~8）
                    int colIndex = 9 + j; 
                    if ((shu[colIndex] & mark) != 0) { f = 0; }
                    shu[colIndex] |= mark;

                    // 第 grid 个九宫格的数字出现情况（grid = 0~8）
                    // 计算当前格子属于哪个九宫格：
                    // 行 i 属于第 (i/3) 个大组（i=0~2 属于第 0 组，i=3~5 属于第 1 组，i=6~8 属于第 2 组）
                    // 列 j 属于第 (j/3) 个大组（同理）
                    // 九宫格索引：18 + (i/3)*3 + (j/3)，例如 i=0,j=0 → 18+0+0=18（第 1 个九宫格）
                    int gridIndex = 18 + (i / 3) * 3 + (j / 3); 
                    if ((shu[gridIndex] & mark) != 0) { f = 0; }
                    shu[gridIndex] |= mark;
                }
            }
            out.println(f);
        }
        out.flush();
        out.close();
    }
//数字 x 对应的二进制位是 x-1 而非 x，因为数字 1 对应第 0 位（从 0 开始计数
//应该用 |=（按位或）来标记数字出现，而不是 +=（加法）。
//  |= 能确保二进制位被设置为 1 且不影响其他位，而 += 会导致数值错误（比如重复标记时数值叠加）
}
```



```java
import java.io.*;
import java.util.*;

public class Main {

    static PrintWriter out = new PrintWriter(System.out);
    static Scanner sc = new Scanner(System.in);
    
    public static void main(String[] args) {
        // 有 t 个数独需要检查
        int t = sc.nextInt();
        while (t-- > 0) {
            // 每行9个，每列9个，每个小数组（3*3）9个
            int shu[] = new int[9 * 3]; 
            int f = 1; // 假设数独合法（1 代表合法，0 代表不合法）
            // i 行 j 列
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    // 读取当前格子的数字（比如 x = 5）
                    int x = sc.nextInt();
                    // 检查数字是否在 1~9 之间，否则直接判错
                    if (x > 9 || x < 1) f = 0;

                    // 第 i 行的数字出现情况（i = 0~8）
                    // 数字 x 对应的标记是 2 的 (x-1) 次方（因为数字 1 对应第 0 位，x=5 对应 2^4=16）
                    int mark = 1 << (x - 1);
                    if ((shu[i] & mark) != 0) f = 0; // 如果当前这一行出现了重复，则不符合
                    shu[i] |= mark; // 无论是否合法，先记录，后面如果合法会用到

                    // 第 j 列的数字出现情况（j = 0~8）
                    //由于前9个元素用于存储行,所以列的信息从索引 9 开始
                    if ((shu[9 + j] & mark) != 0) { f = 0; }
                    shu[9 + j] |= mark;

                    
                    //由于前 18 个元素（0 - 17）分别用于存储行和列的信息，所以九宫格的信息从索引 18 开始
                    /*i / 3：i 是行号，i / 3 能把数独的 9 行划分为 3 个大组（每个大组包含 3 行）。例如，i 从 0 到 2 属于第 0 组，i 从 3 到 5 属于第 1 组，i 从 6 到 8 属于第 2 组。
j / 3：j 是列号，j / 3 能把数独的 9 列划分为 3 个大组（每个大组包含 3 列）。例如，j 从 0 到 2 属于第 0 组，j 从 3 到 5 属于第 1 组，j 从 6 到 8 属于第 2 组。
i / 3 * 3 + j / 3：这部分计算出当前格子 (i, j) 所属的九宫格编号，范围是从 0 到 8。把这个编号加上 2 * 9，就得到了该九宫格在 shu 数组中的索引。*/
                    // 第 grid 个九宫格的数字出现情况（grid = 0~8）
                    // 计算当前格子属于哪个九宫格：
                    // 行 i 属于第 (i/3) 个大组（i=0~2 属于第 0 组，i=3~5 属于第 1 组，i=6~8 属于第 2 组）
                    // 列 j 属于第 (j/3) 个大组（同理）
                    // 九宫格索引：18 + (i/3)*3 + (j/3)，例如 i=0,j=0 → 18+0+0=18（第 1 个九宫格）
                    int gridIndex = 18 + (i / 3) * 3 + (j / 3); 
                    if ((shu[gridIndex] & mark) != 0) { f = 0; }
                    shu[gridIndex] |= mark;
                }
            }
            out.println(f);
        }
        out.flush();
        out.close();
    }
//数字 x 对应的二进制位是 x-1 而非 x，因为数字 1 对应第 0 位（从 0 开始计数
//应该用 |=（按位或）来标记数字出现，而不是 +=（加法）。
//  |= 能确保二进制位被设置为 1 且不影响其他位，而 += 会导致数值错误（比如重复标记时数值叠加）
}
```



```java
// 重复部分比较多，所以我封装了

package TestField;

import java.io.*;
import java.util.*;

public class Main {

	static PrintWriter out = new PrintWriter(System.out);
	static Scanner sc = new Scanner(System.in);

	// 每行9个，每列9个，每个小数组（3*3）9个
	static int shu[] = new int[9 * 3];
	static int f = 1; // 假设数独合法（1 代表合法，0 代表不合法）

	static void fengzhuang(int i, int mark) {
		if ((shu[i] & mark) != 0)
			f = 0; // 如果当前这一行出现了重复，则不符合
		shu[i] |= mark; // 当前这一行加上这个数
	}

	public static void main(String[] args) {
		// 有 t 个数独需要检查
		int t = sc.nextInt();
		while (t-- > 0) {

			// i 行 j 列
			for (int i = 0; i < 9; i++) {
				for (int j = 0; j < 9; j++) {
					// 读取当前格子的数字（比如 x = 5）
					int x = sc.nextInt();
					// 检查数字是否在 1~9 之间，否则直接判错
					if (x > 9 || x < 1)
						f = 0;

					// 第 i 行的数字出现情况（i = 0~8）
					int mark = 1 << (x - 1);	
					fengzhuang(i, mark);

					// 第 j 列的数字出现情况（j = 0~8）
					int colIndex = 9 + j;
					fengzhuang(colIndex, mark);

					// 第 grid 个九宫格的数字出现情况（grid = 0~8）
					// 计算当前格子属于哪个九宫格：
					// 行 i 属于第 (i/3) 个大组（i=0~2 属于第 0 组，i=3~5 属于第 1 组，i=6~8 属于第 2 组）
					// 列 j 属于第 (j/3) 个大组（同理）
					// 九宫格索引：18 + (i/3)*3 + (j/3)，例如 i=0,j=0 → 18+0+0=18（第 1 个九宫格）
					int gridIndex = 18 + (i / 3) * 3 + (j / 3);
					fengzhuang(gridIndex, mark);
				}
			}
			out.println(f);
		}
		out.flush();
		out.close();
	}
//数字 x 对应的二进制位是 x-1 而非 x，因为数字 1 对应第 0 位（从 0 开始计数
//应该用 |=（按位或）来标记数字出现，而不是 +=（加法）。
//  |= 能确保二进制位被设置为 1 且不影响其他位，而 += 会导致数值错误（比如重复标记时数值叠加）
}
```





### 单位换算

 Byte（字节）的简称是 **B**， **bit（比特位）** 的简称是**b**

1 字节（Byte） = 8 位（bit）

- b（bit）是比特，最小单位。
- B（Byte）是字节，1B=8b。
- Kb 是千比特，1Kb=1024b。
- Mb 是兆比特，1Mb=1024Kb。
- Gb 是吉比特，1Gb=1024Mb。

最小是位bit，其次是字节byte





### 日期

Date

```java
import java.util.Date;

public class Main{
    public static void main(String[] args){
        
        // 创建日期对象，把当前的时间转成日期对象
		System.out.println(new Date()); // Sat Sep 19 23:11:21 CST 2020
		
        // 创建日期对象，把当前的毫秒值转成日期对象
		System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970

		Date date = new Date();
		System.out.println(date.getTime());
        // 输出毫秒数
    }
}
```



SimpleDateFormat

| 标识字母（区分大小写） | 含义 |
| ---------------------- | ---- |
| y                      | 年   |
| M                      | 月   |
| d                      | 日   |
| H                      | 时   |
| m                      | 分   |
| s                      | 秒   |

只有 月 和 时 大写

```java
package TestField;

import java.text.SimpleDateFormat;

public class Main {
    public static void main(String[] args) {
        // 对应的日期格式如：2018-01-16 15:06:38
    	SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    }    
}

```

- `public String format(Date date)`：将Date对象格式化为字符串。
- `public Date parse(String source)`：将字符串解析为Date对象。



```java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
/*
 把Date对象转换成String
*/
public class Demo03DateFormatMethod {
    public static void main(String[] args) {
        Date date = new Date();
        // 创建日期格式化对象,在获取格式化对象时可以指定风格
        SimpleDateFormat df = new SimpleDateFormat("yyyy年MM月dd日");
        String str = df.format(date);
        System.out.println(str); // 2020年09月19日
    }
}

```

```java
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
/*
 把String转换成Date对象
*/
public class Demo04DateFormatMethod {
    public static void main(String[] args) throws ParseException {
        SimpleDateFormat df = new SimpleDateFormat("yyyy年MM月dd日");
        String str = "2018年12月11日";
        Date date = df.parse(str);
        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018
    }
}

```



## 竞赛积累



### 题目分析





### 问题

 

#### ***\*以前的东西有点忘了，也算是基础不好\****

 

得有印象，知道什么东西去哪找，手册比赛时可查

D:\01\技术\笔记\md文档\Java.md

![img](D:\01\技术\笔记\md文档\数据结构与算法.assets\wpsD720.tmp.jpg) 

String、StringBuffer……

BigDecimal

 

 

#### ***\*ACM模式\****

模块化思想养成习惯

遵守指定输入输出格式

实现的方法包装成pinYin ( num ) 

输入输出和封装方法分开

 

 

 

#### ***\*DEBUG\****

比如这个arr[numStr[i] - '0'];

 

 

 



### 技巧

 

 

#### **作答方式**

pta和蓝桥杯作答方式一致

```java
import java.util.Scanner;
// 1: 无需package
// 2: 类名必须Main, 不可修改
// 3：要导包

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        //在此输入您的代码...
        scan.close();
    }
}
```

 

```c++
//	可以只写main，在main里实现方法
#include <iostream>
using namespace std;

int main() {

    //实现代码
    return 0;
}






//或者main外定义方法，main内调用		推荐这种
#include <iostream>
using namespace std;


void fun() {
    //执行代码
}

int main() {

    fun();
    return 0;
}
```

 

 

 



#### 将字符串中的字符转换为对应的数字

int digit = num.charAt(i) - '0';

 





#### 运行超时

2025年2月21日 我第一次遇到`运行超时`，用BufferReader代替Scanner后问题解决

对于竞赛，一丝一毫都要注意，只要避免了坑，能用更高效的办法就用





第1个我写的	第2个ai写的

测试点我没拿到所有分，原因是我只看到-600这1个测试点，忽略了正数

所以，代码要写的通用性强，全面，还有别只看到眼前的测试点

```c++
#include <iostream>
#include <string>

using namespace std;

const static string pinYin[] = {"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"};

void printPinYin(string numStr){

    if(numStr[0] == '-' )
        cout << "fu";
    for(int i = 1; i<numStr.length();i++){
        cout << " ";
        int digit = numStr[i] - '0';
        cout << pinYin[digit];
    }
    
}

int main(){

    string numStr;
    cin >> numStr;
    
    printPinYin(numStr);
    return 0;
}




#include <iostream>
#include <string>
using namespace std;

int main() {
    string numStr;
    cin >> numStr;

    // 存储数字对应的拼音
    string pinyin[10] = {"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"};

    // 处理负数情况
    if (numStr[0] == '-') {
        cout << "fu";
        numStr = numStr.substr(1);
    }

    for (int i = 0; i < numStr.length(); i++) {
        if (i > 0) {
            cout << " ";
        }
        int digit = numStr[i] - '0';
        cout << pinyin[digit];
    }

    return 0;
}
```







```java
/* 
一个大规模数据集的测试点始终不通过，通过减少字符串操作，提前结束不必要处理，更高效的api等技术迭代，最终通过，这些就是对java知识熟悉，和一些基本操作，但其中我要了解的是自定义输入读取器（使用自定义的 InputReader 类来处理输入，它直接从输入流中读取字节，避免了 BufferedReader、StringTokenizer 和 split 方法带来的额外开销，这种方式在处理大量数据时效率更高。）
*/


import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.BitSet;

public class Main {
    static class InputReader {
        
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        
/*
stream：用于存储输入流，通过构造函数传入，借助它来读取数据。
buf：这是一个字节数组，大小为 1024，作为缓冲区使用，用于一次性从输入流中读取一定数量的数据，从而减少与输入流的交互次数，提升读取效率。
curChar：表示当前在缓冲区 buf 中读取的字节位置。
numChars：记录当前缓冲区 buf 中有效的字节数量
*/

        public InputReader(InputStream stream) {
            this.stream = stream;
        }
/*
该构造函数接收一个 InputStream 类型的参数 stream，并将其赋值给类的成员变量 stream，以此完成输入流的初始化。
*/

        private int read() {
            if (numChars == -1)
                throw new RuntimeException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }


/*
此方法的作用是从缓冲区 buf 中读取一个字节。
首先检查 numChars 是否为 -1，若为 -1 则表示输入流已结束，此时抛出 RuntimeException 异常。
接着检查 curChar 是否大于或等于 numChars，若满足条件，说明缓冲区中的数据已全部读取完毕，需要从输入流中重新读取数据到缓冲区。将 curChar 重置为 0，调用 stream.read(buf) 方法将数据读取到 buf 中，并将读取的字节数赋值给 numChars。若读取的字节数小于等于 0，意味着输入流已结束，返回 -1。
若缓冲区中还有未读取的数据，返回 buf[curChar]，并将 curChar 加 1。
*/



        public int nextInt() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new RuntimeException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
/*
该方法用于从输入流中读取一个整数。
首先调用 read 方法读取一个字节，然后跳过所有的空白字符（如空格、换行符等），直到遇到非空白字符。
检查该字符是否为负号 -，若是则将符号标志 sgn 设为 -1，并继续读取下一个字符。
初始化结果变量 res 为 0，接着进入循环，将读取到的数字字符转换为对应的整数，并累加到 res 中。每次循环都将 res 乘以 10，然后加上当前字符对应的数字。
当遇到空白字符时，循环结束，返回 res * sgn。
*/

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
/*
该方法用于判断一个字符是否为空白字符，包括空格、换行符、回车符、制表符以及输入流结束标志（-1）。若为空白字符则返回 true，否则返回 false。
*/
    }

    
    public static void main(String[] args) {
        InputReader in = new InputReader(new BufferedInputStream(System.in));
        int n = in.nextInt();

        BitSet hasFriends = new BitSet(100000);

        for (int i = 0; i < n; i++) {
            int k = in.nextInt();
            if (k > 1) {
                for (int j = 0; j < k; j++) {
                    hasFriends.set(in.nextInt());
                }
            } else {
                in.nextInt();
            }
        }

        int m = in.nextInt();
        StringBuilder result = new StringBuilder();
        boolean first = true;
        for (int i = 0; i < m; i++) {
            int id = in.nextInt();
            if (!hasFriends.get(id)) {
                if (!first) {
                    result.append(' ');
                }
                for (int j = 10000; j >= 1; j /= 10) {
                    result.append(id / j % 10);
                }
                first = false;
                hasFriends.set(id);
            }
        }

        if (result.length() == 0) {
            System.out.println("No one is handsome");
        } else {
            System.out.println(result);
        }
    }
}
```













#### **`代码模板`**



`主类`

```java
//主类


import java.util.Scanner;
// 1: 无需package
// 2: 类名必须Main, 不可修改
// 3：要导包

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        //在此输入您的代码...
        scan.close();
    }
}
```





`输入输出`

```Java
package TestField;

import java.io.*;
import java.util.*;
import java.math.BigDecimal;

public class Main {

	static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
	static String[] line = null;
	static String[] line2 = null;

	public static void main(String[] args) throws IOException {
		
		// 输入单个
		line = in.readLine().split(" ");
		int a = Integer.parseInt(line[0]);
		
		out.println(a);
		out.flush(); // 输出1次就必须刷新，否则有问题
		
		
		// 一次性输入一组，以空格分割
//		line = in.readLine().split(" ");
//		for(int i = 0; i < 10; ++i) {
//			int x = Integer.parseInt(line[i]);
//			out.printf("%d", x);
//			out.flush();
//		}
		
		
		// 连续输入，没任何问题，只有输出的时候需要刷新
		line = in.readLine().split(" ");
		line2 = in.readLine().split(" ");
		int a = Integer.parseInt(line[0]);
		int b = Integer.parseInt(line2[0]);
		out.println(a + b);
		out.flush();

//		
		// 使用结束后关闭
		out.close();
		
		
	}

}
```





```java
//	输出
//	数据量大的时候用BufferedWriter输出

    
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) throws Exception {

		Scanner cin = new Scanner(System.in);
		BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));

		int a1 = 66;
		char a2 = '6';
		String a3 = "66";
		cout.write(a1);
		cout.write("\n");
		cout.write(a2);
		cout.write("\n");
		cout.write(a3);
		cout.write("\n");
		cout.flush();
		cin.close();
	}
}

//输出
B
6
66

//	需要注意的是 write() 不能直接输出int类型， 因为write(int a) 会输出其对应的ASCii码的字符 ,比如输出 65 会显示 A。需要注意的是 write() 不能直接输出int类型， 因为write(int a) 会输出其对应的ASCii码的字符 ,比如输出 65 会显示 A。
//	所以当需要输出一个int类型的变量时， 可以用Integer.toString(int a)方法 将其变为字符串形式输出。或者使用 + 拼接一个字符串，这样 参数整体就是一个字符串了，比如加一个换行符。所以当需要输出一个int类型的变量时， 可以用Integer.toString(int a)方法 将其变为字符串形式输出。或者使用 + 拼接一个字符串，这样 参数整体就是一个字符串了，比如加一个换行符。

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner cin = new Scanner(System.in);
        BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));
        int a1 = 66;
        cout.write(a1+"\n");
        cout.write(Integer.toString(a1));
        cout.flush();
        cin.close();
    }
}

//输出
66
66

```



![image-20250222105414976](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250222105414976.png)







`数组模板`

​	动态数组分配

```java
//	动态数组分配
String s[][] = new String[2][]; *//这里的String 可以换成其他类型*
    
```

​	数组复制

![image-20250222112944629](D:\01\技术\笔记\md文档\数据结构与算法.assets\image-20250222112944629.png)

```java
import java.util.Arrays;

//	Arrays.copyOf(原数组，新数组长度)


如果newLength小于源数组的长度，则将源数组的前面若干个元素复制到目标数组。
如果newLength大于源数组的长度，则将源数组的所有元素复制到目标数组
```

​	数组填充

```java
//	Arrays.fill();

Arrays.fill(arr,3);//给所有值赋值3
Arrays.fill(arr,2,4,6);//[2,4) 下标2（包括）到4（不包括）赋值为6
```



​	数组排序

```java
//	Arrays.sort(); //数组排序

数字数组默认从小到大
字母数组默认升序

严格按照字母表排序

String[] strArray = new String[] { “z”, “a”, “C” };
Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);
//输出： [a, C, z]



```





`java常用类`

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String A = br.readLine();
        String B = br.readLine();
BufferReader 是给 Reder的缓冲区，从内存读取更快
   

StringBuffer 是 字符串缓冲区，让字符串更强
不过一般都是用 StringBuilder sb = new StringBuilder();
```



```java
Math.pow()

//注意Math的返回值
```



```java
//	枚举

public class Main {

	enum Week {
		MONDAY, TUESDAY, WEDNESDAY
	}

	public static void main(String[] args) {

		Week week = Week.MONDAY;
		System.out.println(week);

	}
}




//	枚举可以有自己的属性和方法
    enum Planet {
    MERCURY(3.303e+23, 2.4397e6),
    VENUS(4.869e+24, 6.0518e6),
    EARTH(5.976e+24, 6.37814e6),
    MARS(6.421e+23, 3.3972e6);

        
//	枚举的构造函数必须是私有的（默认也是私有），以防止外部创建枚举实例。
//	枚举可以实现接口，但不能继承其他类，因为枚举隐式继承自 java.lang.Enum 类。
    private final double mass; // 质量
    private final double radius; // 半径

    // 构造函数
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }

    // 获取质量的方法
    public double getMass() {
        return mass;
    }

    // 获取半径的方法
    public double getRadius() {
        return radius;
    }
}

public class PlanetExample {
    public static void main(String[] args) {
        Planet earth = Planet.EARTH;
        System.out.println("地球的质量是：" + earth.getMass());
        System.out.println("地球的半径是：" + earth.getRadius());
    }
}



// 枚举的values() 和valueOf()方法

enum Color {
    RED, GREEN, BLUE
}

public class ValuesExample {
    public static void main(String[] args) {
        Color[] colors = Color.values();
        for (Color color : colors) {
            System.out.println(color);
        }
    }
}




enum Day {
    MONDAY, TUESDAY, WEDNESDAY
}

public class ValueOfExample {
    public static void main(String[] args) {
        Day day = Day.valueOf("MONDAY");
        System.out.println(day);
    }
}
```



```java
import java.util.Scanner;

public class BinarySearch {

	public static int binarySearch(int[] arr, int target, int left, int right) {

		int len = arr.length;
		int le = left;
		int ri = right;

		while (left <= right) {
//		while (len >> 1 != 0) {

			int mid = left + (right - left) / 2;
//			int mid = len >>= 1;

			if (arr[mid] == target) {
				return mid;
			} else if (arr[mid] > target) {
				right = mid - 1;
//				binarySearch(arr, target, le, mid);
			} else {
				left = mid + 1;
//				binarySearch(arr, target, mid + 1, ri);
			}

		}

		System.out.println("没有");
		return -1;

	}

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int target = sc.nextInt();
		int[] arr = new int[N];

		for (int i = 0; i < arr.length; ++i) {

			arr[i] = sc.nextInt();
		}

		int result = binarySearch(arr, target, 0, arr.length - 1);
		if (result != -1) {
			System.out.println("目标元素的索引是: " + result);
		} else {
			System.out.println("没有找到目标元素");
		}

//		binarySearch(arr, target, 0, arr.length);

	}
}







/* 二分查找（双闭区间） */
int binarySearch(int[] nums, int target) {
    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素
    int i = 0, j = nums.length - 1;
    // 循环，当搜索区间为空时跳出（当 i > j 时为空）
    while (i <= j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target) // 此情况说明 target 在区间 [m+1, j] 中
            i = m + 1;
        else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中
            j = m - 1;
        else // 找到目标元素，返回其索引
            return m;
    }
    // 未找到目标元素，返回 -1
    return -1;
}
```







```java
L1-023 输出GPLT
分数 20
作者 陈越
单位 浙江大学
给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按GPLTGPLT....这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按GPLT的顺序打印，直到所有字符都被输出。

输入格式：
输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。

输出格式：
在一行中按题目要求输出排序后的字符串。题目保证输出非空。

输入样例：
pcTclnGloRgLrtLhgljkLhGFauPewSKgt
输出样例：
GPLTGPLTGLTGLGLL
代码长度限制
16 KB
时间限制
150 ms
内存限制
64 MB
栈限制
8192 KB

    
    
    

我的思路是：用最便捷高效的找到输入字符串里要求字符的数量，不用原字符串的内容，然后min（GPLT），找最小，输出，然后再找最小，再输出
```











## 模板 + 善用API

### 模板





#### 比较器

```java
@Override
public int compare(Moon o1, Moon o2) {
    if(o1.percent > o2.percent) return -1;
    else if(o1.percent == o2.percent) return 0;
    return 1;
}

compare 方法是 Comparator 接口中必须实现的方法，它接收两个参数 o1 和 o2，分别代表要比较的两个 Moon 对象。
该方法需要返回一个整数值，这个整数值的含义如下：
返回值小于 0：表示 o1 应该排在 o2 前面。
返回值等于 0：表示 o1 和 o2 在排序上是相等的，它们的相对顺序可以保持不变。
返回值大于 0：表示 o1 应该排在 o2 后面。
    
返回值决定表达式返回前者还是后者

最终返回什么，是由表达式和返回值二者共同决定
    
    这也让同一排序结果有多种表现形式
    比如    实现 从大到小 排序
	if(o1.percent > o2.percent) return -1;
	if(o1.percent < o2.percent) return  1;
	if(o2.percent < o1.percent) return  1;
	if(o2.percent > o1.percent) return -1;



//	上面的代码是比较器写法之一，有比较式和返回值2者决定排序逻辑


// 直接return差值，表达式作差
public int compare(other fo) {
    if (this.benefit == fo.benefit) 
        return this.send - fo.send;
    // 若结果 <0，说明this.seng < fo.send， this.seng排在fo.send前面
}


// 基本类型的包装类的compare方法
@Override
public int compareTo(Family other) {
    if (avgAreaThis != avgAreaOther) {
        return Double.compare(avgAreaOther, avgAreaThis);
    }
    return Integer.compare(id, other.id);
    
    
}



Comparable 接口：Comparable 接口位于 java.lang 包中，它只有一个抽象方法 compareTo(T o)。此接口的作用是让类本身具备比较和排序的能力，也就是类的实例之间能够相互比较大小。
Comparator 接口：Comparator 接口处于 java.util 包中，它有一个抽象方法 compare(T o1, T o2)。该接口用于定义一个外部的比较器，可在不修改类本身的情况下，为类的对象定义不同的排序规则。
    
```



#### 快速IO

读题判断数据量

当输入数据量超过 **1e5 级别**（如 10 万行、10 万个数）

混合整数、浮点数、科学计数法或非标准分隔符的输入的特殊处理格式

👇

用快速IO



​	为什么快速IO有效

缓冲机制，减少底层系统的 IO 操作（如从硬盘或网络读取数据）。

最后通过`out.close()`或显式调用`flush()`统一写入，减少 IO 次数。普通IO每次调用会自动换行并刷新缓冲区（相当于`System.out.flush()`），频繁刷新会强制将缓冲区内容写入底层设备，耗时较高。

字符串处理逻辑	**`BufferedReader` + `StringTokenizer`**：直接按行读取字符串，再通过`StringTokenizer`分割

直接返回字符串或通过字符串解析数值，避免了不必要的对象创建和装箱操作。减少拆箱装箱

对于`BigInteger`、`BigDecimal`等大数类型直接读取字符串后转换





IO没有普适性很强的模板



当数据格式简单（如每行数据用空格分隔）时，BufferedReader 的输入效率更高。StreamTokenizer 的自动解析逻辑在处理复杂格式时更方便，但可能成为性能瓶颈



1. StreamTokenizer

```java
// 如果中间需要输出，那就要flush();
.nextToken();
.sval
.nval
throws IOException
close();
还要注意调用，不是. 是直接用

package TestField;

import java.io.*;
import java.math.BigDecimal;
import java.util.Arrays;

public class Main {

	static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in), 32768));
	static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

	static int nextInt() throws IOException {
		in.nextToken();
		return (int) in.nval;
	}

	static String next() throws IOException {
		in.nextToken();
		return in.sval;
	}

	static BigDecimal nextBigDecimal() throws IOException {
		in.nextToken();
		return new BigDecimal(in.nval);
	}

	public static void main(String[] args) throws IOException {

		int n = nextInt();
		out.print(n + " ");
		out.flush();
		String s = next();
		out.print(s + " ");
		out.flush();
		BigDecimal b = nextBigDecimal();
		out.print(b + " ");

		out.close();
	}
}
```



StreamTokenizer

把输入流中的文本按照一定规则分解成一个个标记，标记可以是单词、数字、符号等。它能够识别不同类型的标记，像标识符、数字、引号引起来的字符串等，并且可以对不同类型的标记进行不同的处理。

```java
import java.io.*;
import java.util.InputMismatchException;

public class FastIO {
    static InputReader sc = new InputReader();
    static PrintWriter out = new PrintWriter(System.out);

    static class InputReader {
        private InputStream inputStream = System.in;
        private byte[] buf = new byte[100000];
        private int curChar;
        private int numChars;

        public int getchar() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = inputStream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int a = 0, b = 1;
            int c = getchar();
            while (c < '0' || c > '9') {
                if (c == '-') {
                    b = -1;
                }
                c = getchar();
            }
            while (c >= '0' && c <= '9') {
                a = (a << 1) + (a << 3) + (c ^ 48);
                c = getchar();
            }
            return a * b;
        }
    }

    public static void main(String[] args) {
        // 示例使用
        int num = sc.nextInt();
        out.println(num);
        out.flush();
        out.close();
    }
}    
```











2.BufferedReader + PrintWriter

```java
package TestField;

import java.io.*;
import java.util.*;
import java.math.BigDecimal;

public class Main {

	static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
	static String[] line = null;
	static String[] line2 = null;

	public static void main(String[] args) throws IOException {
		
		// 输入单个
		line = in.readLine().split(" ");
		int a = Integer.parseInt(line[0]);
		
		out.println(a);
		out.flush(); // 输出1次就必须刷新，否则有问题
		
		
		// 一次性输入一组，以空格分割
//		line = in.readLine().split(" ");
//		for(int i = 0; i < 10; ++i) {
//			int x = Integer.parseInt(line[i]);
//			out.printf("%d", x);
//			out.flush();
//		}
		
		
		// 连续输入，没任何问题，只有输出的时候需要刷新
		line = in.readLine().split(" ");
		line2 = in.readLine().split(" ");
		int a = Integer.parseInt(line[0]);
		int b = Integer.parseInt(line2[0]);
		out.println(a + b);
		out.flush();

//		
		// 使用结束后关闭
		out.close();
		
		
	}

}

/*
BufferWriter明确使用缓冲区
PrintWriter如果使用new OutputStreamWriter，则是指定使用缓冲区，就和bw这点一样了
同时pw提供方便的输出，如println（）等
pw是自动刷新，每次使用打印方法，都会自动flush（）
所以还是用pw
*/
```





#### lambda表达式

lambda 表达式允许把函数作为一个方法的参数（函数作为参数传递进方法中）

```java
import java.util.Arrays;

public class Main {
    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
        String[] plants = {"Mercury", "venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};
        Arrays.sort(plants, (String first, String second) -> (first.length() - second.length()));
        for (String word : plants) {
            out.print(word + " ");
        }
        out.close();
    }
}



// 只有一条语句，用（）包裹且不需要返回值

import java.io.PrintWriter;
import java.util.Arrays;

public class Main {
    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
        String[] plants = {"Mercury", "venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};
        Arrays.sort(plants, (first, second) ->
        {
            // 形参不写类型，可以从上下文判断出
            int result = first.length() - second.length();
            return result;
        });
        
        
        for (String word : plants) {
            out.print(word + " ");
        }
        out.close();
    }
}
```



















































### API





[Java算法题常用API整理总结_java算法题常用到的一些api-CSDN博客](https://blog.csdn.net/weixin_45488428/article/details/123352697)

| `gcd(BigInteger val)`      | 返回 this 的绝对值与 val 的绝对值的最大公约数 |
| -------------------------- | --------------------------------------------- |
| `isProbablePrime(int val)` | 返回一个表示 this 是否是素数的布尔值          |
| `nextProbablePrime()`      | 返回第一个大于 this 的素数                    |







Collections 是对数组操作的工具类

Arrays 是对集合操作的工具类

还是当初那句话，名字含义就是API的功能

还有

​	比如List，它是列表，存储有序可重复的元素

​	ArrayList是就是基于动态数组实现的列表

​	LinkedList就是基于双向链表实现的列表

​	其它的都这么理解

`Collection`

1. List	有序（插入顺序）允许重复
    1. ArrayList
    2. LinkedList(双向链表实现list)
    3. Vector
        1. Stack
    
2. Queue  有序（插入顺序、优先级）允许重复
    1. LinkedList（queue实现list）
    
    2. PriorityQueue  基于优先级排序的队列（默认小顶堆）  
    
        new PriorityQueue<(Comparator.reverseOrder());（大顶堆）
    
        new PriorityQueue<>((a, b) -> b - a);
    
    3. Deque  双端队列
    
3. Set         有序、唯一
    1. HashSet  无序、唯一
    2. TreeSet
    3. LinkedHashSet
    4. SortedSet
    
4. Map       有序（键排序）、键唯一
    1. HashMap    无序、键唯一
    2. TreeMap
    3. LinkedHashMap


以上附加了对元素的顺序和唯一性的考虑

以下是具体场景对数据结构的选取



### `开头:我也属于API`

### **一、根据数据特性选择**



考虑  	对应、唯一、有序

#### **1. 需要有序性**

- **保持插入顺序**：`ArrayList`、`LinkedList`、`LinkedHashSet`、`LinkedHashMap`
    （如：需要保留输入顺序输出时）
- **自然排序或自定义排序**：`TreeSet`、`TreeMap`
    （如：需要按字典序、数值大小排序时）
- **优先级排序**：`PriorityQueue`
    （如：需要每次取出最大 / 最小元素时）
- **随即位置**  `Hash 实现的`

#### **2. 需要唯一性**

- **快速去重**：`HashSet`、`HashMap`（键唯一）
    （如：统计不同元素数量时）
- **有序去重**：`TreeSet`、`LinkedHashSet`
    （如：输出去重后的有序列表时）

#### **3. 需要键值对存储**

- **无序键值对**：`HashMap`
    （如：统计单词出现次数时）
- **有序键值对**：`TreeMap`（按键排序）、`LinkedHashMap`（按插入顺序）
    （如：需要输出按键排序的统计结果时）

### **二、根据操作类型选择**

#### **1. 频繁增删操作**

- **链表结构**：`LinkedList`
    （如：需要在链表中间插入 / 删除节点时）
- **队列 / 栈操作**：`LinkedList`（实现 Queue/Deque 接口）、`Stack`
    （如：广度优先搜索 BFS 用 Queue，深度优先搜索 DFS 用 Stack）

#### **2. 频繁随机访问**

- **数组结构**：`ArrayList`
    （如：需要通过索引快速访问元素时）

#### **3. 需要高效查找**

- **哈希表**：`HashSet`、`HashMap`
    （如：判断元素是否存在时，时间复杂度 O (1)）
- **有序查找**：`TreeSet`、`TreeMap`
    （如：查找某个范围的元素时，可利用有序性优化）

### **三、典型算法题场景**

#### **1. 数组去重并保持顺序**

- 插入顺序 + 唯一性

    ：

    ```
    LinkedHashSet
    ```

    java

    

    

    

    

    

    ```java
    List<Integer> list = new ArrayList<>(new LinkedHashSet<>(array));
    ```

#### **2. 优先队列（Top K 问题）**

- 最小堆 / 最大堆

    ：

    ```
    PriorityQueue
    ```

    java

    

    

    

    

    

    ```java
    // 最大堆（降序）
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
    ```

#### **3. 图的遍历（BFS/DFS）**

- BFS（队列）

    ：

    ```
    LinkedList
    ```

    （实现 Queue 接口）

    java

    

    

    

    

    

    ```java
    Queue<TreeNode> queue = new LinkedList<>();
    ```

- DFS（栈）

    ：

    ```
    LinkedList
    ```

    （模拟栈）或

    ```
    Stack
    ```

    java

    

    

    

    

    

    ```java
    Stack<TreeNode> stack = new LinkedList<>(); // 或直接 new Stack<>()
    ```

#### **4. 统计字符频率并排序**

- 无序统计

    ：

    ```
    HashMap
    ```

    - 统计后用`TreeMap`排序

    java

    

    

    

    

    

    ```java
    Map<Character, Integer> freq = new HashMap<>();
    Map<Character, Integer> sortedFreq = new TreeMap<>(freq); // 按键排序
    ```

#### **5. 快速判断是否存在重复元素**

- 哈希表

    ：

    ```
    HashSet
    ```

    java

    

    

    

    

    

    ```java
    boolean containsDuplicate(int[] nums) {
        return nums.length != new HashSet<>(Arrays.asList(nums)).size();
    }
    ```

### **四、总结对比表**

| 场景                  | 推荐集合类                | 时间复杂度    | 典型算法题示例            |
| --------------------- | ------------------------- | ------------- | ------------------------- |
| **插入顺序 + 重复**   | `ArrayList`               | O(1) add      | 数组转列表                |
| **插入顺序 + 唯一**   | `LinkedHashSet`           | O(1) add      | 去重并保持顺序            |
| **自然排序 + 唯一**   | `TreeSet`                 | O(log n) add  | 找出数据流中的第 K 大元素 |
| **键值对 + 快速查找** | `HashMap`                 | O(1) get      | 两数之和                  |
| **键值对 + 有序输出** | `TreeMap`/`LinkedHashMap` | O(log n)/O(1) | 按频率排序元素            |
| **优先队列**          | `PriorityQueue`           | O(log n) poll | 合并 K 个有序链表         |

### **五、避坑指南**

1. **避免误用集合特性**
    - 不要用`HashSet`存储需要顺序的元素，除非题目不关心顺序。
    - 不要用`ArrayList`频繁删除中间元素（时间复杂度 O (n)）。
2. **注意默认排序规则**
    - `TreeSet`/`TreeMap`默认按自然顺序排序（需实现`Comparable`）。
    - 若需自定义排序，必须提供`Comparator`。
3. **优先选择接口编程**
    - 声明变量时用接口（如`List<String> list = new ArrayList<>()`），便于后续替换实现类。

### `结尾：我也属于API`

这个是常用方法

[力扣、牛客刷题 java各类常用方法整理 算法_java力扣常见集合-CSDN博客](https://blog.csdn.net/fan960919/article/details/119898892)



Object

1. Integer……
2. String
3. StringBuffer
4. Array
5. Arrays









































































