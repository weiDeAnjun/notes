# 数据库基础



数据是对现实事物建模



数据

数据库

数据库管理系统

数据库系统



E-R

实体-联系模型



层次型

​	只有 1 个根节点，每个节点有且仅有 1 个父节点，1 对多关系

网状型

​	完全是针对层次型不足改变，允许多对多，允许多个父节点

关系型







# Oracle 数据库

关系型数据库



## 基本操作

### 创建模式

模式名默认用户名

```sql
-- 创建用户（模式）创建用户TEST，模式TEST自动生成
create user 用户名 identified by "密码" | 密码
DEFAULT TABLESPACE USERS -- 指定默认表空间（存储模式对象）
TEMPORARY TABLESPACE TEMP ; -- 指定临时表空间（用于排序等）

-- 授予权限
GRANT xxx TO 用户名 with grant option;
-- with grant option 允许权限转授，默认不允许

alter user username identified by 234556;	-- 修改密码

revoke 权限 from 用户名; -- 卸权
drop user 用户名;	-- 删除模式


-- 对于密码：“”包裹严格区分大小写，不包裹则不区分，最终自动转大写

```

我的测试

```sql
CREATE USER U1
IDENTIFIED BY "Aa123321"
DEFAULT TABLESPACE USERS
TEMPORARY TABLESPACE TEMP;

-- 授权这种事儿，假如我现在使用的用户是scott，那就是把对scott怎样的权限赋予指定用户
GRANT RESOURCE TO U1;
ALTER USER U1 IDENTIFIED BY "AAA";
REVOKE DBA FROM U1;
DROP USER U1;
grant select on emp to u2 with grant option;
grant insert on emp to u2;
```



相关内容

| **表空间类型**                      | **典型名称**                 | **用途**                                                     | **示例操作**                                                 |
| ----------------------------------- | ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **系统表空间**                      | SYSTEM                       | 存储核心元数据（数据字典、系统代码），不可删除。             | 自动创建，默认存在，无需手动创建。                           |
|                                     | SYSAUX（10g+）               | 辅助 SYSTEM，存储非核心系统数据（如 AWR 快照），减轻 SYSTEM 负载。 | `ALTER TABLESPACE SYSAUX ADD DATAFILE ...`（扩展空间）       |
| **用户数据 / 索引表空间**(可自定义) | USERS（默认数据）            | 存储用户表、视图等数据（无指定表空间时默认分配）。           | `CREATE USER test DEFAULT TABLESPACE USERS;`（默认使用）     |
|                                     | 业务表空间（如 SALES_DATA）  | 按业务模块隔离数据（如销售、HR 数据，便于管理）。            | `CREATE TABLESPACE sales_data DATAFILE '...' SIZE 500M AUTOEXTEND ON;` |
|                                     | 索引表空间（如 SALES_INDEX） | 单独存储索引，提升 I/O 性能（数据与索引分离，减少磁头争用）。 | `CREATE TABLESPACE sales_index DATAFILE '...' SIZE 200M AUTOEXTEND ON;` |
| **临时表空间**                      | TEMP（默认临时）             | 存储排序、分组等临时数据（会话结束后清理）。                 | `CREATE TEMPORARY TABLESPACE temp TEMPFILE '...' SIZE 100M AUTOEXTEND ON;` |
|                                     | 多临时表空间（如 TEMP_ETL）  | 分配给特定任务（如 ETL 处理），避免临时空间争用。            | `ALTER USER etl_user TEMPORARY TABLESPACE temp_etl;`（指定用户临时表空间） |
| **特殊表空间**                      | UNDO 表空间（如 UNDOTBS1）   | 存储回滚数据（事务回滚、一致性读取），控制保留时间（`UNDO_RETENTION`）。 | `CREATE UNDO TABLESPACE undotbs1 DATAFILE '...' SIZE 200M AUTOEXTEND ON;` |
|                                     | 加密表空间（如 SECURE_DATA） | 加密数据（需配置钱包，支持 AES128 等算法），增强敏感数据安全。 | `CREATE TABLESPACE secure_data DATAFILE '...' ENCRYPTION USING 'AES128';` |
|                                     | LOB 表空间（如 DOC_LOB）     | 存储大对象（CLOB/BLOB），优化大字段存储（避免占用普通数据块）。 | `CREATE TABLESPACE doc_lob DATAFILE '...' SIZE 300M AUTOEXTEND ON;` |

- **系统表空间**：`SYSTEM` 是 Oracle 核心，`SYSAUX` 用于扩展系统存储，均由数据库自动管理（可扩展但不建议删除）。
- **用户表空间**：通过 `CREATE TABLESPACE` 自定义，分离数据与索引可提升查询性能（如索引表空间存于高速磁盘）。
- **临时表空间**：`TEMP` 为默认，多临时表空间可隔离不同任务（如 OLTP 与 OLAP 任务使用独立临时空间）。
- **特殊表空间**：`UNDO` 确保事务一致性，加密表空间保护敏感数据，`LOB` 表空间优化大文件存储（如图片、文档）。

对于自定义表空间

```sql
-- 业务数据+索引表空间
CREATE TABLESPACE sales_data DATAFILE '...' SIZE 500M AUTOEXTEND ON;
CREATE TABLESPACE sales_index DATAFILE '...' SIZE 200M AUTOEXTEND ON;

-- 分配给用户
CREATE USER sales_user DEFAULT TABLESPACE sales_data TEMPORARY TABLESPACE temp;
GRANT UNLIMITED TABLESPACE TO sales_user;  -- 或指定配额


-- 加密表空间（需先配置加密钱包）
CREATE TABLESPACE secure_data
DATAFILE '...'
SIZE 100M
ENCRYPTION USING 'AES128'  -- 加密算法
DEFAULT STORAGE (ENCRYPT);
```







| 权限 / 角色        | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| `CREATE SESSION`   | 允许用户登录数据库。                                         |
| `CREATE TABLE`     | 允许创建表。                                                 |
| `CREATE VIEW`      | 允许创建视图。                                               |
| `CREATE SEQUENCE`  | 允许创建序列（用于自增主键）。                               |
| `CREATE PROCEDURE` | 允许创建存储过程、函数和触发器。                             |
| `CONNECT`          | 预定义角色，包含基本连接权限（如 `CREATE SESSION`）。        |
| **`RESOURCE`**     | 预定义角色，包含创建数据库对象的权限（如 `CREATE TABLE`、`CREATE PROCEDURE`）。 |
| `DBA`              | 超级管理员角色（慎用，授予所有权限）。                       |

CREATE TABLE 等权限，需要具有系统权限的用户授予用户，不能直接 GRANT，可以通过 RESOURCE





创建了模式，就是创建了一个框架，在其定义该模式包含的数据库 **基本表**



```sql
CREATE TABLE XXX (
	列名  数据类型 列级完整性约束，
    ……
    列级完整性约束
);
```

列级完整性约束

| **NOT NULL（非空约束）**    | 确保列中不能存储空值（`NULL`）                         |                                                              |
| --------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| **UNIQUE（唯一约束）**      | 保证列中的值在整个表中是唯一的（允许有一个 `NULL` 值） |                                                              |
| **PRIMARY KEY（主键约束）** | 主键，值唯一 且 不允许 `NULL（各个属性都不许）         |                                                              |
| **CHECK（检查约束）**       | 限制列的值必须满足指定条件                             | CREATE TABLE Employees (       Age NUMBER CHECK (Age >= 18)  -- 年龄列值必须大于等于 18   ); |
| **外键约束（FOREIGN KEY）** | 引用主表的主键或唯一键于, 建立表间关系                  | 它既可以在列级定义，也可以在表级定义, 更多是用于维护表间的参照完整性，而非单纯的列级数据约束 |



我的测试

```sql
CREATE TABLE Student
(
  ID VARCHAR(100) PRIMARY KEY,
  NAME VARCHAR2(20) UNIQUE,
  SEX CHAR(1) CHECK (SEX IN ('男','女')),
  AGE NUMBER(10) NOT NULL,
  COURSE VARCHAR(20),
  
  FOREIGN KEY(COURSE) REFERENCES Course(CID)
);
```

↑

扩充

```sql
外键必须与外键来源的表里数据类型定义完全一致（都是CHAR(7)），且它是唯一的或主键

还可以添加级联操作（可选）：
ON DELETE CASCADE	定义级联删除
ON UPDATE CASCADE  	更新行为

FOREIGN KEY (COURSE) REFERENCES Course(Cno)
ON DELETE CASCADE  -- 当Course表的Cno被删除时，自动删除Student表中对应的记录


外键可以来自自己，换句话就是参照表和被参照表可以是同一个表，实例如先修课

```







修改表

```sql
alter table 表名 add 列名 VARCHAR2(100) not null;	--增列
ALTER TABLE 表名 MODIFY 列名 NUMBER; 				--修改列数据类型
alter table 表名 drop column 列名;					--删列
alter table 表名 rename COLUMN 列名 to 列名;		   --改列名

drop 和 rename 都需要+column


ALTER TABLE Student DROP COLUMN xx CASCADE CONSTRAINTS; --无视对它的依赖，强制删除


```







## 索引

```
数据量大，查询就慢，索引能加速

就像一本书，一页页翻和看目录找，不一样
```

插一嘴，主键是唯一非空索引，索引满足这 2 个条件就是间接创建主键

```sql
CREATE [UNIQUE] INDEX 索引名 ON 表名（列名1 ASC， 列名n DESC）
--在表上创建索引，索引查找1列或n列，可控制升降序

unique修饰的索引，阻止重复数据
插入时校验：当向表中插入数据时，数据库会检查唯一索引列（或列组合）是否已存在相同值。
若存在：插入操作失败，数据库抛出错误（如 ORA-00001: unique constraint violated）。
若不存在：插入成功。
已有重复数据：若表中已有重复值，创建唯一索引会失败（需要重建）
ALTER INDEX 索引名 REBUILD;



	ALTER INDEX 索引名 RENAME TO 索引名;
×	alter unique index 索引名 rename to 索引名; 
不管index有没有被unique修饰，alter的时候都不需要加unique

drop index 索引名;

我的测试
CREATE [UNIQUE] INDEX INDEX_1 ON Student (NAME ASC, SEX DESC);
```









```sql
create table indexTable(
  ID varchar2 ( 10 ),
  NAME varchar2 ( 20 ),
  constraint pk_id primary key ( ID )
)

  organization index ;
  

```





==索引组织表==

==聚簇==











``删除、清空、截断表的区别``

| 操作                       | 数据保留   | 表结构保留 | 回滚支持       | 速度 | 触发器 |
| -------------------------- | ---------- | ---------- | -------------- | ---- | ------ |
| 删除表                     | 否         | 否         | 否             | 快   | 否     |
| 清空表（`DELETE`）         | 可部分保留 | 是         | 是（未提交时） | 慢   | 是     |
| 截断表（`TRUNCATE TABLE`） | 否         | 是         | 否             | 快   | 否     |





## 数据查询

### 	单表查询

```sql
模板

[] 可选
|  或者
， 允许多条

SELECT [DISTINCT | ALL] 目标列表达式[别名]， FROM <表名|视图>[别名]， | (SELECT 语句) [AS] <别名> [WHERE <条件表达式>] [GROUP BY <列名>[HAVING <条件表达式>]] [ORDER BY <列名> [ASC | DESC]][LIMIT <行数1>[OFFECT <行数2>]];




SELECT * FROM 表名;
SELECT 列1,列2,列3 FORM 表名; 
```



| DISTINCT | 去重 |
| -------- | ---- |
|          |      |
|          |      |
|          |      |
|          |      |



查询

​	查询条件

​	聚集函数

​	谓词

​	子查询

​		

​		子查询在 from 左 或 右

**普通子查询**：子查询可以独立运行，不依赖主查询的数据。先执行子查询得到结果，再将结果代入主查询使用。

主查询直接拿这个结果做条件判断，类似用一个 “固定值 / 固定列表” 参与计算。

适合 “先算一个通用结果，再用结果过滤主查询” 的场景



**相关子查询**：子查询依赖主查询的数据，不能单独运行。主查询每遍历一条记录，子查询就执行一次，子查询中会引用主查询的列。子查询结果随主查询每行数据动态变化

适合 “每行数据需要关联自身所属分组的统计结果” 的场景



​	连表查询

​		连自己

​		联外表

​	集合查询





更新

​	插入数据 insert

​	插入子查询结果（子查询嵌入 insert 语句）

​	

​	修改数据 update

​	

​	

空值处理

空值与其他值运算（也包括空值）为 UNKNOWN





## 视图

由 n 个基本表、视图自由组合 构成（说明可以嵌套视图，嵌套视图有操作限制）

```sql
CREATE VIEW 视图名 [列名……] AS 子查询 [WITH CHECK OPTION]


[WITH CHECK OPTION]意思是 操作视图涉及行 时判断是否满足子查询的条件表达式
[列名……] 一般只有涉及多个基本表才用，毕竟如果只涉及一个基本表，直接子查询就行，不需要再在这里赘述


我的测试
CREATE VIEW is_student 
AS 
select * from emp
WHERE major = ‘计算机专业’
WITH CHECK OPTION;



```

​																																																																					

视图表会根据它来源的表、视图的内容的更新而更新，但来源结构变了，视图不会更新，这时最好重建视图

若视图还有嵌套视图，可在 DROP VIEW 视图名 后+ CASCADE 全删除

oracle 中 若清除视图来源，视图不会被自动清理，还在字典中，也就是要用 DROP 主动处理



视图有很多好处

它把注意力聚集在我只关心的地方、实现一定逻辑独立，也能从不同角度看待同一数据、简化操作、这也意味着我看不到其他数据，保护私密数据安全（比如通过视图我只能看到计算机学院的数据，那其他学院我就看不到）





## 数据库安全



有很多安全体系，规定级别代号和权限

安全手段有口令，验证等，仅看数据库安全，主要是权限



数据库安全有 3 类权限：用户权限、角色权限、系统权限



GRANT	授权

REVOKE	收权

​	

用户权限

```sql
GRANT 权限， ON 对象类型 对象名， TO 用户 [WITH GRANT OPTION]

[WITH GRANT OPTION] 被授权用户可将自身权限赋予它户

用户禁止授权给它的权力来源，不能倒反天罡
```

```sql
我的测试
GRANT INSERT ON TABLE T1 TO U1;
GRANT INSERT ON emp TO U1;
GRANT INSERT(Sno) ON TABLE T1 TO U1;
```





```sql
REVOKE 权限， ON 对象类型 对象名， FROM 用户 [CASCADE | RESTRICT]

CASCADE  收回 A 及其授予的权限
RESTRICT 默认，仅收回用户 A 的权限
```

若删除用户，其他用户被它授予的权限自动收回



以上是直接赋权给 USER，可以选择通过赋权给 ROLE 间接赋权

```sql
-- 在sys用户下操作



-- 创建角色R1和R2
CREATE ROLE R1;
CREATE ROLE R2;

-- SYS用户给R1授予系统权限
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW TO R1;

-- SCOTT用户给R2授予EMP表对象权限
GRANT SELECT, UPDATE, INSERT, DELETE ON EMP TO R2;

-- 将角色授予U3
GRANT R1, R2 TO U3;


-- SYS用户回收U3的R2角色
REVOKE R2 FROM U3;
```







==以上是数据权限，以下是数据库权限==



SQL 对创建数据库没有标准定义

一般都是先创建超级用户（具有所有权限），然后用超级用户创建 具有数据库权限 的用户

不过，↓

​	角色

角色可看作一组数据库操作相关权限的集合

可以赋予 角色数据库权，通过角色 对用户赋予数据库权限，很方便

```sql
CREATE ROLE 角色名

GRANT 权限， ON 对象类型 对象名 TO 角色，;

GRANT 角色， TO 角色，[WITH ADMIN OPTION];
```



预定义角色

| 角色名称               | 描述                                              | 典型权限 / 用途                                              |
| ---------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| `CONNECT`              | 基本用户角色，用于登录数据库                      | `CREATE SESSION`（登录权限）、`ALTER SESSION`、`CREATE TABLE` 等 |
| `RESOURCE`             | 开发者角色，允许创建数据库对象                    | `CREATE TABLE`、`CREATE PROCEDURE`、`CREATE TRIGGER` 等      |
| `SYSDBA`               | 最高系统权限，用于数据库管理（如启动 / 关闭实例） | `STARTUP`、`SHUTDOWN`、`ALTER DATABASE` 等（需操作系统或密码文件认证） |
| `SYSOPER`              | 系统操作员角色，权限低于 `SYSDBA`                 | `STARTUP`、`SHUTDOWN`、`ALTER DATABASE MOUNT` 等             |
| `SELECT_CATALOG_ROLE`  | 允许查询数据字典视图（如 `ALL_*`、`DBA_*`）       | `SELECT` 权限访问数据字典表（如 `DBA_TABLES`）               |
| `EXECUTE_CATALOG_ROLE` | 允许执行 Oracle 系统包（如 `DBMS_*`）             | `EXECUTE` 权限调用系统包（如 `DBMS_SCHEDULER`）              |



对象权限

| 权限名称     | 适用对象       | 描述                                                      |
| ------------ | -------------- | --------------------------------------------------------- |
| `SELECT`     | 表、视图、序列 | 查询对象数据                                              |
| `INSERT`     | 表、视图       | 向对象插入数据                                            |
| `UPDATE`     | 表、视图       | 更新对象数据                                              |
| `DELETE`     | 表、视图       | 删除对象数据                                              |
| `ALTER`      | 表、序列       | 修改对象结构（如添加列、修改序列）                        |
| `INDEX`      | 表             | 在表上创建索引                                            |
| `REFERENCES` | 表             | 创建外键约束                                              |
| `EXECUTE`    | 存储过程、函数 | 执行 PL/SQL 存储过程或函数                                |
| `DEBUG`      | 存储过程、函数 | 调试 PL/SQL 代码（需配合 `DEBUG ANY PROCEDURE` 系统权限） |



系统权限

| 权限名称               | 描述                                     |
| ---------------------- | ---------------------------------------- |
| `CREATE SESSION`       | 允许用户登录数据库                       |
| `CREATE TABLE`         | 允许创建表                               |
| `CREATE VIEW`          | 允许创建视图                             |
| `CREATE PROCEDURE`     | 允许创建存储过程、函数、包               |
| `CREATE USER`          | 允许创建数据库用户                       |
| `ALTER USER`           | 允许修改用户属性（如密码、配额）         |
| `DROP ANY TABLE`       | 允许删除任意用户的表                     |
| `GRANT ANY PRIVILEGE`  | 允许授予任意系统权限或对象权限（高风险） |
| `UNLIMITED TABLESPACE` | 允许使用任意表空间（需谨慎分配）         |

系统权限的 REVOKE **不支持 `CASCADE`**，因为系统权限不允许转授，是 “直接赋予用户”的。



角色管理特性

| 特性名称            | 描述                                                 |
| ------------------- | ---------------------------------------------------- |
| `WITH ADMIN OPTION` | 授予角色时附带此选项，允许接收者将角色再授予其他用户 |
| `SET ROLE`          | 临时激活 / 停用角色（需先被授予角色）                |
| `DEFAULT ROLE`      | 设置用户登录时自动激活的角色                         |
| `CREATE ROLE`       | 允许创建自定义角色                                   |



其他权限相关特性

| 特性名称               | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `REVOKE`               | 撤销用户或角色的权限 / 角色                                  |
| `PROFILE`              | 限制用户资源使用（如登录失败次数、会话时间）                 |
| `VPD（行级安全）`      | 通过 `CREATE POLICY` 创建细粒度访问控制策略，实现行级数据权限控制 |
| `SYSTEM_PRIVILEGE_MAP` | 数据字典视图，映射系统权限名称与内部编号                     |

关键说明

1. **`PUBLIC`**：默认包含所有用户的虚拟角色，可授予公共权限（如 `GRANT SELECT ON table TO PUBLIC`）。
2. **`DBA`**：预定义角色，包含大部分系统权限，但不包含 `SYSDBA` 等超级权限。
3. **权限层级**：`SYSDBA` > `DBA` > 普通角色 / 权限，需通过独立认证机制（如密码文件）获取。





**以上是自主存取控制，但是是通过用户来控制数据，无法防止用户本身泄露**

可以把用户看作主体，数据看作客体，对数据标记密度

主体密度 ≥ 数据，只能读

主体密度 ≤ 数据，只能写

读写权限分离



审计

记录用户操作，放入审计表

```sql
显示审计开关状态
SHOW AUDIT_TRAIL

打开审计开关
SET AUDIT_TRAIL TO ON;
```

对 SC 表设置审计

| **审计类型**          | **描述**                                                     | **启用方式**                                                 | **适用场景**                                  | **关键参数 / 视图**                                     |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------- | ------------------------------------------------------- |
| **语句审计**          | 监控特定类型的 SQL 语句                                      | `AUDIT {语句类型} [BY SESSION/ACCESS];` 例：`AUDIT DROP TABLE BY ACCESS;` | 追踪全局操作（如权限变更、对象删除）          | `AUDIT_TRAIL` 参数（设置为 `DB` 或 `OS`）                   |
| **对象审计**          | 针对特定数据库对象（如表、视图）的操作进行审计               | `AUDIT {操作} ON {对象} [BY ACCESS/BEFORE];` 例：`AUDIT SELECT ON employees;` | 监控敏感表的访问（如用户表、财务数据）        | `DBA_STMT_AUDIT_OPTS`（语句审计配置）                   |
| **细粒度审计（FGA）** | 通过条件表达式过滤审计事件，仅记录符合条件的操作（如 `WHERE salary > 10000`） | 使用 `DBMS_FGA.ADD_FGA_POLICY` 存储过程 例： `BEGIN<br> DBMS_FGA.ADD_FGA_POLICY(<br> object_schema => 'SCOTT',<br> object_name => 'EMP',<br> policy_name => 'EMP_SALARY_AUDIT',<br> predicate => 'SALARY > 10000'<br> );<br>END;` | 精准审计特定条件的数据操作（如敏感字段访问）  | `DBA_FGA_POLICIES`（查看策略） `FGA_LOG$`（审计日志表） |
| **统一审计（12c+）**  | 整合语句审计、对象审计和 FGA，使用统一日志格式，降低资源消耗 | 启用统一审计： `ALTER SYSTEM SET AUDIT_UNIFIED=TRUE SCOPE=SPFILE;` 重启数据库后生效 | 简化审计管理，适用于多租户（CDB）或大规模审计 | `UNIFIED_AUDIT_TRAILS` 视图 `AUDIT_UNIFIED_ENABLED` 参数  |

### **核心配置参数**

| **参数**               | **说明**                                                     | **取值示例**                                      |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| `AUDIT_TRAIL`          | 审计日志存储位置： `DB`（存储在 `AUD$` 表） `OS`（存储在操作系统文件） `XML`（XML 格式，11g+） | `ALTER SYSTEM SET AUDIT_TRAIL=DB SCOPE=SPFILE;`   |
| `AUDIT_FILE_DEST`      | 操作系统审计日志路径（仅当 `AUDIT_TRAIL=OS` 或 `XML` 时有效）    | `ALTER SYSTEM SET AUDIT_FILE_DEST='/audit/logs';` |
| `AUDIT_SYS_OPERATIONS` | 是否审计 SYSDBA/SYSOPER 用户的操作（默认 `FALSE`，需显式开启） | `ALTER SYSTEM SET AUDIT_SYS_OPERATIONS=TRUE;`     |
| `MAX_AUDIT_FILE_SIZE`  | 单个审计文件最大大小（MB，仅适用于 OS 审计）                 | `ALTER SYSTEM SET MAX_AUDIT_FILE_SIZE=100;`       |

审计日志管理

| **操作**                   | **命令 / 工具**                                              | **说明**                                                     |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 查看审计日志（数据库模式） | `SELECT * FROM DBA_AUDIT_TRAILS;`                            | 包含语句审计和对象审计记录                                   |
| 查看统一审计日志           | `SELECT * FROM UNIFIED_AUDIT_TRAILS;`                        | 12c + 适用，整合所有审计类型                                 |
| 查看 OS 审计日志           | 读取 `$ORACLE_BASE/admin/<DB_NAME>/adump/` 目录下的文件（如 `*.aud`） | 文件名格式：`<DB_UNIQUE_NAME>_<USER>_<PID>.aud`              |
| 清除审计日志               | `DELETE FROM AUD$;`（需谨慎，需具备 `DELETE ANY TABLE` 权限） 或使用 `DBMS_AUDIT_MGMT` 包 | 建议通过自动归档或分区表管理日志，避免直接删除影响审计合规性 |
| 归档审计日志               | `sql<br>BEGIN<br> DBMS_AUDIT_MGMT.CREATE_AUDIT_FILE_DEST(<br> audit_file_dest => '/backup/audit_archive',<br> audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_AUD_STD<br> );<br> DBMS_AUDIT_MGMT.ARCHIVE_AUDIT_TRAIL;<br>END;` | 适用于大规模审计日志管理，分离在线日志与归档数据             |

**审计最佳实践**

| **场景**             | **建议操作**                                                 | **原因**                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------ |
| 最小化审计开销       | 仅审计必要的操作，避免对高频业务表启用对象审计               | 审计会产生额外 I/O 和日志开销，影响性能          |
| 保护审计日志不被篡改 | 1. 对 `AUD$` 表启用基于行的访问控制（如通过 VPD） 2. 配置操作系统文件权限（仅允许 DBA 组读取） | 审计日志是合规性关键证据，需防止未授权删除或修改 |
| 应对合规性审计       | 启用统一审计并配置 `AUDIT_SYS_OPERATIONS=TRUE`，确保记录管理员操作 | 满足等保、PCI-DSS 等合规要求，追踪超级用户行为   |
| 性能优化             | 1. 使用异步审计（`AUDIT_TRAIL=DB,ASYNC`） 2. 对审计表进行分区（如按时间分区） | 减少审计对事务提交的阻塞，提升写入性能           |

**注意事项**

1. **权限要求**：普通用户需 `AUDIT_ADMIN` 角色或 `AUDIT SYSTEM` 权限才能配置审计；
2. **版本差异**：12c 之前的审计类型需分别配置，12c + 统一审计可简化管理；
3. **日志膨胀**：定期清理或归档审计日志，避免占用大量存储空间；
4. **审计开关**：可通过 `NOAUDIT` 语句禁用审计（如 `NOAUDIT DROP TABLE;`）。





## 数据库完整性

指的是正确性和相容性

正确指符合现实世界语义、反应当前实况

相容指统一对象在不同关系表一致



为保证完整性施加的事物是约束





### 实体完整性

PRIMARY KEY

约束 1 个属性是列级约束

否则是表级约束

```sql
CREATE TABLE Student
(
    Sno CHAR(8) PRIMARY KEY,
    Sname CHAR(8) PRIMARY KEY
);


CREATE TABLE Student
(
    Sno CHAR(8),
    Sname CHAR(8),
    PRIMARY KEY(Sno)
);
CREATE TABLE Student
(
    Sno CHAR(8),
    Sname CHAR(8),
    PRIMARY KEY(Sno,Sname)
);

```



### 参照完整性

FOREIGN KEY

```sql
FROEIGN KEY(外码) REFERRENCES 被参照表(外码);

CREATE TABLE Student
(
    Sno CHAR(8),
    Sname CHAR(8),
    cno CHAR(10),
    PRIMARY KEY(Sno,Sname)，
    
    FOREIGN KEY(Cno) REFERENCES CLASS_TABLE(Cid)
);
```



### 用户可自定义约束

```sql
CREATE TABLE Stu
(
	Sno CHAR(8) CHECK (Sno IN (18)),	-- 使用CHECK自定义
    Sname CHAR(20),
    Sbirthdate Date
);
```

可以上面那样，或者 ==完整性约束 命名子句==

```sql
CONSTRAINT 完整性约束命名 完整性约束

单独定义成句子，这样不仅可以对某属性约束，也可以选择对全体进行约束（比如not null）
```

我的测试

```sql
CREATE TABLE Stu
(
	C1 Sno CHAR(8),
    C2 Sname CHAR(20),
    C3 Sbirthdate Date,
    
    CONSTRAINT C1 NOT NULL,
    CONSTRAINT C2 CHECK (Sno IN (18)),
    CONSTRAINT C3 StudentKey PRIMARY KEY(Sno)--使用命名约束子句，实体完整约束有名字
    
);
```

```sql
可通过	ALTER TABLE 语句对约束命名子句修改

ALTER TABLE 表名 MODIFY CONSTRAINT 约束名 新功能;



-- 1. ENABLE VALIDATE（启用并验证所有数据）
ALTER TABLE TAB1 MODIFY CONSTRAINT CK_C2 ENABLE VALIDATE;

-- 2. ENABLE NOVALIDATE（启用但不验证已有数据）
ALTER TABLE TAB1 MODIFY CONSTRAINT CK_C2 ENABLE NOVALIDATE;
INSERT INTO TAB1 VALUES ('C', 150, 'EF');  -- 允许插入（不验证历史数据）

-- 3. DISABLE VALIDATE（禁用并验证，实际不可行，语法错误）
-- 正确语法：禁用约束
ALTER TABLE TAB1 MODIFY CONSTRAINT CK_C2 DISABLE;

-- 4. DISABLE NOVALIDATE（禁用且不验证，默认行为）
ALTER TABLE TAB1 MODIFY CONSTRAINT CK_C2 DISABLE;
INSERT INTO TAB1 VALUES ('D', 200, 'GH');  -- 允许插入

-- 删除约束
ALTER TABLE TAB1 DROP CONSTRAINT UQ_C3;



ENABLE VALIDATE：启用约束并检查所有数据（包括已存在的数据）。
ENABLE NOVALIDATE：启用约束但不检查历史数据，仅约束新数据。
DISABLE：禁用约束，允许任何数据插入。
ON DELETE CASCADE 表示删除主表记录时，子表相关记录自动删除（如删除 TAB1 的 'A'，TAB2 中 C5='A' 的记录会被自动删除）。
```



### 域的完整性限制

？











## 触发器

用户执行某操作---> 检查条件是否成立---> 执行动作

↑ 触发事件-> 检查条件-> 执行动作



触发器只能定义在基本表上，表触发器只能由表的所有者创建，且数量有限

触发事件是语句或语句的组合，或触发触发器

执行动作是一组 SQL 语句 或 已创建存储过程的调用

触发器分	行级触发器、语句级触发器

二者区别

| **维度**           | **行级触发器（Row-Level Trigger）**                          | **语句级触发器（Statement-Level Trigger）**                  |      |      |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | ---- |
| **执行频率**       | 针对 **每一行数据** 受影响时执行（如 `INSERT`/`UPDATE`/`DELETE` 的每一行） | 针对 **整个 SQL 语句** 执行一次，无论影响多少行数据            |      |      |
| **触发时机**       | 对每一行数据的操作前后触发（`BEFORE`/`AFTER` 行处理）         | 对整个语句的执行前后触发（`BEFORE`/`AFTER` 语句执行）         |      |      |
| **OLD/NEW 伪记录** | 可访问当前行的旧值（`OLD`）和新值（`NEW`）                   | 不支持 `OLD`/`NEW`，因为不针对特定行                          |      |      |
| **使用场景**       | 1. 行级数据校验（如检查工资变动范围） 2. 记录行级变更日志 3. 实现复杂的行级业务规则 | 1. 统计语句影响行数 2. 语句级权限控制 3. 审计整个操作（如记录 DDL 执行时间） |      |      |
| **性能影响**       | 高（每行触发一次，大量数据操作时可能成为瓶颈）               | 低（仅触发一次，适合批量操作）                               |      |      |

| **特性**              | **行级触发器**                                               | **语句级触发器**                                             |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **FOR EACH ROW 子句** | **必须**（显式声明）                                         | **不允许**（声明会报错）                                     |
| **触发次数**          | 与受影响行数相同（如 UPDATE 1000 行 → 触发 1000 次）         | 固定触发 1 次（无论影响 1 行还是 1000 行）                   |
| **复合触发器支持**    | 可作为复合触发器的一部分（`BEFORE EACH ROW`/`AFTER EACH ROW`） | 可作为复合触发器的一部分（`BEFORE STATEMENT`/`AFTER STATEMENT`） |

二者 的设计是性能和精细度

使用时是在性能和操作精细度（行）找平衡

```sql
CREATE TRIGGER 触发器名
BEFORE|AFTER 触发事件 ON 表名
REFERENCING NEW|OLD AS 变量
FOR EACH ROW|STATEMENT
[WHEN 触发条件]
BEGIN
	触发动作体
END;

-- TRIGGER触发器
-- REFERENCING 引用
-- |不是中文意思的或者，而是数学集合里的2择1

```

我的测试

```sql
CREATE TRIGGER T1
-- 创建触发器
BEFORE UPDATE ON Student
-- 动作
REFERENCING
	NEW AS NEWTuple
	OLD AS OLDTuple
-- 新旧变量
FOR EACH ROW
-- 触发器类型
WHEN (NEWTuple > OLDTuple)
-- 触发条件
BEGIN
	INSERT INTO SC_U(Sno,Sname,Sex)
	VALUES(OLDTuple.Sno,NEWTuple.Sname);
-- 事件
END
```



如果表有多个触发器，有执行顺序，执行顺序如下

先 BEFORE，执行事件，后 AFTER

同 BEFORE 或 AFTER，先创建的先执行（有的关系型数据库是按字母顺序）



删除触发器

```sql
DROP TRIGGER 触发器名 ON 表名
```











# 数据库设计与应用

合理的数据库设计



**NF（范式，Normal Form）** 是关系型数据库规范化的标准，符合 NF 能消除数据冗余和更新异常。

**1. 第一范式（1NF）**

- **规则**：属性原子性（不可再分）。
- **示例**：`Student(ID, Name, Course)`（每行课程为单一值，无复合属性）。
- **作用**：确保数据结构基础规范，避免集合、数组等非原子数据。

**2. 第二范式（2NF）**

- **规则**：1NF + **非主属性完全依赖于主键**（消除部分依赖，适用于复合主键）。
- **反例**：`Order(OrderID, ProductID, ProductName)`（`ProductName` 部分依赖于 `ProductID`，非完全依赖主键 `(OrderID, ProductID)`）。
- **修正**：拆分表，消除部分依赖（如分离 `Product` 表）。
- **作用**：减少复合主键下的冗余，解决部分依赖导致的更新异常。

**3. 第三范式（3NF）**

- **规则**：2NF + **非主属性不传递依赖于主键**（消除传递依赖）。
- **反例**：`Employee(ID, DeptID, DeptName)`（`DeptName` 传递依赖于 `ID`，通过 `DeptID` 间接依赖）。
- **修正**：拆分表，消除传递依赖（如分离 `Department` 表）。
- **作用**：进一步减少冗余，避免传递依赖导致的多表更新异常（如部门名称修改只需改一次）。

**4. BCNF（BC 范式）**

- **规则**：3NF + **所有非平凡函数依赖的左边是候选键**（消除主属性对候选键的依赖）。
- **反例**：存在主属性依赖非候选键（如 `CourseID → TeacherID`，而 `CourseID` 不是候选键）。
- **修正**：确保每个依赖的左边是候选键，拆分表以满足严格规范。
- **作用**：处理 3NF 中仍存在的主属性依赖，适用于高规范化场景（如数据仓库）。

**层级**：`1NF ⊂ 2NF ⊂ 3NF ⊂ BCNF`（每级约束更严格）



- **OLTP 系统**（如业务数据库）：通常满足 3NF，平衡冗余与性能（避免过度拆分影响查询效率）。
- **OLAP 系统**（如数据仓库）：可能采用 BCNF 或更高，追求极致规范化以支持复杂分析。



关键区别表

| 范式 | 核心约束             | 解决的问题             | 示例场景                             |
| ---- | -------------------- | ---------------------- | ------------------------------------ |
| 1NF  | 属性原子性           | 复合属性冗余           | 基础数据建模                         |
| 2NF  | 非主属性完全依赖主键 | 复合主键的部分依赖     | 订单 - 商品关联表（消除部分冗余）    |
| 3NF  | 非主属性无传递依赖   | 传递依赖导致的多表冗余 | 员工 - 部门表（分离部门信息）        |
| BCNF | 所有依赖左边是候选键 | 主属性依赖非候选键     | 复杂关系建模（如课程 - 教师 - 学生） |









## 数据库编程

SQL 是非过程化查询语言，缺少流程控制，缺乏业务逻辑控制

因而引入编程技术，有扩展 SQL 自身，有在高级语言中使用 SQL



==WITH RECURSIVE 递归查询==

先说 with 子句，它存储临时结果集，仅 SQL 语句执行时有效

```sql
WITH RS1[目标列,] AS (SELECT 语句，) SQL语句
```

```sql
我的测试
WITH RS1(AVG_SAL) AS 
(
  SELECT AVG(SAL) FROM EMP
)
SELECT AVG_SAL
FROM RS1;
```



WITH RECURSIVE 查询层次结构，分 2 部分：初始化临时结果集，确定第 1 层数据，然后递归查询

```sql
WITH RECURSIVE 临时结果集名 AS
(
	初始化临时结果集
    UNION ALL --是否保留重复记录
    执行递归查询
)
SQL 语句 -- RS相关查询

```



```sql
WITH RECURSIVE RS1 AS 
(
	SEED Cpno FROM COURSE WHERE Cpon = '数据库系统概论'
    UNION SELECT Course Cpno FROM Course,RS WHERE RS.Cpno = Course.Cpno
)SELECT Cno,Cname FROM Course WHERE Cno IN (SELECT Cpno FORM RS1);
```



### ==内置函数==

字符型函数

| 函数                                 | 功能                                             | 示例                                                         |         |                                     |
| ------------------------------------ | ------------------------------------------------ | ------------------------------------------------------------ | ------- | ----------------------------------- |
| `length(str)`                        | 返回字符串长度（字符数，从 1 开始计数）          | `SELECT LENGTH('Oracle') FROM DUAL;` → `6`                   |         |                                     |
| `trim(str)`                          | 去除字符串两端空格                               | `TRIM(' Hello ')` → `Hello`                                  |         |                                     |
| `lower(str)/upper(str)`              | 字符串全小写 / 全大写                            | `LOWER('AbC')` → `abc`；`UPPER('xYz')` → `XYZ`               |         |                                     |
| `concat(str1, str2)`                 | 拼接字符串（同 `str1                             |                                                              | str2`） | `CONCAT('SQL', 'Plus')` → `SQLPlus` |
| `instr(str, find_str, [start, nth])` | 查找子串位置（默认从第 1 位找第 1 次出现）       | `INSTR('Oracle', 'a')` → `0`（未找到）；`INSTR('HelloWorld', 'l', 3, 2)` → `4`（第 3 位开始找第 2 个 `l`） |         |                                     |
| `substr(str, pos, [len])`            | 截取子串（`pos` 起始位置，`len` 长度，默认到末尾） | `SUBSTR('Oracle', 2, 3)` → `rac`；`SUBSTR('Oracle', -3)` → `acle`（从右数第 3 位开始） |         |                                     |
| `lpad/rpad(str, len, pad_str)`       | 左 / 右填充至指定长度                            | `LPAD('ID', 5, '0')` → `000ID`；`RPAD('Name', 10, '*')` → `Name******` |         |                                     |
| `initcap(str)`                       | 每个单词首字母大写（空格分隔单词）               | `INITCAP('hello world')` → `Hello World`                     |         |                                     |
| `replace(str, old, new)`             | 替换子串                                         | `REPLACE('abac', 'a', 'x')` → `xbxc`                         |         |                                     |

日期型

| 函数                           | 功能                                                         | 示例                                                     |
| ------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| `sysdate`                      | 返回当前日期时间（Oracle 内置变量，非函数但常用）            | `SELECT SYSDATE FROM DUAL;` → `2025-05-27 20:19:00`      |
| `add_months(date, n)`          | 日期加减月份                                                 | `ADD_MONTHS(SYSDATE, 3)` → 3 个月后日期                  |
| `months_between(date1, date2)` | 计算月份差（`date1 - date2` 的月数，精确到小数）             | `MONTHS_BETWEEN(SYSDATE, ADD_MONTHS(SYSDATE, -1))` → `1` |
| `last_day(date)`               | 返回当月最后一天                                             | `LAST_DAY(SYSDATE)` → 2025-05-31（假设当前月 5 月）      |
| `next_day(date, '星期X')`      | 查找下一个指定星期（`'星期一'` 对应 `1`，或直接写英文 `'MONDAY'`） | `NEXT_DAY(SYSDATE, '星期三')` → 下一个星期三的日期       |
| `to_char(date, format)`        | 日期转字符串（格式如 `'YYYY-MM-DD HH24:MI:SS'`）             | `TO_CHAR(SYSDATE, 'YYYY-MM-DD')` → `2025-05-27`          |
| `to_date(str, format)`         | 字符串转日期                                                 | `TO_DATE('2025-05-27', 'YYYY-MM-DD')` → 日期类型         |

数值型

| 函数                     | 功能                                      | 示例                                                         |
| ------------------------ | ----------------------------------------- | ------------------------------------------------------------ |
| `round(num, [decimals])` | 四舍五入（`decimals` 为小数位数，默认 0） | `ROUND(123.456, 2)` → `123.46`；`ROUND(123.456, -1)` → `120`（十位四舍五入） |
| `trunc(num, [decimals])` | 截断（不四舍五入，`decimals` 同 `round`） | `TRUNC(123.456, 2)` → `123.45`；`TRUNC(123.456, -1)` → `120` |
| `ceil(num)/floor(num)`   | 向上 / 向下取整                           | `CEIL(123.1)` → `124`；`FLOOR(123.9)` → `123`                |
| `abs(num)`               | 绝对值                                    | `ABS(-100)` → `100`                                          |
| `mod(num1, num2)`        | 取余（`num1 % num2`，`num2≠0`）           | `MOD(10, 3)` → `1`；`MOD(-10, 3)` → `2`（Oracle 取余规则：结果与 `num2` 同号） |
| `sqrt(num)`              | 平方根                                    | `SQRT(25)` → `5`                                             |
| `power(num, exp)`        | 幂运算                                    | `POWER(2, 3)` → `8`                                          |

转换型

| 函数                        | 功能                                             | 示例                                        |
| --------------------------- | ------------------------------------------------ | ------------------------------------------- |
| `to_number(str, [format])`  | 字符串转数字（如 `'123.45'` 转 `NUMBER`）        | `TO_NUMBER('100.5')` → `100.5`              |
| `to_char(num/date, format)` | 数字 / 日期转字符串（数字格式如 `'999,999.99'`） | `TO_CHAR(1234.56, '9,999.99')` → `1,234.56` |
| `to_date(str, format)`      | 字符串转日期（同日期函数部分）                   | 见上文                                      |

控制与条件函数

| 函数                                           | 功能                                                 | 示例                                                         |
| ---------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| `nvl(expr1, expr2)`                            | 若 `expr1` 为 `NULL`，返回 `expr2`，否则返回 `expr1` | `NVL(NULL, 'N/A')` → `N/A`；`NVL(10, 20)` → `10`             |
| `nvl2(expr1, expr2, expr3)`                    | 若 `expr1` 非 `NULL`，返回 `expr2`，否则返回 `expr3` | `NVL2(NULL, 'A', 'B')` → `B`；`NVL2(10, 'A', 'B')` → `A`     |
| `decode(expr, search1, result1, ..., default)` | 条件判断（类似 `CASE` 表达式，更简洁）               | `DECODE(grade, 'A', '优秀', 'B', '良好', '及格')` → 根据 `grade` 返回对应值 |

聚合函数（用于谓词查询）

| 函数                  | 功能                                                    | 示例                         |
| --------------------- | ------------------------------------------------------- | ---------------------------- |
| `sum(col)`            | 求和                                                    | `SELECT SUM(sal) FROM EMP;`  |
| `avg(col)`            | 平均值                                                  | `AVG(sal)`                   |
| `max/min(col)`        | 最大值 / 最小值                                         | `MAX(sal)`, `MIN(hire_date)` |
| `count(col)/count(*)` | 计数（`count(col)` 忽略 `NULL`，`count(*)` 统计所有行） | `COUNT(ename)`, `COUNT(*)`   |

其它函数+使用场景 举例

- **`dual` 表**：Oracle 内置虚拟表，用于测试函数（如 `SELECT SYSDATE FROM DUAL;`）。
- **`case` 表达式**：非函数，但用于条件逻辑（如 `CASE WHEN sal > 10000 THEN '高薪' ELSE '普通' END`）。
- **分析函数**：如 `row_number()`, `rank()`, `dense_rank()`（用于窗口函数，需结合 `OVER` 子句，如 `ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal DESC)`）。





1. **数据清洗**：`trim` 去除空格，`replace` 替换非法字符。
2. **报表生成**：`to_char` 格式化日期 / 数字，`nvl` 处理空值为默认值。
3. **性能优化**：`instr` 快速查找子串，`substr` 截取关键信息。
4. **业务逻辑**：`decode` 简化条件判断，`add_months` 计算合同到期日。





除了以上内置函数，还有源自插件的函数，但不够，为此引入 PL/SQL 和存储过程/存储函数



### PL/SQL+存储过程/函数

#### PL/SQL

用户自定义的

PL/SQL 与 SQL 不同是过程化语言

块结构

```plsql
DECLARE
  -- 声明变量、常量、游标等
  v_empno NUMBER := 7369;
  v_ename VARCHAR2(20);
BEGIN
  -- 执行 SQL 语句和过程化代码
  SELECT ename INTO v_ename FROM emp WHERE empno = v_empno;
  DBMS_OUTPUT.PUT_LINE('员工姓名: ' || v_ename);
  
EXCEPTION
  -- 异常处理
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('未找到员工');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('错误: ' || SQLERRM);
END;
/
```

变量与数据类型

```plsql
DECLARE
  v_salary    NUMBER(8,2) := 5000.00;      -- 数字类型
  v_hiredate  DATE := SYSDATE;             -- 日期类型
  v_name      VARCHAR2(50) := 'John Doe';  -- 字符串类型
  v_valid     BOOLEAN := TRUE;             -- 布尔类型
  v_deptno    emp.deptno%TYPE;             -- 引用表列类型
  v_emp_rec   emp%ROWTYPE;                 -- 记录类型（行对象）
BEGIN
  -- 使用变量
  v_deptno = 10;
  SELECT * INTO v_emp_rec FROM emp WHERE empno = 7369;
END;
```

这里需要说明一些东西

**‘	和	“	作用不同**

| **符号** | **作用**                           | **典型场景**                      |
| -------- | ---------------------------------- | --------------------------------- |
| `'`      | 用于 **字符串常量**（固定值）       | 条件判断（`WHERE name = '张三'`） |
| `"`      | 用于 **标识符引用**（表名、列名等） | 区分大小写（`"EmpNo"`）           |

‘

若值包含单引号，需用两个单引号转义（如 `'O''Neil'` 表示 `O'Neil`）

```sql
-- 正确：字符串常量用单引号
SELECT * FROM emp WHERE ename = 'SCOTT';  

-- 转义示例：查询名字包含单引号的记录
SELECT * FROM emp WHERE ename = 'O''NEIL';  
```

”

被“包裹的叫标识符，同时 Oracle 会按原样识别标识符（表名、列名、别名等）

常用于：

- 保留大小写（默认 Oracle 标识符不区分大小写，双引号可强制区分）。
    - 若未用双引号，Oracle 会自动将标识符转为大写（如 `empno` 等价于 `EMPNO`）。
    - 用双引号时，严格区分大小写（如 `"empno"` 和 `"EmpNo"` 是不同的列名）。
- 包含特殊字符（如空格、关键字）的标识符。

```sql
-- 情况1：区分大小写的列别名
SELECT empno AS "EmpNo" FROM emp;  
-- 结果集中列名为 "EmpNo"（保留大小写）

-- 情况2：包含特殊字符的列名
CREATE TABLE t (
    "column with space" VARCHAR2(10)  -- 列名含空格，必须用双引号
);
```

**变量符和变量符 2**

| **对比项**       | **VARCHAR**                                   | **VARCHAR2**                                        |
| ---------------- | --------------------------------------------- | --------------------------------------------------- |
| **空字符串处理** | 可能存空字符串（行为未严格定义）              | 把空字符串等同于 `NULL` 处理                        |
| **未来兼容性**   | Oracle 标记为 “不建议使用”                    | Oracle 承诺永久支持                                 |
| **实际使用**     | 极少用，仅为兼容保留                          | Oracle 首选的可变长字符串类型                       |
| **本质设计**     | 属于标准 SQL 类型，但 Oracle 中未完全遵循标准 | 是 Oracle 对 `VARCHAR` 的增强替代，专为 Oracle 优化 |



WITH 子句

`WITH` 子句（也称为 **公共表表达式**，简称 CTE）

将结果集临时命名，以

提高查询可读性、简化复杂查询

允许在同一查询中多次引用

实现递归查询







这个命名仅在查询执行期间存在

```sql
模型

WITH cte_name () AS (
	-- 子查询逻辑
)
主查询，引用CTE;
```



```sql
-- 单CTE
WITH cte_name (column1, column2, ...) AS (
    -- 子查询逻辑
    SELECT ...
)
-- 主查询引用 CTE
SELECT * FROM cte_name;



-- 实例
WITH dept_avg AS (
    SELECT AVG(sal) AS avg_sal
    FROM emp
)
SELECT e.ename, e.sal
FROM emp e, dept_avg
WHERE e.sal > dept_avg.avg_sal;

```



```sql
-- 多CTE
WITH 
dept_avg AS (SELECT AVG(sal) AS avg_sal FROM emp),	-- 多个CTE间逗号分隔
dept_max AS (SELECT MAX(sal) AS max_sal FROM emp)
SELECT e.ename, e.sal
FROM emp e, dept_avg, dept_max
WHERE e.sal > dept_avg.avg_sal * 2;  -- 工资超过平均2倍



```



```sql
-- 递归CTE


-- 模型
-- RECURSIVE 递归的
WITH RECURSIVE cte_name (column1, column2, ...) AS (
    -- 初始查询（锚成员）：定义递归起点
    SELECT ...
    WHERE ...
    
    UNION ALL
    
    -- 递归查询（递归成员）：引用 CTE 自身
    SELECT ...
    FROM cte_name
    WHERE ...
)
-- 主查询：使用递归生成的结果集
SELECT * FROM cte_name;





-- 实例
--- 查询员工层级关系
WITH RECURSIVE emp_hierarchy AS (
    SELECT empno, ename, mgr, 1 AS level
    FROM emp
    WHERE mgr IS NULL  -- 先找到顶层CEO，并规定ta的层级为1
    
    UNION ALL -- 合并结果集
    
    SELECT e.empno, e.ename, e.mgr, eh.level + 1
    FROM emp e
    JOIN emp_hierarchy eh ON e.mgr = eh.empno  -- 递归连接
)
SELECT LPAD(' ', (level-1)*2) || ename AS employee_tree
FROM emp_hierarchy;
```



实际生产环境中更推荐使用 **`CONNECT BY` 语法**，因为它针对层级查询做了优化：

```sql
-- 等价于上述组织架构查询的 CONNECT BY 写法
SELECT 
    LPAD(' ', (LEVEL-1)*2) || ename AS employee_tree,
    LEVEL,
    SYS_CONNECT_BY_PATH(ename, ' > ') AS path
FROM emp
START WITH mgr IS NULL  -- 起始条件
CONNECT BY PRIOR empno = mgr  -- 父子关系
ORDER SIBLINGS BY ename;  -- 同级排序
```

性能考虑

- **索引优化**：递归连接的字段（如 `mgr`、`parent_id`）必须有索引，否则会导致全表扫描。
- **结果集大小**：层级过深会导致性能下降，建议通过 `WHERE level <= N` 限制深度。
- **替代方案**：对于静态层级数据，可预计算并存储路径信息（如使用 `PATH` 字段），避免实时递归。



| **特性**   | **CTE**                  | **子查询**   | **视图**             |
| ---------- | ------------------------ | ------------ | -------------------- |
| **命名**   | 有（`cte_name`）         | 无           | 有（存储在数据库中） |
| **作用域** | 当前查询                 | 仅所在子句   | 全局可用             |
| **复用性** | 可在同一查询中多次引用   | 需重复编写   | 可被多个查询引用     |
| **性能**   | 可能优化（避免重复计算） | 可能重复计算 | 与直接查询表类似     |
| **持久化** | 临时（查询结束即消失）   | 临时         | 永久（需手动删除）   |













控制结构

循环

```plsql
-- 1. 基本 LOOP
LOOP
  v_counter := v_counter + 1;
  EXIT WHEN v_counter > 10;
END LOOP;

-- 2. WHILE 循环
WHILE v_counter <= 10 LOOP
  v_counter := v_counter + 1;
END LOOP;

-- 3. FOR 循环
FOR i IN 1..10 LOOP
  DBMS_OUTPUT.PUT_LINE('迭代: ' || i);
END LOOP;
```

判断

```plsql
IF v_salary > 10000 THEN
  DBMS_OUTPUT.PUT_LINE('高薪');
ELSIF v_salary > 5000 THEN
  DBMS_OUTPUT.PUT_LINE('中等');
ELSE
  DBMS_OUTPUT.PUT_LINE('低薪');
END IF;
```

游标

过程化 SQL 中如果 结果集 返回 ＞1 条语句，用游标处理

它类似迭代器，逐行遍历结果集并对每行数据都做特定处理

声明》打开》使用》关闭

分显式隐式（区别是是否手动），其下又有不同

显式

```plsql
DECLARE
  -- 声明游标（定义查询语句）
  CURSOR cursor_name [(parameter_list)] IS
    SELECT_statement;
  
  -- 声明变量存储游标数据
  variable1 datatype;
  variable2 datatype;
BEGIN
  -- 打开游标（执行查询）
  OPEN cursor_name[(parameter_values)];
  
  -- 循环获取数据
  LOOP
    FETCH cursor_name INTO variable1, variable2;  -- 提取数据到变量
    EXIT WHEN cursor_name%NOTFOUND;  -- 无数据时退出循环
    -- 处理数据（如打印或更新）
  END LOOP;
  
  -- 关闭游标（释放资源）
  CLOSE cursor_name;
END;
```

| 属性        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| `%FOUND`    | 布尔值，上次 `FETCH` 成功返回数据时为 `TRUE`。               |
| `%NOTFOUND` | 与 `%FOUND` 相反，无数据时为 `TRUE`。                        |
| `%ROWCOUNT` | 已获取的行数（从 1 开始计数）。                              |
| `%ISOPEN`   | 布尔值，游标是否打开（`OPEN` 后为 `TRUE`，`CLOSE` 后为 `FALSE`）。 |

显式带参数

```plsql
DECLARE
  CURSOR c_emp(p_deptno NUMBER) IS
    SELECT ename, sal FROM emp WHERE deptno = p_deptno;
  v_ename VARCHAR2(20);
  v_sal   NUMBER;
BEGIN
  OPEN c_emp(10);  -- 传递参数
  LOOP
    FETCH c_emp INTO v_ename, v_sal;
    EXIT WHEN c_emp%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_ename || ': ' || v_sal);
  END LOOP;
  CLOSE c_emp;
END;
```





隐式

```plsql
DECLARE
  v_ename VARCHAR2(20);
BEGIN
  -- 直接执行查询，无需显式声明游标
  SELECT ename INTO v_ename FROM emp WHERE empno = 7369;
  
  -- 使用隐式游标属性（如 SQL%ROWCOUNT）
  IF SQL%FOUND THEN
    DBMS_OUTPUT.PUT_LINE('找到员工: ' || v_ename);
  END IF;
END;
```



隐式游标属性（`SQL%XXX`）

| 属性         | 描述                                                  |
| ------------ | ----------------------------------------------------- |
| SQL%FOUND    | `SELECT` 成功返回一行或 `DML` 影响至少一行时为 `TRUE` |
| SQL%NOTFOUND | 与 `SQL%FOUND` 相反                                   |
| SQL%ROWCOUNT | `DML` 语句影响的行数（如 `UPDATE` 修改的行数）        |
| SQL%ISOPEN   | 隐式游标执行后立即关闭，始终为 `FALSE`                |

 DML 语句中的隐式游标

```plsql
BEGIN
  UPDATE emp SET sal = sal * 1.1 WHERE deptno = 10;
  
  IF SQL%ROWCOUNT > 0 THEN
    DBMS_OUTPUT.PUT_LINE('成功更新 ' || SQL%ROWCOUNT || ' 条记录');
    COMMIT;
  ELSE
    DBMS_OUTPUT.PUT_LINE('无记录更新');
  END IF;
END;
```

游标 FOR 循环（简化显式游标的写法）

```plsql
FOR record_name IN cursor_name [(parameter_values)] LOOP
  -- 直接使用 record_name.列名 访问数据，无需 OPEN/FETCH/CLOSE
END LOOP;
```

实例

```plsql
DECLARE
  CURSOR c_emp IS
    SELECT ename, sal FROM emp WHERE deptno = 10;
BEGIN
  FOR emp_rec IN c_emp LOOP
    DBMS_OUTPUT.PUT_LINE('姓名: ' || emp_rec.ename || ', 薪资: ' || emp_rec.sal);
  END LOOP;
END;
```

直接在 FOR 循环中定义查询（无需显式声明游标）

```plsql
BEGIN
  FOR emp_rec IN (SELECT ename, sal FROM emp WHERE deptno = 10) LOOP
    DBMS_OUTPUT.PUT_LINE(emp_rec.ename);
  END LOOP;
END;
```





REF 游标（动态游标，运行时确定查询）

强类型 REF 游标

```plsql
DECLARE
  TYPE emp_cursor_type IS REF CURSOR RETURN emp%ROWTYPE;  -- 强类型（指定返回类型）
  v_emp_cursor emp_cursor_type;
  v_emp_rec    emp%ROWTYPE;
BEGIN
  OPEN v_emp_cursor FOR SELECT * FROM emp WHERE deptno = 10;
  
  LOOP
    FETCH v_emp_cursor INTO v_emp_rec;
    EXIT WHEN v_emp_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_emp_rec.ename);
  END LOOP;
  
  CLOSE v_emp_cursor;
END;
```

弱类型 REF 游标

```plsql
DECLARE
  TYPE generic_cursor_type IS REF CURSOR;  -- 弱类型（不指定返回类型）
  v_cursor  generic_cursor_type;
  v_empno   NUMBER;
  v_ename   VARCHAR2(20);
BEGIN
  OPEN v_cursor FOR SELECT empno, ename FROM emp WHERE deptno = 20;
  
  LOOP
    FETCH v_cursor INTO v_empno, v_ename;
    EXIT WHEN v_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_empno || ': ' || v_ename);
  END LOOP;
  
  CLOSE v_cursor;
END;
```

游标与异常处理

```plsql
DECLARE
  CURSOR c_emp IS
    SELECT ename FROM emp WHERE deptno = 99;  -- 假设部门99不存在
  v_ename VARCHAR2(20);
BEGIN
  OPEN c_emp;
  FETCH c_emp INTO v_ename;
  
  IF c_emp%NOTFOUND THEN
    DBMS_OUTPUT.PUT_LINE('未找到数据');
  END IF;
  
  CLOSE c_emp;
  
EXCEPTION
  WHEN OTHERS THEN
    IF c_emp%ISOPEN THEN  -- 异常时检查游标是否打开，避免资源泄漏
      CLOSE c_emp;
    END IF;
    RAISE;  -- 重新抛出异常
END;
```

适用场景与性能建议

| 场景               | 推荐游标类型  | 示例                                 |
| ------------------ | ------------- | ------------------------------------ |
| 简单遍历查询结果   | 游标 FOR 循环 | `FOR emp_rec IN (SELECT * FROM emp)` |
| 需动态控制提取过程 | 显式游标      | `FETCH` 后处理逻辑，如条件判断       |
| 运行时确定查询语句 | REF 游标      | 根据参数执行不同查询                 |
| 单条记录查询       | 隐式游标      | `SELECT ... INTO ...`                |







### 存储 过程/函数

过程化 SQL 程序保留复用是存储

必须有返回值的是函数否则是过程



存储过程

```sql
					-- 程序
CREATE OR REPLACE PROCEDURE 存储过程名(
    参数名 [IN|OUT|INOUT] 数据类型, 		
    参数名 [IN|OUT|INOUT] 数据类型 DEFAULT x  -- 默认参数
) AS
	局部变量 变量数据类型;

	/* 局部变量命名
        v_：局部变量（如 v_sal）
        p_：参数（如 p_empno）
        l_：包级变量
        g_：全局变量
	*/

BEGIN
  操作
  -- 操作中包含将结果赋予局部变量的操作

  -- 异常处理
  exception
  when NO_DATA_FOUND then
 	/*
 		系统包打印语句
 		|| 连接字符串，非字符串会被转为字符串
 	*/
    DBMS_OUTPUT.PUT_LINE('xxx');
  when TOO_MANY_ROWS then
    DBMS_OUTPUT.PUT_LINE('xxx');
    ？？异常类型有哪些？

END;
/ -- 普通 SQL 语句用分号（;）结束，但 PL/SQL 块需要专用的终止符/


-- 启用输出
SET SERVEROUTPUT ON;

-- 调试
exec 过程名(参数);
/*
	调试等价于
	BEGIN
	  get_emp_sal(7369);  -- 存储过程调用
	END;
*/
```



```sql
create or replace procedure get_emp_sal(
  p_empno in number
) as 
  v_sal number;
BEGIN
  select sal into v_sal from emp where empno = p_empno;
  DBMS_OUTPUT.PUT_LINE('工资 : ' || v_sal);
  
exception
  when NO_DATA_FOUND then
    DBMS_OUTPUT.PUT_LINE('错误：员工编号不存在');
  when TOO_MANY_ROWS then
    DBMS_OUTPUT.PUT_LINE('错误：查询返回多行结果');
end;
/-- 这部分和我的测试结合在一起

[IN|OUT|INOUT] 是参数传递模式,用于定义参数方向和行为

-- IN是默认的
-- IN向存储过程传递值，在过程内部可读取但不可修改。
CREATE OR REPLACE PROCEDURE get_emp_salary(
  p_empno IN NUMBER  -- 输入员工编号
) AS
  
  -- AS 和 BEGIN 之间的这部分是变量声明区域
  v_salary NUMBER;	-- 局部变量用于临时存储查询结果，将查询结果存储到局部变量的操作在BEGIN END这一部分，通过INTO。
	
BEGIN
  SELECT sal INTO v_salary FROM emp WHERE empno = p_empno;
  DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);
END;
-- 调试方法
EXEC get_emp_salary(7369);  -- 传入员工编号




-- OUT从存储过程返回值，必须在过程内部赋值，调用前无需传入值。
参数名 OUT 数据类型
CREATE OR REPLACE PROCEDURE get_emp_info(
  p_empno IN NUMBER,     -- 输入：员工编号
  p_ename OUT VARCHAR2,  -- 输出：员工姓名
  p_sal OUT NUMBER       -- 输出：员工工资
) AS
BEGIN
  SELECT ename, sal INTO p_ename, p_sal FROM emp WHERE empno = p_empno;
END;
-- 调试方法
DECLARE
  v_name VARCHAR2(50);
  v_sal NUMBER;
BEGIN
  get_emp_info(7369, v_name, v_sal);  -- 输出参数通过变量接收
  DBMS_OUTPUT.PUT_LINE('Name: ' || v_name || ', Salary: ' || v_sal);
END;



-- INOUT 可输入可输出，像OUT一样返回值
参数名 INOUT 数据类型

CREATE OR REPLACE PROCEDURE increase_salary(
  p_empno IN NUMBER,        -- 输入：员工编号
  p_salary INOUT NUMBER     -- 输入输出：初始工资，返回增加后的工资
) AS
  v_increase_rate NUMBER := 0.1;  -- 加薪10%
BEGIN
  p_salary := p_salary * (1 + v_increase_rate);
END;
-- 调试方法
DECLARE
  v_salary NUMBER := 5000;  -- 初始工资
BEGIN
  increase_salary(7369, v_salary);  -- 传入初始值，返回修改后的值
  DBMS_OUTPUT.PUT_LINE('New Salary: ' || v_salary);  -- 输出：5500
END;





OUT 和 INOUT 参数的数据类型必须明确（如 VARCHAR2(50)），不能使用 %TYPE 或 %ROWTYPE
OUT 和 INOUT 参数必须在过程内部至少赋值一次，否则会报错。
IN 参数通过值传递，适合小数据量; OUT 和 INOUT 通过引用传递，适合大数据量。





CREATE OR REPLACE PROCEDURE format_phone(
  p_phone INOUT VARCHAR2  -- 例如：传入 '1234567890'，返回 '(123) 456-7890'
) AS
BEGIN
  p_phone := '(' || SUBSTR(p_phone, 1, 3) || ') ' || SUBSTR(p_phone, 4, 3) || '-' || SUBSTR(p_phone, 7);
END;
```



我的测试

```plsql
CREATE OR REPLACE PROCEDURE increase_salary(
  p_empno IN NUMBER,
  p_percent IN NUMBER DEFAULT 5  -- 默认参数
) AS
BEGIN
  UPDATE emp
  SET sal = sal * (1 + p_percent/100)
  WHERE empno = p_empno;
  
  COMMIT;
END;
/

-- 调用存储过程
EXEC increase_salary(7369, 10);  -- 加薪10%
```



存储函数

```sql
CREATE OR REPLACE FUNCTION 函数名(
  参数名 [IN|OUT|INOUT] 数据类型,
  参数名 [IN|OUT|INOUT] 数据类型 DEFAULT x  -- 默认参数
) RETURN 类型 AS
 过程化SQL

CALL/SELECT 函数名（参数数据类型，参数数据类型）；
```

我的测试

```plsql
CREATE OR REPLACE FUNCTION get_avg_salary(
  p_deptno IN NUMBER
) RETURN NUMBER AS
  v_avg_sal NUMBER;
BEGIN
  SELECT AVG(sal) INTO v_avg_sal FROM emp WHERE deptno = p_deptno;
  RETURN v_avg_sal;
END;
/

-- 调用函数
DECLARE
  v_result NUMBER;
BEGIN
  v_result := get_avg_salary(10);
  DBMS_OUTPUT.PUT_LINE('部门10平均工资: ' || v_result);
END;
```

修改和删除过程

```sql
ALTER PROCUDURE 过程名 RENAME TO 过程名；
ALTER PROCUDURE 过程名 COMPILE； --重编译
DROP PROCUDURE 过程名;
```

修改和删除函数

```sql
ALTER FUNCTION 过程名 RENAME TO 过程名；
ALTER FUNCTION 过程名 COMPILE； --重编译
DROP FUNCTION 过程名;
```

 

异常处理

```plsql
DECLARE
  v_empno NUMBER := 9999;
  v_ename VARCHAR2(20);
BEGIN
  SELECT ename INTO v_ename FROM emp WHERE empno = v_empno;
  
EXCEPTION
  WHEN NO_DATA_FOUND THEN  -- 预定义异常
    DBMS_OUTPUT.PUT_LINE('员工不存在');
  WHEN TOO_MANY_ROWS THEN  -- 预定义异常
    DBMS_OUTPUT.PUT_LINE('查询返回多行');
  WHEN OTHERS THEN         -- 其他异常
    DBMS_OUTPUT.PUT_LINE('错误代码: ' || SQLCODE);
    DBMS_OUTPUT.PUT_LINE('错误信息: ' || SQLERRM);
END;
```

包

封装在一起的过程、变量、函数

```plsql
-- 包规范
CREATE OR REPLACE PACKAGE emp_package AS
  FUNCTION get_emp_count(p_deptno NUMBER) RETURN NUMBER;
  PROCEDURE print_emp_info(p_empno NUMBER);
END;
/

-- 包体
CREATE OR REPLACE PACKAGE BODY emp_package AS
  FUNCTION get_emp_count(p_deptno NUMBER) RETURN NUMBER AS
    v_count NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_count FROM emp WHERE deptno = p_deptno;
    RETURN v_count;
  END;
  
  PROCEDURE print_emp_info(p_empno NUMBER) AS
    v_ename VARCHAR2(20);
  BEGIN
    SELECT ename INTO v_ename FROM emp WHERE empno = p_empno;
    DBMS_OUTPUT.PUT_LINE('员工姓名: ' || v_ename);
  END;
END;
/

-- 调用包中的函数
SELECT emp_package.get_emp_count(10) FROM DUAL;
```

避免在 PL/SQL 中使用逐行处理（Row-By-Row），尽量用集合操作（SQL 批量处理）

















# 高级语言实现数据库复杂应用

用户和数据库通过界面进行交互

对开发人员更方便，对使用人员没必要展示交互过程



交互方式

**动态链接库**

基于分布式系统的思想，大系统分为小系统，数据库作为其中 1 个小系统，由应用系统通过 **动态链接库** 访问



**嵌入**

将 SQL 嵌入高级语言，关系型数据库管理系统一般通过预编译方式，处理从源码中识别出来的 SQL 语句，然后转换为 SQL 调用语句，这个调用语句对宿主语言来说是对库函数的调用，将嵌入 SQL 看作宿主语言的库函数

因为有这个过程，直接在宿主语言里写 SQL 语句就行，反正能识别

以 C 为例

声明

```c
EXEC SQL BEGIN DECLARE SECTION;  // 主变量声明开始
int emp_no;
char emp_name[20];
EXEC SQL END DECLARE SECTION;    // 主变量声明结束
```

连接数据库

```c
EXEC SQL CONNECT TO db_name USER 'username' IDENTIFIED BY 'password';
```

执行查询（单记录）

```c
EXEC SQL SELECT ename INTO :emp_name FROM emp WHERE empno = :emp_no;

-- 冒号是为了将变量与数据库对象名区分
    
if (SQLCODE != 0) {  // SQLCODE为预定义变量，0表示成功
  printf("查询失败: %d", SQLCODE);
} else {
  printf("员工姓名: %s", emp_name);
}
```

更新

```c
EXEC SQL UPDATE emp SET sal = sal * 1.1 WHERE empno = :emp_no;
EXEC SQL COMMIT;  // 提交事务
```

满足了高效访问数据库的过程



**基于 ODBC/JDBC 的中间件**

避免因不同关系型数据库的差异导致移植性差

以 windows 为例，软件支持平台将  软件  看作设备，厂商提供驱动，以设备方式使用软件





































































## 数据库优化

[最强总结！数据库优化完全指南！！-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2469014)























































