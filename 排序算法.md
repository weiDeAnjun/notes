# 排序算法



## 插入排序

### 直接插入排序

直接插入排序以 乱序列的首元素为基准，每次遍历序列，$余下元素都与该首元素比较以确定自己是否挪动位置$

```java
public static int[] sortArr(int[] arr) {

		for (int i = 1; i < arr.length; ++i) {

			int keyVal = arr[i];
			int j = i - 1;
			while (j >= 0 && arr[j] < keyVal) {

				arr[j + 1] = arr[j];
				--j;
			}
			arr[j + 1] = keyVal;

		}

		return arr;
    
```





### 折半插入排序

```java
	public static int[] binaryInsertionSort(int[] arr) {

		int len = arr.length;

		for (int i = 1; i < len; ++i) {

			int keyVal = arr[i];
			int low = 0;
			int high = i - 1;

			// 折半查找合适插入范围
			while (low <= high) {

				int mid = (low + high) >> 1;
				if (arr[mid] > keyVal)
					high = mid - 1;
				else
					low = mid + 1;
			}

			// 插入数值，需要挪动其它元素腾位置
			for (int j = i; j >= low; --j) {
				arr[j] = arr[j - 1];
			}
			arr[low] = keyVal;

		}

		return arr;
	}
```



### 希尔排序

```java
public static void shellSort(int[] arr) {

		// gap随便，这里为了方便和长度捆绑
		for (int gap = arr.length >> 1; gap > 0; gap >>= 1) {

			for (int i = gap; i < arr.length; ++i) {

				int keyVal = arr[i];
				int j = i;

				for (; j >= gap && arr[j - gap] > keyVal; j -= gap) {
					arr[j] = arr[j - gap];
				}
				arr[j] = keyVal;
			}

		}

	}
```



## 交换排序







### 冒泡排序

```java
public static void bubbleSort(int[] arr) {

		for (int i = 0; i < arr.length - 1; i++) {
			// 标记是否在本轮遍历中发生了交换，若未发生交换则说明数组已经有序，可提前结束排序
			boolean swapped = false;
			for (int j = 0; j < arr.length - 1 - i; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
					swapped = true;
				}
			}
			// 如果本轮没有发生交换，直接跳出外层循环，结束排序
			if (!swapped) {
				break;
			}
		}
	}

```



### 快速排序

```java
	public static void main(String[] args) {

		int[] arr = { 1, 12, 33, 6, 9, 54, 10, 60, 888 };

		int len = arr.length;
		int left = 0;
		int right = len - 1;

		quickSort(arr, left, right);

		for (int i : arr) {
			System.out.println(i + " ");
		}

	}

	public static int[] quickSort(int[] arr, int left, int right) {

		int partitionindex = 0;

		if (left < right) {
			partitionindex = partition(arr, left, right);
			quickSort(arr, left, partitionindex - 1);
			quickSort(arr, partitionindex + 1, right);
		}

		return arr;

	}

	public static int partition(int[] arr, int left, int right) {
		int pivot = arr[left];
		int index = left + 1;
		for (int i = left + 1; i <= right; ++i) {
			if (arr[i] < pivot) {
				swap(arr, i, index);
				index++;
			}
		}
		swap(arr, left, index - 1);
		return index - 1;
	}

	public static void swap(int[] arr, int i, int j) {

		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;

	}
```

