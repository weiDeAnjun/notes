# 前奏

设计模式是模型(解决问题的方案)

目前有4大类

| 序号 | 模式 & 描述                                                  | ***\*包括\****                                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | ***\*创建型模式\**** 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 | · 工厂模式（Factory Pattern）· 抽象工厂模式（Abstract Factory Pattern）· 单例模式（Singleton Pattern）· 建造者模式（Builder Pattern）· 原型模式（Prototype Pattern） |
| 2    | ***\*结构型模式\**** 这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。 | · 适配器模式（Adapter Pattern）· 桥接模式（Bridge Pattern）· 过滤器模式（Filter、Criteria Pattern）· 组合模式（Composite Pattern）· 装饰器模式（Decorator Pattern）· 外观模式（Facade Pattern）· 享元模式（Flyweight Pattern）· 代理模式（Proxy Pattern） |
| 3    | ***\*行为型模式\**** 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。 | · 责任链模式（Chain of Responsibility Pattern）· 命令模式（Command Pattern）· 解释器模式（Interpreter Pattern）· 迭代器模式（Iterator Pattern）· 中介者模式（Mediator Pattern）· 备忘录模式（Memento Pattern）· 观察者模式（Observer Pattern）· 状态模式（State Pattern）· 空对象模式（Null Object Pattern）· 策略模式（Strategy Pattern）· 模板模式（Template Pattern）· 访问者模式（Visitor Pattern） |
| 4    | ***\*J2EE 模式\**** 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 | · MVC 模式（MVC Pattern）· 业务代表模式（Business Delegate Pattern）· 组合实体模式（Composite Entity Pattern）· 数据访问对象模式（Data Access Object Pattern）· 前端控制器模式（Front Controller Pattern）· 拦截过滤器模式（Intercepting Filter Pattern）· 服务定位器模式（Service Locator Pattern）· 传输对象模式（Transfer Object Pattern） |

 这么多，但常用只有23种

 

![img](D:\01\技术\感获\md文档\设计模式.assets\wps3735.tmp.jpg) 

 



掌握设计模式，要对一些基本概念熟知：

**接口**

它就像是“规范”或者“协议”，定义了一组方法的**名称和参数格式**，但并不去实现这些方法的具体逻辑。我们可以把接口理解成是一种“承诺”——谁实现了这个接口，谁就必须按照接口定义的方法去完成逻辑。

在 Java 中，接口的作用主要有两个：

- **规范约束**：统一各个实现类的行为标准。
- **解耦合设计**：程序可以依赖接口而不是具体实现，这对于后期扩展和维护是非常重要的。

从 Java 8 开始，接口还可以带有默认方法（`default`）和静态方法，甚至可以有私有方法，但它们仍不能有实例变量，也不能有构造方法，接口本质上还是以“行为定义”为主。



**抽象类**

抽象类更像是“半成品”或者“骨架”，已经包含了一些默认的行为实现，还预留了部分抽象方法交给子类实现，让子类去继承并补全细节

抽象类有几个特点：

- 可以有普通成员变量和方法。
- 可以有构造函数。
- 可以包含抽象方法（用 `abstract` 关键字标识）。
- 不能被直接实例化。

抽象类和接口最大的不同是抽象类是类，有字段，属性



类存在父子关系，且父类提供默认实现，抽象类更好

制定规范，接口更好



**多态**

多态，指的是**同一操作作用于不同对象时，可以表现出不同的行为**。

多态有三种形式：

1. **方法重载（Overload）**：同一个类中方法名相同，参数不同。
2. **方法重写（Override）**：子类重新定义父类的方法。
3. **父类引用指向子类对象**：这是实际使用多态的常见场景。



这为设计模式中的很多“可扩展”“可替换”行为打下了基础。



**继承**

它允许我们创建一个类，并“复用”另一个类的代码。

继承有两个主要用途：

- **代码复用**：父类写好了通用逻辑，子类可以直接使用。
- **构建层次结构**：通过继承构建出清晰的类型体系。

 



# 设计模式的六大原则

## 单一职责原则

一个类，只干一件事。

一个类只负责一个功能模块上的事情。如果一个类同时负责业务逻辑、数据库访问、日志处理等多种职责，那么一旦某个职责发生变化，就有可能影响到整个类的稳定性。



比如装饰器模式、职责链模式，其实都是在帮我们把复杂职责拆分开，控制类的粒度



## 开闭原则

对扩展开放，对修改关闭。

当我们新增功能时，应该通过“新增代码”的方式来实现，而不是去修改已有的类或方法。这样做的好处是，原来的功能不会被影响，风险小；新功能也能保持独立，维护方便。



比如策略模式、工厂模式、本质上都是在帮助我们在已有体系上“平滑加功能”。





## 里氏替换原则

子类对象必须能够替换掉父类对象，并保持原有功能不变。

通俗点说，继承关系不能乱用。继承不是为了代码复用，而是为了“**保持通用的行为**”。如果子类违背了父类的行为约定，那就会出现一些难以察觉的 bug。

里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。



像模板方法模式、桥接模式这些，都很强调父子类之间的替换关系。



## 依赖倒置原则

高层模块不应该依赖低层模块，两者都应该依赖抽象。

我们应该“面向接口编程”，而不是直接依赖某个具体的类。

比方说，一个支付系统，业务逻辑层不要直接依赖“微信支付”或“支付宝支付”的实现类，而应该依赖一个 `Payment` 接口。这样我们就可以灵活地切换实现方式，而不会动到业务逻辑的代码。

像工厂模式、策略模式、依赖注入的思想，基本都是围绕这个原则展开的。



## 接口隔离原则

接口要小而精，不要大而全。

接口一旦设计成“全能型”，实现起来就容易出现“我不需要这个方法但也要实现它”的情况。这样不仅多余，还容易让接口的维护变得困难。

比如我们在系统中定义了 `UserService` 接口，如果这个接口又要注册用户、又要导出报表、还要批量删除，很多实现类就会出现强行实现的尴尬场面。

它强调降低依赖，降低耦合。

像组合模式、适配器模式这些，往往就是在帮助我们更好地隔离接口、解耦功能。

## 迪米特法则(最少知道原则)

只和直接相关的类交流，尽量减少对外部对象内部细节的依赖。

也叫“最少知道原则”，就是说一个类应该尽量只关注自己的直接朋友，不要对别人家的细节过于熟悉。这样可以减少耦合，提高模块的独立性。

典型的例子就是外观模式，它通过提供统一入口，让调用者不需要接触系统内部的各种细节类。



比如，我不直接new引用，而是通过方法获取引用，但有很多方法，它们实现不同功能后组合返回，这样的话我就需要调用很多方法，这就是过于关注内部细节，我可以再写一个方法，把所有方法调用封装到这里面，我只调用这个方法就可以了



虽说有6个，但众口不一，所以我还是写上了

**7、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。





# 设计模式的分类

从设计模式的大类上来看，设计模式共分成三种类型：

1. 创建型模式（Creational Patterns）：主要关注“对象怎么创建”，比如单例、工厂、建造者。
2. 结构型模式（Structural Patterns）：主要处理“类与类、对象与对象之间如何组合”，比如适配器、桥接、装饰器。
3. 行为型模式（Behavioral Patterns）：关注“对象之间如何协作和通信”，比如观察者、状态、策略

![img](D:\01\技术\感获\md文档\设计模式.assets\SFXJtPi0ts2zBJBU.webp)

**不要过度依赖设计模式！！！！！！** 它并不是银弹(彻底解决某个复杂问题的简单方法)，过分使用设计模式可能只会增加系统的复杂度。

它们好用，但不是任何时候都应该用，在不恰当时机使用也会有问题



2025年8月12日，底部我还没看

[保姆级 23 种设计模式教程 - 编程导航教程 - 做您编程学习路上的导航员](https://www.codefather.cn/course/1930517607799193602?type=)

![image-20250812085312803](D:\01\技术\感获\md文档\设计模式.assets\image-20250812085312803.png)





# -----------------



# 创建型模式

## 单例模式

单例模式核心是单例，保证全局就这么1个

同时单例模式有饿汉懒汉2种



如何保证单例？那就是一开始创建1个，之后不再允许创建

做到这些，我就要保证创建方法不被获取（private），但这样只是不被外部获取，如果在内部的话，还是可以new引用，那我就做到无论怎么new，怎么引用，获取的都是那个最初创建好的（static）

这样的话



饿汉式和懒汉式区别是前者无论我是否使用都会创建对象，后者只有使用时才会创建

```java
// 饿汉式
class Person{

    private String name;
    private static Person person = new Person();	//唯一实例对象

    private Person() {	// 构造方法私有化

    }

    public static Person getInstance(){// 对外接口
        return person;
    }

}
```

```java
// 基础懒汉式

public class Main {

    public static void main(String[] args)  {

    }

    public static class Person{

        private String name;
        private static Person person;

        private Person() {

        }

        public static Person getInstance(){
            if(person == null){
                person = new Person();
            }
            return person;
        }

    }
}
```



**在线程方面**

- 饿汉式实例在类加载阶段由 JVM 的**类加载器机制**保证初始化的原子性（同一类加载过程中，静态变量初始化只会执行一次），无论多少线程调用`getInstance()`，获取的都是已经初始化完成的实例，不存在 “多线程同时创建多个实例” 的风险。
- 懒汉式由于存在多次通过 if(person == null)的情况，可能导致创建多个实例

为此，优化懒汉式

```java
class Person {
    // volatile 防止指令重排序导致的"半初始化"问题
    private static volatile Person person = null;

    private Person() {
    }

    public static Person getInstance(){
        if(person == null){
            //因为是static修饰的对象，类.class唯一
            synchronized (Person.class){
                if(person == null){
                    person = new Person();
                }
            }
        }
        return person;
    }
}
```







## 工厂模式

我把现实中工厂相关概念和设计模式中“工厂”联系起来便于理解

模板、批量、生产线

生产出来的东西虽然各不相同，但根本功能是一样的，就以日志系统为例，虽然有错误日志，数据库日志、控制台日志记录不同的内容，但本质都是记录，这就像模板，奠定基调

工程是为了高效批量的制作物品，这里就是高效便捷生成对象

通过工厂创建错误日志、操作日志的对象，这些不同的对象就是来自不同生产线的物品



我通过工程模式创建是为了使用，对于我这个消费者，不需要关心物品是怎么生产出来，所以工厂模式无需关心具体创建过程



**使用工厂模式是为了以  解耦对象创建和使用  的方式 创建对象，提升代码的可维护性、可扩展性和灵活性**





有无使用工厂模式对比

```java
//直接创建不同类型日志记录器
class Logger {
    private String type;

    public Logger(String type) {
        this.type = type;
    }

    public void log(String message) {
        if (type.equald("database")) {
            System.out.println("message");
        } else if (type.equals("console")) {
            System.out.println("message");
        }
    }
}
//引用对象和创建对象的内容混合在一起，若修改，就要牵扯大量修改
```



```java
//使用工厂

	//抽象产品
interface Logger{
    public void log(String msg);
}
	//抽象工厂
interface LoggerFactory{
    Logger getLogger();
}
	//具体产品
class FileLogger implements Logger{
    @Override
    public void log(String msg){
        System.out.println(msg);
    }
}
	//具体工厂
class FileLoggerFactory implements LoggerFactory{
    @Override
    public Logger getLogger(){
        return new FileLogger();
    }
}

//具体产品、工厂各自继承于抽象产品工厂
//工厂创建产品

// 调用
    public static void main(String[] args) throws Exception {
        FileLoggerFactory flf = new FileLoggerFactory();
        // 调用时用抽象（/父类）调用，这样才能接纳各种子类，实现替换
        Logger fl = flf.getLogger();
        fl.log("hello");
    }
```



通过对比可以看出，不使用工厂方法模式时，通过条件判断来处理不同类型的日志记录，无论哪种类型都在同一代码结构中创建，代码耦合度高、职责不单一，后续修改还违反开闭原则等

使用工厂方法模式后，؜**对象的创建与使用分离**，没有上述缺点

需创建新的工厂类⁢，通‏过工厂接口封装了具体日志记录器的创建细节，这个问题是类如果很多，显得臃肿

典型的应用场景：

- 消息通知系统：系统支持短信、邮件、站内信等不同通知方式时，可通过工厂方法屏蔽创建细节，让调用方只负责发消息。
- 支付系统：用户可能选择支付宝、微信、银行卡等支付方式，工厂方法可以根据用户选择生成对应的支付通道对象，方便扩展新方式。
- 文件解析模块：上传的文件可能是 Excel、CSV、JSON、XML 等不同格式，工厂方法可以根据文件类型创建对应的解析器实例，统一解析入口。
- 业务规则引擎：当一个系统支持多个业务规则版本（如不同行业、不同客户），可以通过工厂方法创建对应的规则计算器，灵活支持定制化逻辑。





**通过让子类决定实例化哪个具体类**，从而实现了对象创建的灵活性和可扩展性

↓

抽象工厂只规定 “要创建一个产品”，但不指定具体是哪个产品（比如只说 “造个交通工具”，不说造汽车还是自行车）
具体工厂（抽象工厂的子类）则负责 “决定” 并 “实现” 具体创建哪种产品：汽车工厂造汽车，自行车工厂造自行车





#### 工厂方法模式的基本结构

工厂方法模式具有的角色和职责：tixvTheYGXxejp+louUqtnhSzCkcqYGh80mlhbQvU6Q=

1）抽象产؜品（Product﻿）：定义产品的公共⁢接口，是所有具体产品‏的父类。

2）具体产؜品（Concret﻿eProduct）⁢：实现了抽象产品接‏口，表示某种具‍体的产品。

3）抽象工؜厂（Factory﻿）：定义了一个返回⁢产品对象的方法（一‏般是一个抽象方法）‍。tixvTheYGXxejp+louUqtnhSzCkcqYGh80mlhbQvU6Q=

4）具体工؜厂（Concret﻿eFactory）⁢：实现了抽象工厂中‏的创建产品的方法，‍生成具体的产品实例。



## 抽象工厂模式

抽象工厂模式专门用来创建一组互相关联的对象

这些对象之间的关联关系是：无论使用谁，都会有其它对象参与，虽然都是独立对象，但在业务上是一个共同体，这个时候就需要把它们全部创建，干脆把它们的创建打包在一起

![img](D:\01\技术\感获\md文档\设计模式.assets\fAan5HUTBzlw8YST.webp)



举一些开发中典型的应用场景：

- 多平台 UI 渲染引擎：在开发一个支持 Web、Android、小程序等多端渲染的内容管理系统时，可以用抽象工厂为不同平台提供一整套组件（按钮、表单、图片组件等），工厂屏蔽平台差异，保持调用方式一致。
- 多数据库适配场景（逻辑与物理结构差异大）：当一个系统需要支持 MySQL、Oracle、SQL Server 等数据库，且它们不仅语法不同，连分页、存储过程、数据结构等都不统一时，可用抽象工厂提供一整套数据访问组件（分页查询器、SQL 拼接器、字段映射器等）。
- 多种导出格式支持系统：比如报表系统或试卷系统中，一套业务数据可能要导出为 PDF、Word、Excel、HTML 等格式，每种格式对应一组导出组件（布局器、样式渲染器、文件写入器），通过抽象工厂生成完整的导出工具链。
- 多语言/多地区内容适配：跨境系统中，不同地区展示的内容、日期格式、币种符号等都不相同，可以通过抽象工厂为每个地区创建一整套“本地化服务组件”，如文本翻译器、格式转换器、金额展示器等。



可以看出，虽然具体创建细节有很大不同，但是抽象上是一致的，要创建数据库

这时候就可以用抽象接口作为同一接口，无论用哪个数据库，都可以通过这些统一数据库，屏蔽创建细节，统一调用方式



### 抽象工厂模式的基本结构

抽象工厂模式具有的角色和职责：

1）抽象工厂（AbstractFact؜ory）：声明一组创建产品的方法。
 2）具体工厂（ConcreteFac﻿tory）：实现创建具体产品对象的方法。
 3）抽象产品（Abstract⁢Product）：定义每个产品的公共接口。
 4）具体产品（Concret‏eProduct）：实现具体的产品对象。
 5）客户端（Client）：只‍依赖抽象工厂和抽象产品，负责调用工厂去生产对象。





### 实践

```java
// 抽象产品接口
public interface Button{
    void render();
}

public interface TextBox{
    void render();
}

public interface Image{
    void render();
}

// 抽象工厂
public interface UIFactory{
    Button createButton();
    Button createTextBox();
    Button createImage();
}

// 具体产品接口-Web
public class WebButton implements Button {
    @Override
    public void render() {
        System.out.println("渲染 Web 风格按钮");
    }
}

public class WebTextBox implements TextBox {
    @Override
    public void render() {
        System.out.println("渲染 Web 风格文本框");
    }
}

public class WebImage implements Image {
    @Override
    public void render() {
        System.out.println("渲染 Web 风格图片组件");
    }
}
// 具体产品接口-App
public class appButton implements Button {
    @Override
    public void render() {
        System.out.println("渲染 App 风格按钮");
    }
}

public class appTextBox implements TextBox {
    @Override
    public void render() {
        System.out.println("渲染 App 风格文本框");
    }
}

public class appImage implements Image {
    @Override
    public void render() {
        System.out.println("渲染 App 风格图片组件");
    }
}
// 具体工厂-web
public class WebUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new WebButton();
    }

    @Override
    public TextBox createTextBox() {
        return new WebTextBox();
    }

    @Override
    public Image createImage() {
        return new WebImage();
    }
}
// 具体工厂-app
public class AppUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new AppButton();
    }

    @Override
    public TextBox createTextBox() {
        return new AppTextBox();
    }

    @Override
    public Image createImage() {
        return new AppImage();
    }
}



    
//客户端
public class Client{
    
    public static void main(String[] args){
        
        UIFactory factory = new WebUIFactory();
        Button button = factory.createButton();
        TextBox textBox = factory.createTextBox();
        Image image = factory.createImage();
        
        Button button = factory.createButton();
        TextBox textBox = factory.createTextBox();
        Image image = factory.createImage();
    }
    
}


```



### 抽象工厂模式的优缺点和作用

优点

- **产品族的一致性**：抽象工厂模式可以保证同一个产品族中的组件搭配使用时不会出错，比如 UI 组件的样式风格统一，使用体验更协调，避免了“东拼西凑”的情况。
- **便于切换产品系列**：如果系统支持多种产品系列，比如要支持不同品牌或不同平台的实现，只需要替换一个工厂类，就能完成整套产品的切换，代码改动量小，扩展性好。
- **封装了对象的创建逻辑**：对象的创建过程都被工厂封装起来了，客户端不用关心具体怎么创建，只要调用对应的工厂方法就行，降低了使用门槛，也让代码更整洁。

缺点

- **扩展产品族比较困难**：一旦产品族的结构确定下来，比如工厂里要创建哪些产品是固定的，后期要再加一个新产品（比如再加一个新控件），就得改所有的工厂实现类，违反了开闭原则。
- **类的数量会变多**：每个产品系列都要对应一个具体工厂类，加上每个产品本身也要有接口和实现，项目结构会变得比较庞大，对于简单项目来说可能有些“杀鸡用牛刀”。
- **增加了系统的抽象层级**：虽然提高了灵活性，但也让代码结构变得更抽象，理解成本提升，对于新手或者不熟悉该模式的人来说，可能会觉得不太直观。

作用

​	1、统一产品创建逻辑

在实际开发中，我们经常会遇到“创建一整组相关对象”的场景。像 `DocumentBuilderFactory` 就是个很典型的例子，它不直接暴露底层的构造逻辑，而是统一提供 `DocumentBuilder` 实例的创建方式，确保不同平台、不同实现下生成的解析器行为一致。类似地，Spring 的 `ApplicationContext` 本质上也是个抽象工厂，负责统一创建 Bean 实例，保证配置文件、注解、Java 配置这些方式最终创建出的 Bean 都是风格一致、结构统一的。mRGelFRxTB7VTe2K9XB/KaI7V98pVhdVKB5ch1QjBfw=

​	2、提升扩展性

抽象工厂最大的优势之一是“新增产品族”时非常方便。以 Spring 为例，`ApplicationContext` 可以根据不同需求，切换为 `ClassPathXmlApplicationContext`、`AnnotationConfigApplicationContext` 等不同实现类，但外部调用者只依赖于统一的接口，不需要关心背后怎么创建 Bean。类似地，在 JDK 中我们也可以通过替换 `DocumentBuilderFactory` 实现，支持不同的 XML 解析器，扩展能力很强。

​	3、解耦具体实现

在系统架构中，解耦是很核心的一件事。我们通过定义抽象工厂接口，把产品的“使用”与“创建”彻底分开。比如我们平时在 Spring 中用 `getBean()` 获取对象时，根本不用管底层是用反射、CGLIB 还是单例池，具体策略全都被 `ApplicationContext` 屏蔽掉了。这样的好处是测试、替换、升级都不需要改动业务逻辑，系统整体也变得更灵活。







## --简单工厂、工厂方法、抽象工厂的区别

**1）简单工厂**：一个工厂类负责创建所有产品的实例，缺点是当产品种类增加时，工厂类会变得庞大，且难以扩展。

**2）工厂方法**：所有具体工厂源自1个抽象工厂，1个具体工厂类专精创建1类产品，通过继承和多态机制解决了简单工厂类的问题。

**3）抽象工厂**：进一步扩展了工厂方法模式，不仅提供了创建单一产品的工厂方法，还提供了创建一系列相关产品的工厂方法，确保了不同产品之间的协调性。





## 建造者模式

一大步分成好几小步走

就像饭馆吃饭，这个过程中客户端不在乎后厨怎么做，只要饭







# 结构型模式

# 行为型模式











































# 模板模式

抽象类，内有公共部分和抽象方法，抽象部分在公共内容里，公共内容打包为方法，实现类只需要实现方法，调用打包的方法即可（通过动态调用，调用各自方法）







# 代理模式

原本直接访问目标，现在由代理访问，代理介于我和目标之间

代理在不修改目标对象的前提下，灵活地扩展或改变其行为，实现对目标功能增强或控制

代理特征

1. **代理实现和目标对象相同的接口（`Runnable`）**。这样代理对象可以替换目标对象，这样可以把目标作为参数引入，执行一些增强或控制
2. 持有目标对象（`target`）。目标对象作为参数引入
3. **委托调用目标对象的方法（`target.run()`）**（java动态调用，引入后可以用目标对象方法）。
4. **提供额外的控制接口**（`start()`，代理自身的东西）。

```java
//如线程
class ThreadProxy implements Runnable {

    private Runnable target = null; 

    @Override
    public void run() {
        System.out.println("Before running..."); // 增强逻辑
        if(target != null) {
            target.run();// 委托给目标对象执行
        }
        System.out.println("After running..."); // 增强逻辑
    }

    public ThreadProxy(Runnable target) {
        this.target = target;//持有目标对象
    }


    // 这部分不直接调用，因为
    //	接口一致性：保持与目标对象（如 Thread）相同的调用方式。
	//	可扩展性：方便未来修改或增强启动逻辑。
	//	控制访问：在启动过程中添加额外功能（如权限、监控）。
    public void start(){
        start0();
    }

    public void start0() {
        run();
    }
    
}
```

- **抽象角色**：`Runnable`接口。
- **目标角色**：通过构造函数传入的`target`对象（实现了`Runnable`）。
- **代理角色**：`ThreadProxy`类本身。



![image-20250724121115252](D:\01\技术\感获\md文档\设计模式.assets\image-20250724121115252.png)

中断不是中止，





# 修饰器设计模式

现有对象结构不变，同时获取新功能



首先，为什么需要这个模式：

有一组功能一致但面向目标不同的方法，比如IO流，有面向file、buffer、对象的

file，对象本身IO能力较弱，但如果能使用bufferf方法加持，就能提高效率，这个时候如果我选择再创建类，让它继承file和buffer的方法，就需要新建类，如果我有很多很多需求，子类数量就会暴涨

如果我无需创建类就能调用方法就好了，为此可以通过 **类继承实现抽象类**的关系实现类的方法共享

A需要B的方法（这里假设file需要buffer的方法），那么谁被需要，谁就持有一个抽象类对象，这样，A类只需要向B传入它的实参，再向上转型，这样A就可以借助B的性能了





**主要解决的问题**

- 避免通过继承引入静态特征，特别是在子类数量急剧膨胀的情况下。
- 允许在运行时动态地添加或修改对象的功能。

**使用场景**

- 当需要在不增加大量子类的情况下扩展类的功能。
- 当需要动态地添加或撤销对象的功能。

**实现方式**

- **定义组件接口**：创建一个接口，规定可以动态添加职责的对象的标准。
- **创建具体组件**：实现该接口的具体类，提供基本功能。
- **创建抽象装饰者**：实现同样的接口，持有一个组件接口的引用，可以在任何时候动态地添加功能。
- **创建具体装饰者**：扩展抽象装饰者，添加额外的职责。



就像孙悟空72变



以java IO流为例

```java
//组件接口
public abstract Reader_ {
    public void readFile(){}
    public void readString(){}
}

// 具体组件
	//节点流，读写功能弱
public FileReader_ extends Reader_{
    public void readFile(){
		System.out.println("正在读取文件");
    }
}

public StringReader_ extends Reader_{
    public void readString(){
		System.out.println("正在读取字符串");
    }
}
	//包装流，读写功能强
public BufferedReader_ extends Reader_{
    
    private Reader_ reader_;
    
    public BufferedReader_(Reader_ reader_){
		this.reader_ = reader_;
    }
    // 可以理解成，通过父类形参，子类实参 这种方式，共属一个接口下的子类方法实现了共享，而且随着子类实参不同，方法也是不同的，在运行过程中可以替换，即动态替换
    
    	//假设这里传入的是FileReader实例，
    public void readFile(int num){
        for(int i = 0; i < num; i++){
            reader_.readFile();
        }
    }
    
}



// Test
public static void main(){
    BufferedReader_ br_ = new BufferedRead_(new FileReader_);
    br_.readFile(10);
}
```





















































