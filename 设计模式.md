2025年8月17日

到目前为止，设计模式给我的感觉就是抽象，模式越是抽象，它到具体实现的时候就越天马行空，每种模式都是制定1个大框架，实现指定功能，而不限制具体怎么做





# 前奏

设计模式是解决问题的方案

目前有4大类

| 序号 | 模式 & 描述                                                  | ***\*包括\****                                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | ***\*创建型模式\**** 创建对象的同时隐藏创建逻辑，（如 java不直接使用 new 运算符实例化对象），这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 | · 工厂模式（Factory Pattern）· 抽象工厂模式（Abstract Factory Pattern）· 单例模式（Singleton Pattern）· 建造者模式（Builder Pattern）· 原型模式（Prototype Pattern） |
| 2    | ***\*结构型模式\**** 关注对象之间的组合和关系，旨在构建灵活、可复用的类和对象结构。 | · 适配器模式（Adapter Pattern）· 桥接模式（Bridge Pattern）· 过滤器模式（Filter、Criteria Pattern）· 组合模式（Composite Pattern）· 装饰器模式（Decorator Pattern）· 外观模式（Facade Pattern）· 享元模式（Flyweight Pattern）· 代理模式（Proxy Pattern） |
| 3    | ***\*行为型模式\**** 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。 | · 责任链模式（Chain of Responsibility Pattern）· 命令模式（Command Pattern）· 解释器模式（Interpreter Pattern）· 迭代器模式（Iterator Pattern）· 中介者模式（Mediator Pattern）· 备忘录模式（Memento Pattern）· 观察者模式（Observer Pattern）· 状态模式（State Pattern）· 空对象模式（Null Object Pattern）· 策略模式（Strategy Pattern）· 模板模式（Template Pattern）· 访问者模式（Visitor Pattern） |
| 4    | ***\*J2EE 模式\**** 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 | · MVC 模式（MVC Pattern）· 业务代表模式（Business Delegate Pattern）· 组合实体模式（Composite Entity Pattern）· 数据访问对象模式（Data Access Object Pattern）· 前端控制器模式（Front Controller Pattern）· 拦截过滤器模式（Intercepting Filter Pattern）· 服务定位器模式（Service Locator Pattern）· 传输对象模式（Transfer Object Pattern） |

 这么多，但常用只有23种

![img](D:\01\技术\感获\md文档\设计模式.assets\wps3735.tmp.jpg) 

 



掌握设计模式，要对一些基本概念熟知：

**接口**

它就像是“规范”或者“协议”，定义了一组方法的**名称和参数格式**，但并不去实现这些方法的具体逻辑。我们可以把接口理解成是一种“承诺”——谁实现了这个接口，谁就必须按照接口定义的方法去完成逻辑。

在 Java 中，接口的作用主要有两个：

- **规范约束**：统一各个实现类的行为标准。
- **解耦合设计**：程序可以依赖接口而不是具体实现，这对于后期扩展和维护是非常重要的。

从 Java 8 开始，接口还可以带有默认方法（`default`）和静态方法，甚至可以有私有方法，但它们仍不能有实例变量，也不能有构造方法，接口本质上还是以“行为定义”为主。



**抽象类**

抽象类更像是“半成品”或者“骨架”，已经包含了一些默认的行为实现，还预留了部分抽象方法交给子类实现，让子类去继承并补全细节

抽象类有几个特点：

- 可以有普通成员变量和方法。
- 可以有构造函数。
- 可以包含抽象方法（用 `abstract` 关键字标识）。
- 不能被直接实例化。

抽象类和接口最大的不同是抽象类是类，有字段，属性



类存在父子关系，且父类提供默认实现，抽象类更好

制定规范，接口更好



**多态**

多态，指的是**同一操作作用于不同对象时，可以表现出不同的行为**。

多态有三种形式：

1. **方法重载（Overload）**：同一个类中方法名相同，参数不同。
2. **方法重写（Override）**：子类重新定义父类的方法。
3. **父类引用指向子类对象**：这是实际使用多态的常见场景。



这为设计模式中的很多“可扩展”“可替换”行为打下了基础。



**继承**

它允许我们创建一个类，并“复用”另一个类的代码。

继承有两个主要用途：

- **代码复用**：父类写好了通用逻辑，子类可以直接使用。
- **构建层次结构**：通过继承构建出清晰的类型体系。

 



# 设计模式的六大原则

## 单一职责原则

一个类，只干一件事。

一个类只负责一个功能模块上的事情。如果一个类同时负责业务逻辑、数据库访问、日志处理等多种职责，那么一旦某个职责发生变化，就有可能影响到整个类的稳定性。



比如装饰器模式、职责链模式，其实都是在帮我们把复杂职责拆分开，控制类的粒度



## 开闭原则

对扩展开放，对修改关闭。

当我们新增功能时，应该通过“新增代码”的方式来实现，而不是去修改已有的类或方法。这样做的好处是，原来的功能不会被影响，风险小；新功能也能保持独立，维护方便。



比如策略模式、工厂模式、本质上都是在帮助我们在已有体系上“平滑加功能”。





## 里氏替换原则

子类对象必须能够替换掉父类对象，并保持原有功能不变。

通俗点说，继承关系不能乱用。继承不是为了代码复用，而是为了“**保持通用的行为**”。如果子类违背了父类的行为约定，那就会出现一些难以察觉的 bug。

里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。



像模板方法模式、桥接模式这些，都很强调父子类之间的替换关系。



## 依赖倒置原则

高层模块不应该依赖低层模块，两者都应该依赖抽象。

就是“面向接口编程”，依赖抽象的接口 而不是 依赖某个具体的类。

比方说，一个支付系统，业务逻辑层不要直接依赖“微信支付”或“支付宝支付”的实现类，而应该依赖一个 `Payment` 接口。这样我们就可以灵活地切换实现方式，而不会动到业务逻辑的代码。

像工厂模式、策略模式、依赖注入的思想，基本都是围绕这个原则展开的。



## 接口隔离原则

接口要小而精，不要大而全。

接口一旦设计成“全能型”，实现起来就容易出现“我不需要这个方法但也要实现它”的情况。这样不仅多余，还容易让接口的维护变得困难。

比如我们在系统中定义了 `UserService` 接口，如果这个接口又要注册用户、又要导出报表、还要批量删除，很多实现类就会出现强行实现的尴尬场面。

它强调降低依赖，降低耦合。

像组合模式、适配器模式这些，往往就是在帮助我们更好地隔离接口、解耦功能。

## 迪米特法则(最少知道原则)

只和直接相关的类交流，尽量减少对外部对象的内部细节的依赖

也叫“最少知道原则”，就是说一个类应该尽量只关注自己的直接朋友，不要对别人家的细节过于熟悉。这样可以减少耦合，提高模块的独立性。

典型的例子就是外观模式，它通过提供统一入口，让调用者不需要接触系统内部的各种细节类。



比如，我不直接new引用，而是通过方法获取引用，但有很多方法，它们实现不同功能后组合返回，这样的话我就需要调用很多方法，这就是过于关注内部细节，我可以再写一个方法，把所有方法调用封装到这里面，我只调用这个方法就可以了

再比如，A方法有很多参数，B引用A，我设计的时候可以调用调用1个其它的间接无参数方法C，通过C调用A，即使A变动了，我也不需要修改引用A的部分



**7、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

```java
// 父类：相机（有拍照功能）
class Camera {
    public void takePhoto() {
        System.out.println("咔嚓，拍照成功");
    }
}

// 子类：手机（继承相机，直接用拍照功能）
class Phone extends Camera {
    public void makeCall() {
        System.out.println("喂，打电话呢");
    }
}

// 用的时候
Phone myPhone = new Phone();
myPhone.takePhoto(); // 继承来的功能
myPhone.makeCall();  // 自己的功能
```

如果还有来自收音机的功能，手机不能继承收音机，改成

```java
// 先做一个“相机模块”（独立功能，谁都能用）
class CameraModule {
    public void takePhoto() {
        System.out.println("咔嚓，拍照成功");
    }
}

// 再做一个“扫码模块”（也是独立功能）
class ScannerModule {
    public void scanCode() {
        System.out.println("滴，扫码成功");
    }
}

// 手机：通过“合成”持有这两个模块（相当于装了这两个零件）
class Phone {
    // 手机里“装”了相机和扫码模块（合成：模块不能脱离手机单独用）
    private CameraModule camera = new CameraModule();
    private ScannerModule scanner = new ScannerModule();

    // 手机自己的方法，内部调用模块的功能
    public void takePhoto() {
        camera.takePhoto(); // 让相机模块干活
    }

    public void scanCode() {
        scanner.scanCode(); // 让扫码模块干活
    }

    public void makeCall() {
        System.out.println("喂，打电话呢");
    }
}

// 用的时候
Phone myPhone = new Phone();
myPhone.takePhoto(); // 调用相机模块
myPhone.scanCode();  // 调用扫码模块
myPhone.makeCall();  // 自己的功能
```

以上是合成，以下是聚合

```java
class Headphone {
    public void playMusic() {
        System.out.println("播放音乐");
    }
}

class Phone {
    // 聚合：耳机是外部传进来的，能单独用（拔下来插别的手机也能用）
    private Headphone headphone;

    // 外部传入耳机
    public void setHeadphone(Headphone headphone) {
        this.headphone = headphone;
    }

    public void playMusic() {
        if (headphone != null) {
            headphone.playMusic();
        }
    }
}
```

主对象引用外部的模块是聚合，内部是合成





# 设计模式的分类

从设计模式的大类上来看，设计模式共分成三种类型：

1. 创建型模式（Creational Patterns）：主要关注“对象怎么创建”，比如单例、工厂、建造者。
2. 结构型模式（Structural Patterns）：主要处理“类与类、对象与对象之间如何组合”，比如适配器、桥接、装饰器。
3. 行为型模式（Behavioral Patterns）：关注“对象之间如何协作和通信”，比如观察者、状态、策略

![img](D:\01\技术\感获\md文档\设计模式.assets\SFXJtPi0ts2zBJBU.webp)

**不要过度依赖设计模式！！！！！！** 它并不是银弹(彻底解决某个复杂问题的简单方法)，过分使用设计模式可能只会增加系统的复杂度。

它们好用，但不是任何时候都应该用，在不恰当时机使用也会有问题



2025年8月12日，底部我还没看

[保姆级 23 种设计模式教程 - 编程导航教程 - 做您编程学习路上的导航员](https://www.codefather.cn/course/1930517607799193602?type=)

![image-20250812085312803](D:\01\技术\感获\md文档\设计模式.assets\image-20250812085312803.png)





# -----------------



# 创建型模式

## 单例模式

单例模式核心是单例，保证全局就这么1个

同时单例模式有饿汉懒汉2种



如何保证单例？那就是一开始创建1个，之后不再允许创建

做到这些，我就要保证创建方法不被获取（private），但这样只是不被外部获取，如果在内部的话，还是可以new引用，那我就做到无论怎么new，怎么引用，获取的都是那个最初创建好的（static）

这样的话



饿汉式和懒汉式区别是前者无论我是否使用都会创建对象，后者只有使用时才会创建

```java
// 饿汉式
class Person{

    private String name;
    private static Person person = new Person();	//唯一实例对象

    private Person() {	// 构造方法私有化

    }

    public static Person getInstance(){// 对外接口
        return person;
    }

}
```

```java
// 基础懒汉式

public class Main {

    public static void main(String[] args)  {

    }

    public static class Person{

        private String name;
        private static Person person;

        private Person() {

        }

        public static Person getInstance(){
            if(person == null){
                person = new Person();
            }
            return person;
        }

    }
}
```



**在线程方面**

- 饿汉式实例在类加载阶段由 JVM 的**类加载器机制**保证初始化的原子性（同一类加载过程中，静态变量初始化只会执行一次），无论多少线程调用`getInstance()`，获取的都是已经初始化完成的实例，不存在 “多线程同时创建多个实例” 的风险。
- 懒汉式由于存在多次通过 if(person == null)的情况，可能导致创建多个实例

为此，优化懒汉式

```java
class Person {
    // volatile 防止指令重排序导致的"半初始化"问题
    private static volatile Person person = null;

    private Person() {
    }

    public static Person getInstance(){
        if(person == null){
            //因为是static修饰的对象，类.class唯一
            synchronized (Person.class){
                if(person == null){
                    person = new Person();
                }
            }
        }
        return person;
    }
}
```







## 工厂模式

我把现实中工厂相关概念和设计模式中“工厂”联系起来便于理解

模板、批量、生产线

生产出来的东西虽然各不相同，但根本功能是一样的，就以日志系统为例，虽然有错误日志，数据库日志、控制台日志记录不同的内容，但本质都是记录，这就像模板，奠定基调

工程是为了高效批量的制作物品，这里就是高效便捷生成对象

通过工厂创建错误日志、操作日志的对象，这些不同的对象就是来自不同生产线的物品



我通过工程模式创建是为了使用，对于我这个消费者，不需要关心物品是怎么生产出来，所以工厂模式无需关心具体创建过程



**使用工厂模式是为了以  解耦对象创建和使用  的方式 创建对象，提升代码的可维护性、可扩展性和灵活性**





有无使用工厂模式对比

```java
//直接创建不同类型日志记录器
class Logger {
    private String type;

    public Logger(String type) {
        this.type = type;
    }

    public void log(String message) {
        if (type.equald("database")) {
            System.out.println("message");
        } else if (type.equals("console")) {
            System.out.println("message");
        }
    }
}
//引用对象和创建对象的内容混合在一起，若修改，就要牵扯大量修改
```



```java
//使用工厂

	//抽象产品
interface Logger{
    public void log(String msg);
}
	//抽象工厂
interface LoggerFactory{
    Logger getLogger();
}
	//具体产品
class FileLogger implements Logger{
    @Override
    public void log(String msg){
        System.out.println(msg);
    }
}
	//具体工厂
class FileLoggerFactory implements LoggerFactory{
    @Override
    public Logger getLogger(){
        return new FileLogger();
    }
}

//具体产品、工厂各自继承于抽象产品工厂
//工厂创建产品

// 调用
    public static void main(String[] args) throws Exception {
        FileLoggerFactory flf = new FileLoggerFactory();
        // 调用时用抽象（/父类）调用，这样才能接纳各种子类，实现替换
        Logger fl = flf.getLogger();
        fl.log("hello");
    }
```



通过对比可以看出，不使用工厂方法模式时，通过条件判断来处理不同类型的日志记录，无论哪种类型都在同一代码结构中创建，代码耦合度高、职责不单一，后续修改还违反开闭原则等

使用工厂方法模式后，؜**对象的创建与使用分离**，没有上述缺点

需创建新的工厂类⁢，通‏过工厂接口封装了具体日志记录器的创建细节，这个问题是类如果很多，显得臃肿

典型的应用场景：

- 消息通知系统：系统支持短信、邮件、站内信等不同通知方式时，可通过工厂方法屏蔽创建细节，让调用方只负责发消息。
- 支付系统：用户可能选择支付宝、微信、银行卡等支付方式，工厂方法可以根据用户选择生成对应的支付通道对象，方便扩展新方式。
- 文件解析模块：上传的文件可能是 Excel、CSV、JSON、XML 等不同格式，工厂方法可以根据文件类型创建对应的解析器实例，统一解析入口。
- 业务规则引擎：当一个系统支持多个业务规则版本（如不同行业、不同客户），可以通过工厂方法创建对应的规则计算器，灵活支持定制化逻辑。





**通过让子类决定实例化哪个具体类**，从而实现了对象创建的灵活性和可扩展性

↓

抽象工厂只规定 “要创建一个产品”，但不指定具体是哪个产品（比如只说 “造个交通工具”，不说造汽车还是自行车）
具体工厂（抽象工厂的子类）则负责 “决定” 并 “实现” 具体创建哪种产品：汽车工厂造汽车，自行车工厂造自行车





#### 工厂方法模式的基本结构

工厂方法模式具有的角色和职责：tixvTheYGXxejp+louUqtnhSzCkcqYGh80mlhbQvU6Q=

1）抽象产؜品（Product﻿）：定义产品的公共⁢接口，是所有具体产品‏的父类。

2）具体产؜品（Concret﻿eProduct）⁢：实现了抽象产品接‏口，表示某种具‍体的产品。

3）抽象工؜厂（Factory﻿）：定义了一个返回⁢产品对象的方法（一‏般是一个抽象方法）‍。tixvTheYGXxejp+louUqtnhSzCkcqYGh80mlhbQvU6Q=

4）具体工؜厂（Concret﻿eFactory）⁢：实现了抽象工厂中‏的创建产品的方法，‍生成具体的产品实例。



## 抽象工厂模式

抽象工厂模式专门用来创建一组互相关联的对象

这些对象之间的关联关系是：无论使用谁，都会有其它对象参与，虽然都是独立对象，但在业务上是一个共同体，这个时候就需要把它们全部创建，干脆把它们的创建打包在一起

![img](D:\01\技术\感获\md文档\设计模式.assets\fAan5HUTBzlw8YST.webp)



举一些开发中典型的应用场景：

- 多平台 UI 渲染引擎：在开发一个支持 Web、Android、小程序等多端渲染的内容管理系统时，可以用抽象工厂为不同平台提供一整套组件（按钮、表单、图片组件等），工厂屏蔽平台差异，保持调用方式一致。
- 多数据库适配场景（逻辑与物理结构差异大）：当一个系统需要支持 MySQL、Oracle、SQL Server 等数据库，且它们不仅语法不同，连分页、存储过程、数据结构等都不统一时，可用抽象工厂提供一整套数据访问组件（分页查询器、SQL 拼接器、字段映射器等）。
- 多种导出格式支持系统：比如报表系统或试卷系统中，一套业务数据可能要导出为 PDF、Word、Excel、HTML 等格式，每种格式对应一组导出组件（布局器、样式渲染器、文件写入器），通过抽象工厂生成完整的导出工具链。
- 多语言/多地区内容适配：跨境系统中，不同地区展示的内容、日期格式、币种符号等都不相同，可以通过抽象工厂为每个地区创建一整套“本地化服务组件”，如文本翻译器、格式转换器、金额展示器等。



可以看出，虽然具体创建细节有很大不同，但是抽象上是一致的，要创建数据库

这时候就可以用抽象接口作为同一接口，无论用哪个数据库，都可以通过这些统一数据库，屏蔽创建细节，统一调用方式



### 抽象工厂模式的基本结构

抽象工厂模式具有的角色和职责：

1）抽象工厂（AbstractFact؜ory）：声明一组创建产品的方法。
 2）具体工厂（ConcreteFac﻿tory）：实现创建具体产品对象的方法。
 3）抽象产品（Abstract⁢Product）：定义每个产品的公共接口。
 4）具体产品（Concret‏eProduct）：实现具体的产品对象。
 5）客户端（Client）：只‍依赖抽象工厂和抽象产品，负责调用工厂去生产对象。





### 实践

```java
// 抽象产品接口
public interface Button{
    void render();
}

public interface TextBox{
    void render();
}

public interface Image{
    void render();
}

// 抽象工厂
public interface UIFactory{
    Button createButton();
    Button createTextBox();
    Button createImage();
}

// 具体产品接口-Web
public class WebButton implements Button {
    @Override
    public void render() {
        System.out.println("渲染 Web 风格按钮");
    }
}

public class WebTextBox implements TextBox {
    @Override
    public void render() {
        System.out.println("渲染 Web 风格文本框");
    }
}

public class WebImage implements Image {
    @Override
    public void render() {
        System.out.println("渲染 Web 风格图片组件");
    }
}
// 具体产品接口-App
public class appButton implements Button {
    @Override
    public void render() {
        System.out.println("渲染 App 风格按钮");
    }
}

public class appTextBox implements TextBox {
    @Override
    public void render() {
        System.out.println("渲染 App 风格文本框");
    }
}

public class appImage implements Image {
    @Override
    public void render() {
        System.out.println("渲染 App 风格图片组件");
    }
}
// 具体工厂-web
public class WebUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new WebButton();
    }

    @Override
    public TextBox createTextBox() {
        return new WebTextBox();
    }

    @Override
    public Image createImage() {
        return new WebImage();
    }
}
// 具体工厂-app
public class AppUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new AppButton();
    }

    @Override
    public TextBox createTextBox() {
        return new AppTextBox();
    }

    @Override
    public Image createImage() {
        return new AppImage();
    }
}



    
//客户端
public class Client{
    
    public static void main(String[] args){
        
        UIFactory factory = new WebUIFactory();
        Button button = factory.createButton();
        TextBox textBox = factory.createTextBox();
        Image image = factory.createImage();
        
        Button button = factory.createButton();
        TextBox textBox = factory.createTextBox();
        Image image = factory.createImage();
    }
    
}


```



### 抽象工厂模式的优缺点和作用

优点

- **产品族的一致性**：抽象工厂模式可以保证同一个产品族中的组件搭配使用时不会出错，比如 UI 组件的样式风格统一，使用体验更协调，避免了“东拼西凑”的情况。
- **便于切换产品系列**：如果系统支持多种产品系列，比如要支持不同品牌或不同平台的实现，只需要替换一个工厂类，就能完成整套产品的切换，代码改动量小，扩展性好。
- **封装了对象的创建逻辑**：对象的创建过程都被工厂封装起来了，客户端不用关心具体怎么创建，只要调用对应的工厂方法就行，降低了使用门槛，也让代码更整洁。

缺点

- **扩展产品族比较困难**：一旦产品族的结构确定下来，比如工厂里要创建哪些产品是固定的，后期要再加一个新产品（比如再加一个新控件），就得改所有的工厂实现类，违反了开闭原则。
- **类的数量会变多**：每个产品系列都要对应一个具体工厂类，加上每个产品本身也要有接口和实现，项目结构会变得比较庞大，对于简单项目来说可能有些“杀鸡用牛刀”。
- **增加了系统的抽象层级**：虽然提高了灵活性，但也让代码结构变得更抽象，理解成本提升，对于新手或者不熟悉该模式的人来说，可能会觉得不太直观。

作用

​	1、统一产品创建逻辑

在实际开发中，我们经常会遇到“创建一整组相关对象”的场景。像 `DocumentBuilderFactory` 就是个很典型的例子，它不直接暴露底层的构造逻辑，而是统一提供 `DocumentBuilder` 实例的创建方式，确保不同平台、不同实现下生成的解析器行为一致。类似地，Spring 的 `ApplicationContext` 本质上也是个抽象工厂，负责统一创建 Bean 实例，保证配置文件、注解、Java 配置这些方式最终创建出的 Bean 都是风格一致、结构统一的。mRGelFRxTB7VTe2K9XB/KaI7V98pVhdVKB5ch1QjBfw=

​	2、提升扩展性

抽象工厂最大的优势之一是“新增产品族”时非常方便。以 Spring 为例，`ApplicationContext` 可以根据不同需求，切换为 `ClassPathXmlApplicationContext`、`AnnotationConfigApplicationContext` 等不同实现类，但外部调用者只依赖于统一的接口，不需要关心背后怎么创建 Bean。类似地，在 JDK 中我们也可以通过替换 `DocumentBuilderFactory` 实现，支持不同的 XML 解析器，扩展能力很强。

​	3、解耦具体实现

在系统架构中，解耦是很核心的一件事。我们通过定义抽象工厂接口，把产品的“使用”与“创建”彻底分开。比如我们平时在 Spring 中用 `getBean()` 获取对象时，根本不用管底层是用反射、CGLIB 还是单例池，具体策略全都被 `ApplicationContext` 屏蔽掉了。这样的好处是测试、替换、升级都不需要改动业务逻辑，系统整体也变得更灵活。







## --简单工厂、工厂方法、抽象工厂的区别

**1）简单工厂**：一个工厂类负责创建所有产品的实例，缺点是当产品种类增加时，工厂类会变得庞大，且难以扩展。

**2）工厂方法**：所有具体工厂源自1个抽象工厂，1个具体工厂类专精创建1类产品，通过继承和多态机制解决了简单工厂类的问题。

**3）抽象工厂**：进一步扩展了工厂方法模式，不仅提供了创建单一产品的工厂方法，还提供了创建一系列相关产品的工厂方法，确保了不同产品之间的协调性。





## 建造者模式

大问题分解成小问题

复杂对象构建过程清晰表达：有很多步骤、参数，直接在构造函数或者其他方法中传递这些信息会变得复杂难懂。而建造者模式把这些步骤分开了，使得对象的构建过程更加清晰。

构建过程和表示分离：建造者模式可以把构建过程和对象的表示（即结果）分离开来，分离后具备抽象性质，使得同一个构建过程能够创建出不同表示的对象。

基于上述原因：对于   需求不同，但是构建过程又很相似的对象，只需改动部分代码就能实现



![img](D:\01\技术\感获\md文档\设计模式.assets\hJ7LwlEhpVJmCxu4.webp)

开发中典型的应用场景：

- 复杂表单或请求对象的构建：如创建一个包含多个可选字段的用户注册请求、订单提交请求、报表筛选条件等，可以用建造者模式灵活拼接参数，避免构造方法过长或参数顺序混乱。
- 导出文件内容构建：例如生成复杂的 PDF 报告、Word 文件或 Excel 报表，往往需要一步步构建文档结构（页眉、表格、图片、段落等），使用建造者模式可以分步骤构造并保证内容完整性。
- 业务流水记录对象创建：例如在支付系统或交易系统中，流水日志往往由多个字段拼成（请求来源、时间戳、交易码、响应内容、错误栈等），用建造者模式可以按需构造，避免创建臃肿的构造器或 set 方法杂乱调用。
- 消息推送内容构建器：推送系统中，不同渠道（短信、微信、邮件）消息格式各异，有标题、正文、按钮、跳转链接等字段，通过建造者统一构造内容体，保持代码清晰灵活。



可见建造者模式可以根据需求自由搭配组合，这也需要一个指挥角色，来按一定步骤构建



**建造者模式具有的角色和职责：**

1）产品类؜（Product）﻿：要构建的复杂对象⁢，包含多个组成部分‏

2）抽象建؜造者类（Build﻿er）：定义构建产⁢品各个部分的抽象方‏法，以及返回最终产‍品的方法。

3）具体建造؜者类（Concrete﻿Builder）：实现⁢Builder接口，具‏体负责各个部分的构建细‍节，并最终组装出完整产品。

4）指挥者؜类（Directo﻿r）：统一指挥建造⁢者按照一定步骤来构‏建产品，屏蔽了构建过‍程的细节。

5）客户端类（؜Client）：发起建造请求﻿，选择具体的建造者并使用指挥⁢者来完成产品的创建。   



```java
// 定义产品类
class Computer {
    private String disk;
    private String ram;
    private String cpu;


    public void setDisk(String disk) {
        this.disk = disk;
    }

    public void setRam(String ram) {
        this.ram = ram;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    @Override
    public String toString() {
        return "Computer{" +
                "disk='" + disk + '\'' +
                ", ram='" + ram + '\'' +
                ", cpu='" + cpu + '\'' +
                '}';
    }
}
```

```java
// 定义抽象建造者类
abstract class ComputerBuilder {
    Computer computer = new Computer();

    public abstract void setDisk(String disk);

    public abstract void setRam(String ram);

    public abstract void setCpu(String cpu);

    public Computer getComputer() {
        return computer;
    }
}
```

```java
// 定义具体产品类的构建者类
class WorkComputerBuilder extends ComputerBuilder {
    Computer computer = new Computer();

    @Override
    public void setDisk(String disk) {
        computer.setDisk("asdas");
    }

    @Override
    public void setRam(String ram) {
        computer.setRam("setRam");

    }

    @Override
    public void setCpu(String cpu) {
        computer.setCpu("setCpu");

    }

}
```

```java
// 定义指挥类
class Direcotor {
    private ComputerBuilder builder;

    public Direcotor(ComputerBuilder builder) {
        this.builder = builder;
    }

    public Computer construct(){
        builder.setDisk("asdas");
        builder.setRam("setRam");
        builder.setCpu("setCpu");
        return builder.getComputer();
    }

}
```

```java
//客户端类
public static void main(String[] args) throws Exception {

    ComputerBuilder builder = new WorkComputerBuilder();
    Computer computer = new Direcotor(builder).construct();
    System.out.println(computer);
}
```



### 建造者模式的优缺点

#### 优点

- **结构清晰、过程可控**：建造者模式把复杂对象的构建过程拆成一个个明确的步骤，让整个构建流程变得清晰、稳定，而且每一步都可以单独控制，方便管理和调整。
- **便于构建“不同版本”的对象**：通过不同的建造者，可以轻松地创建出结构类似但配置不同的对象，特别适合那种“定制化”很强的业务场景，比如生成不同类型的报表、构造不同风格的 UI 等。
- **代码更易维护和扩展**：把构建逻辑从产品本身抽离出来，符合单一职责原则，既减少了耦合，也让代码更容易维护。如果后续要新增构建步骤或者替换某个细节，实现起来也很自然。

#### 缺点

- **增加了类的数量**：为了实现建造者模式，需要引入额外的建造者类和指挥者类，类的数量一下子就上来了。如果对象结构本身不复杂，这种拆分反而会让代码变得繁琐。
- **不适合构建过程差异太大的对象**：建造者模式适合用在“有共同构建步骤”的对象上。如果对象之间的构建逻辑完全不一样，硬套建造者反而会让代码变得臃肿、不灵活。









# 结构型模式

关注类和对象的搭配协调，不解决具体业务



## 适配器模式

一些东西之间不兼容，造个适配器类当桥梁

适配器模式的核心就是兼容差异



适配器模式具有的角色和职责：

1）目标接口（Target）：客户端希望使用的接口。aC5zdeWLpULKjkbRg1/IA25mHAXY3bvuBuCjDHl+xgY=

2）适配器؜类（Adapter﻿）：实现了目标接口⁢，并且通过委托的方‏式将请求转换为适配的‍接口调用。

3）适配者类（Adaptee）：已有的、需要适配的类。

4）客户端（Client）：通过目标接口与系统交互的代码。



```java
// 客户端
public static void main(String[] args) throws Exception {

    ModelPlayer player = new ModelPlayer();
    player.play("mp3", "1");
    player.play("mp4", "2");
    player.play("vlc", "3");
    player.play("avi", "4");
}
```



```java
//	适配者：待适配
interface APlayer {
    void play(String type, String fileName);
}

//	目标
interface BPlayer {
    void playMp3(String fileName);

    void playVLC(String fileName);
}

// 适配接口实现
class Mp4Player implements APlayer {

    @Override
    public void play(String type, String fileName) {
        System.out.println("Mp4");
    }
}

//	目标接口实现
static class Mp3Player implements BPlayer {

    @Override
    public void playMp3(String fileName) {
        System.out.println("Mp3");
    }

    @Override
    public void playVLC(String fileName) {
    }
}
//	因为单一功能原则，各自只实现1个方法
static class VLCPlayer implements BPlayer {

    @Override
    public void playMp3(String fileName) {
    }

    @Override
    public void playVLC(String fileName) {
        System.out.println("VLC");
    }
}


//	适配器
static class ModelPlayer implements APlayer {

    private BPlayer bPlayer;

    @Override
    public void play(String type, String fileName) {
        if (type.equals("mp4")) {
            System.out.println(fileName);
        } else if (type.equals("vlc")) {
            bPlayer = new VLCPlayer();
            bPlayer.playVLC(fileName);
        } else if (type.equals("mp3")) {
            bPlayer = new Mp3Player();
            bPlayer.playMp3(fileName);
        } else {
            System.out.println("error");
        }
    }
}
```



## 代理模式

目标对象间接被访问

不直接访问某对象可能是因为 不想 或 不能 （资源太大、权限﻿限制、需要额外操作）

这些逻辑都扔给目标对象，它的职责会复杂，有代理可以在不改变‍原始类代码的前提下，对原始对象进行功能增强或者访问控制。



比如图片，有图片加载控制逻辑，和图片显示逻辑，如果没有代理，全部在目标对象实现，有了代理，代理负责一种逻辑，职责划分更清晰



关键是区分目标和代理的职责，建立它们之间联系



**举一些开发中典型的应用场景**：

* 权限代理：在系统中有权限控制时，代理模式可用于控制对某些功能或资源的访问。例如，某些用户或角色只能访问特定的资源或方法，通过代理来拦截调用，验证用户权限后再决定是否允许执行操作。
* 日志记录代理：在业务系统中，操作日志的记录是非常常见的需求。代理模式可以用于方法调用的拦截，在方法执行前后自动记录日志信息，而不需要修改原始业务逻辑。例如，在一个订单系统中，所有订单的创建、修改操作都通过代理来记录日志，追踪操作过程。
* 网络图片懒加载器：在开发一些图片浏览应用或文档查看工具时，我们不希望一开始就把所有图片都加载到内存中，尤其是当图片很多、尺寸又大时。这时我们可以使用代理模式，让“代理图片”控制真实图片的加载时机，只有真正需要显示时再去加载资源，从而节省内存和加快响应。****



**代理模式具有的角色和职责**：

1）抽象**主؜题**接口（Subje﻿ct）：定义了实际对象和代理对象都需‏要实现的方法。

2）真实主؜题（RealSub﻿ject）：也就是⁢目标对象，真正去执‏行核心业务逻辑的类‍。

3）代理类（P؜roxy）：实现和目标对象﻿相同的接口，在内部维护一个⁢真实对象的引用。代理类会控‏制对真实对象的访问，可能会‍在调用前后加点特殊的处理逻辑。



以图片懒加载为例

对用户来说，不知道存在代理，以为就是加载图片

对用户来说，代理就是目标对象，而对代理来说，目标对象是它的目标对象

因为这个缘故，代理和实际对象都需要实现加载图片这个抽象主题接口

```java
// 抽象 主题接口
interface Image {
    // 主题是展示图片
    void display();
}
```

```java
// 代理
static class ProxyImage implements Image {
    private String fileName;
    private RealImage realImage;

    // 用户给代理发送要获得的图片的图片名，这也是联系代理和实际对象的枢纽
    public ProxyImage(String fileName) {
        this.fileName = fileName;
    }

    @Override
    //代理返回图片，需要从实际对象那里获取
    // 这里使用了懒加载
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }
}
```

```java
// 实际对象，目标对象
static class RealImage implements Image {

    private String fileName;

    // 代理调用实际对象，实际对象获取了图片名，根据图片名实现实际对象负责的逻辑：找到图片
    public RealImage(String fileName) {
        this.fileName = fileName;
        loadFromDisk();
    }

    public void loadFromDisk() {
        System.out.println("来自硬盘");
    }

    @Override
    public void display() {
        System.out.println(fileName);
    }
}
```

```java
// 客户端
public static void main(String[] args) throws Exception {

    ProxyImage image = new ProxyImage("1.png");

    System.out.println("首次载图");
    image.display();
    System.out.println("第二次载图");
    image.display();
}
```





### （未接触）动态选择代理

### （未接触）动态代理

动态代理是 “动态生成代理类”，而 “按配置选代理” 是 “动态选择代理实例”，两者本质不同，但可以结合使用。



**优点**

* **控制对象访问**：通过代理类控制对目标对象的访问，有助于增强安全性、控制权限或延迟加载。
* **增强目标对象功能**：无需修改目标类代码即可添加额外功能，如缓存、日志、远程访问等，符合开闭原则。
* **隔离客户端与目标对象**：客户端通过代理与目标对象交互，有利于解耦，提高系统的可维护性。
* **支持多种代理形式**：支持静态代理、动态代理、远程代理等多种实现方式，适应不同应用场景。
* 

**缺点**

* **增加系统复杂度**：引入代理类会增加类的数量和系统结构的复杂性，增加理解和维护成本。
* **可能引入性能开销**：特别是在动态代理或远程代理中，可能带来反射、网络传输等额外开销。
* **不适用于频繁变更的接口**：若目标接口频繁变更，代理类也需同步更新，降低了开发效率。





## 装饰模式

目的是不动原功能，并动态的给它扩展功能



装饰装饰，自然是给原有东西点缀



在实际开发中：需求变更，需要添加（日志、加缓存、加权限控制等）非核心但必需的业务逻辑，可用装饰模式



以文本渲染为例：文本渲染（加粗，色彩，倾斜等），这些渲染各自是1个方法，装在一个类里，如果对文本进行不同渲染，一次调用多个方法，组合这些方法为1个新方法，最后整个渲染类都会变得臃肿，而且下次不一定用得到了，还是对原始类的修改，违背设计模式原则

使用装饰模式，将所有涉及渲染的东西划分组件（要被渲染的文本，渲染器），它们实现共同接口（统一规范，实现某些类独立也能互相传递），然后再将抽象的装饰器根据功能具体实现，（具体渲染器），最后，不管怎样的渲染组合，我只需要动态调用就行（原来无论用不用，所有方法都会加载，不如动态调用，用的时候再加载）



装饰模式具有的角色和职责：

1）组件接؜口（Compone﻿nt）：定义对象的⁢接口，所有的具体组‏件和装饰器都实现‍这个接口

2）具体组؜件（Concret﻿eComponen⁢t）：就是原始对象‏，包含核心功能实现

3）抽象装؜饰器（Decora﻿tor）：实现组件⁢接口，内部持有一个‏组件对象（也就是被装饰‍的对象）

4）具体装؜饰器（Concre﻿teDecorat⁢or）：继承抽象装‏饰器，负责给组件对‍象添加新的功能

<img src="D:\01\技术\感获\md文档\设计模式.assets\Am6Q1VgYH9uwcZaB.webp" alt="img" style="zoom:50%;" />

组件接口负责统一规范，也保证了这些所有东西都是一个家族的，实现传递，具体组件包含原始对象，也实现核心功能，其它的就是实现不改变原内容添加新内容的装饰器了，所有装饰器源自1个抽象装饰器

装饰模式有个很重要的点是要进行传递，会形成传递链，没有组件接口就无法实现）（虽然看上去它什么也没做，但实际上它在底层做很重要的支撑）

把它们串联起来的核心是	render()渲染

调用装饰的地方，一般是具体组件里，是装饰链的起点



```java
//	客户端调用
public class Client {
    public static void main(String[] args) {
        TextComponent text = new PlainText("Hello, Decorator!");

        // 添加加粗
        text = new BoldDecorator(text);

        // 添加红色字体
        text = new ColorDecorator(text, "red");

        System.out.println("最终渲染结果：");
        System.out.println(text.render());
    }
}



//	定义文本组件接口：声明所有文本类必须实现的 render() 方法
public interface TextComponent {
    String render();
}

//	实现基本文本类：作为被装饰的核心组件
public class PlainText implements TextComponent {
    private String content;

    public PlainText(String content) {
        this.content = content;
    }

    @Override
    public String render() {
        return content;
    }
}

//	定义装饰器抽象类：用于包裹基础组件并扩展功能
public abstract class TextDecorator implements TextComponent {
    protected TextComponent component;

    public TextDecorator(TextComponent component) {
        this.component = component;
    }
}

//	实现具体装饰器类（加粗、加颜色）
public class BoldDecorator extends TextDecorator {
    public BoldDecorator(TextComponent component) {
        super(component);
    }

    @Override
    public String render() {
        return "<b>" + component.render() + "</b>";
    }
}

public class ColorDecorator extends TextDecorator {
    private String color;

    public ColorDecorator(TextComponent component, String color) {
        super(component);
        this.color = color;
    }

    @Override
    public String render() {
        return "<span style='color:" + color + "'>" + component.render() + "</span>";
    }
}

```

我写的

```java
package com.net;

public class One {

    public static void main(String[] args) {

        String content = "asd";
        TextComponent component = new PlainText(content);
        component = new BoleDecorator(component);
        component = new ColorDecorator(component, "red");
        //只有这里调用了render（）方法，但是因为component都来自上一个装饰器，整个装饰链的 `render` 方法都会被 间接调用，这正是装饰器模式 “链式传递” 的核心机制。
        System.out.println(component.render());
        //整个过程是 链式委托：表面上只调用了最外层装饰器的 `render`，但内部会自动追溯到所有被包装的组件，依次执行它们的 `render` 方法。
        //PlainText也是装饰器，本身就是装饰器可以装饰 装饰器
    }


    interface TextComponent {
        String render();
    }

    //  基本文本类，被修饰，核心功能
    static class PlainText implements TextComponent {
        private String content;

        public PlainText(String content) {
            this.content = content;
        }

        @Override
        public String render() {
            return content;
        }

    }

    //  抽象装饰器
    static abstract class BaseDecorator implements TextComponent {
        protected TextComponent component;

        public BaseDecorator(TextComponent component) {
            this.component = component;
        }

    }

    //  具体装饰器
    static class BoleDecorator extends BaseDecorator {

        public BoleDecorator(TextComponent component) {
            super(component);
        }

        @Override
        public String render() {
            return component.render() + "bold";
        }
    }

    static class ColorDecorator extends BaseDecorator {

        private String color;

        public ColorDecorator(TextComponent component, String color) {
            super(component);
            this.color = color;
        }

        @Override
        public String render() {
            return component.render() + color;
        }
    }


}


```



优点

* **扩展功能更灵活**：装饰模式允许你在不修改原始类代码的前提下，动态地给对象增加额外的功能。比起继承，它更灵活，也更符合开闭原则，特别适合功能经常变动的场景。
* **避免类过多**：如果用继承来应对各种功能组合，很容易导致子类数量成倍增加，维护压力大。装饰模式通过“包装”的方式，把功能拆成一个个装饰类，组合使用，结构更清晰。
* **可以组合使用**：多个装饰类可以灵活叠加，按需组合功能，像搭积木一样，自由度高，不用预先规划好所有情况，尤其适合处理功能可选、可叠加的业务逻辑。
* 增强功能不影响原有结构
* 支持链式组合，领过增强
* 职责清晰，逻辑解耦：像日志、转换、؜校验这类与业务无关的增强逻辑﻿，都可以通过装饰器独立出来，⁢既避免了业务类臃肿，也方便维‏护和替换，IO 和 Serv‍let 场景都很适合这样做

缺点

* **调试比较麻烦**：因为装饰模式是通过一层一层地包装对象的，有时候为了看清楚一个操作是在哪个环节做的，你可能得顺着一长串“包装链”去追踪，调试起来不太友好。
* **增加了系统复杂度**：虽然类过多的问题解决了，但类之间的关系变得更抽象了，理解和使用都需要一定的学习成本。特别是对于刚接触装饰模式的人来说，不太容易一下子理清谁在装饰谁。
* **可能影响性能**：如果装饰链太长，每次调用方法都要经过多层对象转发，虽然每层逻辑可能都很轻，但叠加起来也可能对性能有些影响，尤其是在高频调用场景下。





举一些开发؜中典型的应用场景：﻿         ⁢         ‏         ‍     

* 动态增加功能或行为：例如，在电商系统中，用户可能选择多个优惠（如打折、优惠券、积分抵扣等）。这些优惠可以通过装饰模式动态地为订单增加不同的优惠功能，而不需要修改原始的订单类。每种优惠可以视为一个装饰类，独立实现不同的行为。
* 输入输出流处理：在文件读取和写入操作中，经常使用装饰模式。例如，Java 的 I/O 流操作就使用了装饰模式。你可以使用 `BufferedReader` 装饰 `FileReader`，为其增加缓冲功能，而不需要改变 `FileReader` 的原始实现。
* 日志系统功能增强：在日志记录系统中，通常有多种日志格式或输出方式。可以使用装饰模式为日志对象动态增加不同的功能，如输出到文件、控制台、远程服务器等。每种日志输出方式可以作为一个装饰器，透明地增加额外的功能。
* 文本渲染增强系统：在开发富文本编辑器或日志输出组件时，经常会需要在文本基础上增加不同的功能，比如加粗、加下划线、加颜色等等。如果直接在原有类中添加这些功能，会导致类膨胀、职责混乱。用装饰模式可以在不改变原有类的基础上，为其动态添加功能，保持设计的灵活性和扩展性。



2025年10月24日

学到这里，我觉着这些设计模式，是从软件一开始搭建就使用的，如果软件已经形成一定架构和规模就效果不好了，还有个关键点，什么时候，用什么设计模式？

这里用代理模式也行吧？如果我还有这种疑问，说明我没学透，代理模式是将一些逻辑和核心逻辑分开，不能或不想是现在一起，而装饰模式核心是为了添加新功能





 JDK 里面最典型的装饰模式实现，就是在 IO 流

```java
public class BufferedReader extends Reader {    private Reader in; // 被包装的 Reader     public BufferedReader(Reader in) {        this(in, defaultCharBufferSize);    }     public String readLine() throws IOException {        // 加缓冲逻辑读取一整行    } }
```



```java
// 使用方式
Reader reader = new FileReader("test.txt");
BufferedReader bufferedReader = new BufferedReader(reader);
String line = bufferedReader.readLine();
```



## 外观模式

**为复杂的子系统提供一个统一的对外接口**，我们访问子接口而无需关心内部复杂逻辑



外观模式具有的角色和职责：tsOBO420zrT6+W1hsgn40NCYQd8/Rxz4CWxTh6kPHZI=

1）外观类؜（Facade）：﻿对外提供统一接口，⁢封装子系统的调用。

2）子系统؜类（Subsyst﻿em）：负责自身的⁢业务逻辑处理，通常‏不会对外暴露。

3）客户端（Client）：通过外观类来使用子系统的功能。

<img src="D:\01\技术\感获\md文档\设计模式.assets\6sH85LWn0gECvmtD.webp" alt="img" style="zoom:50%;" />





优点

* **简化调用逻辑**：外观模式最大的作用就是把系统的复杂度“挡在门外”。对于使用方来说，只需要跟一个外观类打交道，不用去理会底层有多少子系统、具体是怎么实现的，调用起来简单又清爽。
* **降低耦合度**：外观类起到了一个中间人的作用，让调用者和内部子系统之间的联系变得松散。换句话说，你要是将来改了底层实现，只要外观接口不动，上层代码基本不用动，维护成本低。
* **有利于分层架构设计**：在一些分层结构的系统里，比如三层架构，外观类可以作为“门卫”，帮你管理每一层之间的依赖关系，让层与层之间解耦得更干净，结构也更清晰。

缺点

* **功能扩展时不够灵活**：一旦客户端习惯了只跟外观类打交道，那要想用到子系统里一些比较细的功能，就得回头改外观类，或者绕过它。这时候，外观反而成了一种限制。
* **可能会变成“万能类”**：如果设计得不太合理，外观类很容易膨胀，什么事都往它身上堆，最后变成一个大杂烩，职责太多，反而不利于维护。
* **隐藏了部分系统细节**：虽然这本身是优点，但有时候也是把“双刃剑”。尤其是在调试或者排查问题时，如果所有东西都被外观包装了起来，开发者可能会对系统内部的真实结构缺乏了解，排错效率也可能受影响。





```java
// 实体类
public class User {
    private int id;
    private String name;

    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}

//定义底层 DAO 接口和实现：封装原始数据⁢库操作（模拟实现）
public interface UserDAO {
    void insert(User user);
    User findById(int id);
    void update(User user);
    void delete(int id);
}
// 实现基本CRUD操作
import java.util.HashMap;
import java.util.Map;

public class UserDAOImpl implements UserDAO {
    private Map<Integer, User> database = new HashMap<>();

    public void insert(User user) {
        database.put(user.getId(), user);
        System.out.println("插入用户：" + user.getName());
    }

    public User findById(int id) {
        System.out.println("根据 ID 查询用户：" + id);
        return database.get(id);
    }

    public void update(User user) {
        database.put(user.getId(), user);
        System.out.println("更新用户：" + user.getName());
    }

    public void delete(int id) {
        User removed = database.remove(id);
        System.out.println("删除用户：" + (removed != null ? removed.getName() : "未知"));
    }
}


```

如果没有 `UserServiceFacade`，客户端要完成 “创建用户”“更新用户” 等业务操作，需要自己处理 `UserDAO` 的细节

```java
// 没有外观类时，客户端的代码
UserDAO userDAO = new UserDAOImpl();

// 1. 创建用户：需要手动new User，再调用insert
User user = new User(1, "张三");
userDAO.insert(user);

// 2. 更新用户：需要先findById查询，再手动修改属性（如果User有setter），最后调用update
User oldUser = userDAO.findById(1);
oldUser.setName("张三三"); // 假设User有setName方法
userDAO.update(oldUser);

// 3. 查看用户：需要先findById，再手动打印信息
User user = userDAO.findById(1);
if (user != null) {
    System.out.println("用户信息：ID=" + user.getId() + "，姓名=" + user.getName());
} else {
    System.out.println("未找到用户");
}
```

如果有了外观类

```java
public class UserServiceFacade {
    private UserDAO userDAO;

    public UserServiceFacade() {
        this.userDAO = new UserDAOImpl(); // 实际开发中可注入
    }

    public void createUser(int id, String name) {
        User user = new User(id, name);
        userDAO.insert(user);
    }

    public void viewUser(int id) {
        User user = userDAO.findById(id);
        if (user != null) {
            System.out.println("用户信息：ID=" + user.getId() + "，姓名=" + user.getName());
        } else {
            System.out.println("未找到对应的用户");
        }
    }

    public void renameUser(int id, String newName) {
        User user = userDAO.findById(id);
        if (user != null) {
            User updatedUser = new User(id, newName);
            userDAO.update(updatedUser);
        } else {
            System.out.println("无法重命名，用户不存在");
        }
    }

    public void removeUser(int id) {
        userDAO.delete(id);
    }
}
```

```java
// 客户端示例
public class Client {
    public static void main(String[] args) {
        UserServiceFacade userService = new UserServiceFacade();

        userService.createUser(1, "鱼皮");
        userService.viewUser(1);
        userService.renameUser(1, "Yes");
        userService.viewUser(1);
        userService.removeUser(1);
        userService.viewUser(1);
    }
}
```

```markdown
插入用户：鱼皮
根据 ID 查询用户：1
用户信息：ID=1，姓名=鱼皮
根据 ID 查询用户：1
更新用户：Yes
根据 ID 查询用户：1
用户信息：ID=1，姓名=Yes
删除用户：Yes
根据 ID 查询用户：1
未找到对应的用户
```





## 桥接模式

当一个系统中，抽象和实现之间都可能频؜繁变化，而且两者都存在多种可能性组合的时候，使用桥接



比如做一个消息通知系统，你可能既要支持“邮⁢件通知、短信通知、微信通知”，又要支持“普通用户、VI‏P 用户、企业用户”的各种业务逻辑。2种类型相互独立但因业务联系紧密，用继承联系在一起会很臃肿，用抽象接口桥接

2种类型是现实部分，联系它们的抽象接口是抽象部分

如果业务变更导致它们都变换，它们通过继承的方式依然会臃肿，且它们有不同的组合，为此通过组合的方式实现

<img src="D:\01\技术\感获\md文档\设计模式.assets\Wcl4r2Is8zTMhBso.webp" alt="img" style="zoom: 33%;" />

消息有普通和告警，消息类型有邮件和短信，不使用桥接模式把它们全都作为单独类，使用桥接则分为消息接口，类型接口，然后它们是抽象的，其下各自有具体实现，抽象和实现分离



举一些开发中典型的应用场景：

* 支付系统：在电商平台中，不同的支付方式（如支付宝、微信支付、银行卡支付）通常具有不同的支付实现逻辑。通过桥接模式，可以将支付接口与支付方式分开，使得支付系统可以在不修改业务逻辑的情况下，灵活地添加新的支付方式，同时也能保持原有支付方式的稳定性。
* 多渠道广告系统：在一个广告发布平台中，可能需要支持不同的广告投放渠道（如电视、互联网、户外广告等）。桥接模式可以将广告的具体展示与不同广告渠道的实现分开，使得增加或修改广告渠道时，系统的其他部分不受影响，提升系统的扩展性和维护性。
* 消息推送系统扩展：在一个支持多平台（如邮件、短信、微信等）的消息推送系统中，不同的消息类型（如普通通知、告警通知）和发送渠道可能任意组合。使用桥接模式，我们可以将“消息类型”和“发送渠道”解耦，避免类数量过多，并实现任意组合的灵活扩展。











# 待融入-------------代理模式

1. **代理实现和目标对象相同的接口（`Runnable`）**。这样代理对象可以替换目标对象，这样可以把目标作为参数引入，执行一些增强或控制
2. 持有目标对象（`target`）。目标对象作为参数引入
3. **委托调用目标对象的方法（`target.run()`）**（java动态调用，引入后可以用目标对象方法）。
4. **提供额外的控制接口**（`start()`，代理自身的东西）。

```java
//如线程
class ThreadProxy implements Runnable {

    private Runnable target = null; 

    @Override
    public void run() {
        System.out.println("Before running..."); // 增强逻辑
        if(target != null) {
            target.run();// 委托给目标对象执行
        }
        System.out.println("After running..."); // 增强逻辑
    }

    public ThreadProxy(Runnable target) {
        this.target = target;//持有目标对象
    }


    // 这部分不直接调用，因为
    //	接口一致性：保持与目标对象（如 Thread）相同的调用方式。
	//	可扩展性：方便未来修改或增强启动逻辑。
	//	控制访问：在启动过程中添加额外功能（如权限、监控）。
    public void start(){
        start0();
    }

    public void start0() {
        run();
    }
    
}
```

- **抽象角色**：`Runnable`接口。
- **目标角色**：通过构造函数传入的`target`对象（实现了`Runnable`）。
- **代理角色**：`ThreadProxy`类本身。



![image-20250724121115252](D:\01\技术\感获\md文档\设计模式.assets\image-20250724121115252.png)

中断不是中止，





# 装饰模式

现有对象结构不变，同时获取新功能



首先，为什么需要这个模式：

有一组功能一致但面向目标不同的方法，比如IO流，有面向file、buffer、对象的

file，对象本身IO能力较弱，但如果能使用bufferf方法加持，就能提高效率，这个时候如果我选择再创建类，让它继承file和buffer的方法，就需要新建类，如果我有很多很多需求，子类数量就会暴涨

如果我无需创建类就能调用方法就好了，为此可以通过 **类继承实现抽象类**的关系实现类的方法共享

A需要B的方法（这里假设file需要buffer的方法），那么谁被需要，谁就持有一个抽象类对象，这样，A类只需要向B传入它的实参，再向上转型，这样A就可以借助B的性能了





**主要解决的问题**

- 避免通过继承引入静态特征，特别是在子类数量急剧膨胀的情况下。
- 允许在运行时动态地添加或修改对象的功能。

**使用场景**

- 当需要在不增加大量子类的情况下扩展类的功能。
- 当需要动态地添加或撤销对象的功能。

**实现方式**

- **定义组件接口**：创建一个接口，规定可以动态添加职责的对象的标准。
- **创建具体组件**：实现该接口的具体类，提供基本功能。
- **创建抽象装饰者**：实现同样的接口，持有一个组件接口的引用，可以在任何时候动态地添加功能。
- **创建具体装饰者**：扩展抽象装饰者，添加额外的职责。



就像孙悟空72变



以java IO流为例

```java
//组件接口
public abstract Reader_ {
    public void readFile(){}
    public void readString(){}
}

// 具体组件
	//节点流，读写功能弱
public FileReader_ extends Reader_{
    public void readFile(){
		System.out.println("正在读取文件");
    }
}

public StringReader_ extends Reader_{
    public void readString(){
		System.out.println("正在读取字符串");
    }
}
	//包装流，读写功能强
public BufferedReader_ extends Reader_{
    
    private Reader_ reader_;
    
    public BufferedReader_(Reader_ reader_){
		this.reader_ = reader_;
    }
    // 可以理解成，通过父类形参，子类实参 这种方式，共属一个接口下的子类方法实现了共享，而且随着子类实参不同，方法也是不同的，在运行过程中可以替换，即动态替换
    
    	//假设这里传入的是FileReader实例，
    public void readFile(int num){
        for(int i = 0; i < num; i++){
            reader_.readFile();
        }
    }
    
}



// Test
public static void main(){
    BufferedReader_ br_ = new BufferedRead_(new FileReader_);
    br_.readFile(10);
}
```





















































