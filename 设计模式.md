# 前奏

设计模式是模型(解决问题的方案)

目前有4大类

| 序号 | 模式 & 描述                                                  | ***\*包括\****                                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | ***\*创建型模式\**** 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 | · 工厂模式（Factory Pattern）· 抽象工厂模式（Abstract Factory Pattern）· 单例模式（Singleton Pattern）· 建造者模式（Builder Pattern）· 原型模式（Prototype Pattern） |
| 2    | ***\*结构型模式\**** 这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。 | · 适配器模式（Adapter Pattern）· 桥接模式（Bridge Pattern）· 过滤器模式（Filter、Criteria Pattern）· 组合模式（Composite Pattern）· 装饰器模式（Decorator Pattern）· 外观模式（Facade Pattern）· 享元模式（Flyweight Pattern）· 代理模式（Proxy Pattern） |
| 3    | ***\*行为型模式\**** 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。 | · 责任链模式（Chain of Responsibility Pattern）· 命令模式（Command Pattern）· 解释器模式（Interpreter Pattern）· 迭代器模式（Iterator Pattern）· 中介者模式（Mediator Pattern）· 备忘录模式（Memento Pattern）· 观察者模式（Observer Pattern）· 状态模式（State Pattern）· 空对象模式（Null Object Pattern）· 策略模式（Strategy Pattern）· 模板模式（Template Pattern）· 访问者模式（Visitor Pattern） |
| 4    | ***\*J2EE 模式\**** 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 | · MVC 模式（MVC Pattern）· 业务代表模式（Business Delegate Pattern）· 组合实体模式（Composite Entity Pattern）· 数据访问对象模式（Data Access Object Pattern）· 前端控制器模式（Front Controller Pattern）· 拦截过滤器模式（Intercepting Filter Pattern）· 服务定位器模式（Service Locator Pattern）· 传输对象模式（Transfer Object Pattern） |

 

 

![img](D:\01\技术\感获\md文档\设计模式.assets\wps3735.tmp.jpg) 

 

 

 

# 设计模式的六大原则

**1、开闭原则（Open Close Principle）**

对	扩展程序	持开放态度

对	修改程序	持关闭态度

扩展，同时又尽量避免对源代码修改，简言之，使程序易于维护和升级。

想要达到这样的效果，我们需要使用接口和抽象类。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，基类可以出现的地方，子类也一定可以。

LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件功能不受影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。

里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

接口单独设计，相互隔离，降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

一个实体应当尽量少地与其他实体之间耦合，使得系统功能模块相对独立，以免牵一发动全身。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

 







# 单例模式

饿汉式和懒汉式区别是前者无论我是否使用都会创建对象，后者只有使用时才会创建

```java
// 饿汉式
class Person{

    private String name;
    private static Person person = new Person();	//唯一实例对象

    private Person() {	// 构造方法私有化

    }

    public static Person getInstance(){// 对外接口
        return person;
    }

}
```

```java
// 懒汉式

public class Main {

    public static void main(String[] args)  {

    }

    public static class Person{

        private String name;
        private static Person person;

        private Person() {

        }

        public static Person getInstance(){
            if(person == null){
                person = new Person();
            }
            return person;
        }

    }
}
```

![image-20250702175326837](D:\01\技术\感获\md文档\设计模式.assets\image-20250702175326837.png)



# 模板模式

抽象类，内有公共部分和抽象方法，抽象部分在公共内容里，公共内容打包为方法，实现类只需要实现方法，调用打包的方法即可（通过动态调用，调用各自方法）







# 代理模式

原本直接访问目标，现在由代理访问，代理介于我和目标之间

代理在不修改目标对象的前提下，灵活地扩展或改变其行为，实现对目标功能增强或控制

代理特征

1. **代理实现和目标对象相同的接口（`Runnable`）**。这样代理对象可以替换目标对象，这样可以把目标作为参数引入，执行一些增强或控制
2. 持有目标对象（`target`）。目标对象作为参数引入
3. **委托调用目标对象的方法（`target.run()`）**（java动态调用，引入后可以用目标对象方法）。
4. **提供额外的控制接口**（`start()`，代理自身的东西）。

```java
//如线程
class ThreadProxy implements Runnable {

    private Runnable target = null; 

    @Override
    public void run() {
        System.out.println("Before running..."); // 增强逻辑
        if(target != null) {
            target.run();// 委托给目标对象执行
        }
        System.out.println("After running..."); // 增强逻辑
    }

    public ThreadProxy(Runnable target) {
        this.target = target;//持有目标对象
    }


    // 这部分不直接调用，因为
    //	接口一致性：保持与目标对象（如 Thread）相同的调用方式。
	//	可扩展性：方便未来修改或增强启动逻辑。
	//	控制访问：在启动过程中添加额外功能（如权限、监控）。
    public void start(){
        start0();
    }

    public void start0() {
        run();
    }
    
}
```

- **抽象角色**：`Runnable`接口。
- **目标角色**：通过构造函数传入的`target`对象（实现了`Runnable`）。
- **代理角色**：`ThreadProxy`类本身。



![image-20250724121115252](D:\01\技术\感获\md文档\设计模式.assets\image-20250724121115252.png)

中断不是中止，





# 修饰器设计模式

现有对象结构不变，同时获取新功能



首先，为什么需要这个模式：

有一组功能一致但面向目标不同的方法，比如IO流，有面向file、buffer、对象的

file，对象本身IO能力较弱，但如果能使用bufferf方法加持，就能提高效率，这个时候如果我选择再创建类，让它继承file和buffer的方法，就需要新建类，如果我有很多很多需求，子类数量就会暴涨

如果我无需创建类就能调用方法就好了，为此可以通过 **类继承实现抽象类**的关系实现类的方法共享

A需要B的方法（这里假设file需要buffer的方法），那么谁被需要，谁就持有一个抽象类对象，这样，A类只需要向B传入它的实参，再向上转型，这样A就可以借助B的性能了





**主要解决的问题**

- 避免通过继承引入静态特征，特别是在子类数量急剧膨胀的情况下。
- 允许在运行时动态地添加或修改对象的功能。

**使用场景**

- 当需要在不增加大量子类的情况下扩展类的功能。
- 当需要动态地添加或撤销对象的功能。

**实现方式**

- **定义组件接口**：创建一个接口，规定可以动态添加职责的对象的标准。
- **创建具体组件**：实现该接口的具体类，提供基本功能。
- **创建抽象装饰者**：实现同样的接口，持有一个组件接口的引用，可以在任何时候动态地添加功能。
- **创建具体装饰者**：扩展抽象装饰者，添加额外的职责。



就像孙悟空72变



以java IO流为例

```java
//组件接口
public abstract Reader_ {
    public void readFile(){}
    public void readString(){}
}

// 具体组件
	//节点流，读写功能弱
public FileReader_ extends Reader_{
    public void readFile(){
		System.out.println("正在读取文件");
    }
}

public StringReader_ extends Reader_{
    public void readString(){
		System.out.println("正在读取字符串");
    }
}
	//包装流，读写功能强
public BufferedReader_ extends Reader_{
    
    private Reader_ reader_;
    
    public BufferedReader_(Reader_ reader_){
		this.reader_ = reader_;
    }
    // 可以理解成，通过父类形参，子类实参 这种方式，共属一个接口下的子类方法实现了共享，而且随着子类实参不同，方法也是不同的，在运行过程中可以替换，即动态替换
    
    	//假设这里传入的是FileReader实例，
    public void readFile(int num){
        for(int i = 0; i < num; i++){
            reader_.readFile();
        }
    }
    
}



// Test
public static void main(){
    BufferedReader_ br_ = new BufferedRead_(new FileReader_);
    br_.readFile(10);
}
```





















































